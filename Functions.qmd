---
title: "Основы функционального программирования"
---

Кроме того, что R является интерпретируемым языком, это еще и язык функционального программирования (ФП). Это означает, что R содержит множество инструментов для создания и манипулирования функциями. Более того, функции могут быть рассмотрены как [*объекты первого класса*](https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8_%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%B3%D0%BE_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0), то есть мы можем делать с функциями то же самое, что и с векторами: присваивать их переменным, сохранять их как списки, передавать в качестве аргументов другим функциям, создавать функции внутри функций и даже возвращать их в качестве результата.

Зачем нам, социологам, уметь разбираться и писать собственные функции? Это важно по нескольким причинам. Во-первых, знание о том, как функции устроены, поможет нам использовать R более осознанно, с четким пониманием того, что происходит, когда мы запускаем ту или иную команду. Поначалу может казаться, что писать свои функции это нечто запредельное, что-то доступное только программистам или специалистам с техническим образованием. Но по мере того, как вы будете овладевать языком, писать больше кода и проводить анализ на R, вы поймете, что собственные, пусть и не очень сложные функции, могут помочь автоматизировать некоторые рутинные задачи (например, по перекодировке или чистке данных, создани. однотипных объектов, таких как таблицы или графики) и, в конечном итоге, сделают вашу работу в R быстрой и эффективной.

Так, что же такое функция? Давайте разбираться.

## Понятие функции и ее основные элементы

Функция представляет собой набор утверждений, организованных вместе для выполнения определенной задачи.

Это часть программного кода, имеющий определенное имя, который может быть вызван сам по себе или в других частях программы.

::: {.callout-note appearance="minimal"}
В R имеется множество встроенных функций, и огромное количество дополнительных функций можно найти в различных библиотеках. Каждый пользователь может создавать свои собственные функции.
:::

::: {.callout-important appearance="minimal"}
Функция является объектом, и значит интерпретатор R может проверить, насколько хорошо функция выполняется, нужны ли функции какие-то аргументы для выполнения и есть ли у программы достаточно информации, чтобы все сделать так, как описано в функции.
:::

::: {.callout-note appearance="minimal"}
В свою очередь функция выполняет задачу и выдает (возвращает, return) какие-то результаты, которые могут быть сохранены в дальнейшем как отдельные объекты.
:::

**Формула функции**

В R функция создается очень просто - с помощью ключевого слова `function`. Базовый синтаксис у функции следующий:

```{r eval=F}

function_name <- function(arg_1, arg_2, ...) {
   Function body 
}
```

**Компоненты функции**

У функции есть несколько частей

::: {.alert .alert-info role="alert"}
**Function Name (имя функции)** − тут все просто - это имя функции, которое хранится в окружении и обозначает конкретный объект (то есть саму функцию). Зная имя функции, ее можно вызвать в любое время и вставить в любую часть программного кода.
:::

::: {.alert .alert-danger role="alert"}
**Arguments (аргументы)** − это те элементы, параметры, значения, которые вводятся в функцию, чтобы она работала. Аргументы не являются обзательными, функция может иногда работать и без них, либо они могут быть указаны по умолчанию.
:::

::: {.alert .alert-success role="alert"}
**Function Body (тело функции)** − пожалуй, самая главная часть функции, содержащая утверждения, определяющие то, что именно делает данная функция.
:::

::: {.alert .alert-warning role="alert"}
**Return Value (возвращаемое значение)** − возвращаемое значение - это результат обработки последнего выражения в теле функции, то есть ее конечный результат. Если в функции заложено множество действий - то это последнее действие.
:::

## Встроенные функции

Можно привести огромное количество базовых функций, таких как `seq()`, `mean()`, `max()`, `sum(x)`, `paste(...)` и т. д. Они вызываются напрямую при написании программы.

```{r eval=F}
# Создать последовательность чисел от 32 до 44
seq(32,44)

# Найти среднее чисел от 25 до 82.
mean(25:82)

# Найти сумму чисел от 41 до 68.
sum(41:68)
```

## Функции apply(), lapply(), sapply(), tapply()

Семейство функций `apply()` позволяет производить различные преобразования с отдельными элементами векторов, матриц и датафреймов. Такие действия в процессе анализа данных приходится проводить довольно часто. Например, нам может потребоваться сдвинуть значения переменных на какую либо константу, или провести трансформации, необходимые для нормализации данных.

### apply()

Общая формула для функции `apply()`:

`apply(data, MARGIN, FUN)`,

Где:

-   `data`: массив или матрица
-   `MARGIN`: данный аргумент принимает значения 1 или 2
-   `MARGIN=1`: манипуляции проводятся со строками
-   `MARGIN=2`: манипуляции проводятся со столбцами
-   `MARGIN=c(1,2)`: манипуляции проводятся со строками и столбцами одновременно
-   `FUN`: функция, которую необходимо применить, например, рассчитать среднее `mean()`, медиану `median()`, сумму `sum()`, минимум `min()`, максимум `max()` и др. Также можно применить пользовательские функции.

Простой пример применения данной функции - суммировать данные по столбцам (запустите код ниже и посмотрите на результат в последней строке):

```{r eval=FALSE}
m1 <- matrix(1:10,nrow=5, ncol=6)
m1
a_m1 <- apply(m1, 2, sum)

a_m1
```

{{< iconify arcticons writer size=42px >}} **Самостоятельное задание**: попробуйте изменить код так, чтобы сумма считалась не по столбцу, а по строке.

### lapply()

Функция `lapply()` полезна для осуществления операций над списками и возвращает список объектов такой же длины. При этом каждый объект является результатом применения функции к элементу исходного списка. Эта функция может применяться к спискам, векторам или датафрейму, но на выходе - всегда список.

Общая формула:

`lapply(data, FUN)`

Аргументы:

-   `data`: вектор или другой объект
-   `FUN`: функцию, которую мы собираемся применять к каждому объекту x.

`l` в функции `lapply()` обозначает `list` (список). Различия между `lapply()` и `apply()` заключаются именно в формате вывода.

функции `lapply()` не требуется аргумент MARGIN.

Приведем примеры. Допустим, у нас есть список, в котором содержатся два элемента - вектор A и датафрейм B. Предположим, что нам нужно посчитать сумму по каждому элементу списка (отдельно у вектора и у датафрейма).

```{r }
a <- list(A = c(8, 9, 7, 5),
          B = data.frame(x = 1:5, y = c(5, 1, 0, 2, 3)))
a
lapply(a, sum)
```

Еще один пример - со строковыми данными. Поменяем названия фильмов с большой буквы на маленькую.

```{r }
movies <- c("SPYDERMAN","BATMAN","VERTIGO","CHINATOWN")
movies_lower <-lapply(movies, tolower)
movies
movies_lower
```

Чтобы значения из списка опять стали вектором, нужно применить функцию `unlist()`.

```{r}
unlist(movies_lower)
```


{{< iconify arcticons writer size=42px >}}**Самостоятельное задание**: создайте список из двух датафреймов, в каждом из которых содержалось бы по две переменных с 5 значениями. Затем примените функцию `lapply()` для того, чтобы поcчитать максимальные значения в каждом датафрейме (функция `max()`). 

### sapply()

Функция `sapply()` используются со списками, векторами или датафреймами и на выходе дают вектор или матрицу. Функция полезна для операций над списками, она работает почти так же, как и `lapply()`, только возвращает вектор.

Приведем пример с известным набором `cars`, в котором содержится информация о скорости и тормозном пути машин 1920-х гг.

Применим функцию `sapply()`, чтобы посчитать минимальные значения:

```{r}
sapply(cars, min)
```

Сравним с `lapply()`:

```{r}
lapply(cars, min)
```

### tapply()

Функции `tapply()` рассчитывает какой-либо показатель (среднее, моду, медиану, минимум, максимум и т.д.) или применяет пользовательскую функцию к каждому элементу вектора в зависимости от уровней факторной переменной. Очень полезная функция, позволяющая отобрать значения и применить функцию именно к ним (провести анализ по группам).

Общая формула:

`tapply(data, INDEX, FUN = NULL, ...)`

Аргументы:

-   `data`: данные, которые мы хотим агрегировать с помощью `tapply`
-   `INDEX`: список факторов (группирующих переменных)
-   `FUN`: функция, которую нужно применить к каждому элементу x
-   `...`: другие аргументы, которые мы можем передать функции.

В процессе анализа данных очень часто возникает необходимость подсчета каких-либо показателей, например, посчитать средние значения в группах наблюдений, образованных на основе каких-либо характеристик. Примеры: проанализировать средний уровень доходов в зависимости от региона, страны, социального статуса и т.д.

Чтобы понять, как это работает, давайе воспользумся датасетом `iris`, встроенным в базовый R, содержащий измерения 4 параметров (ширина и длина лепестков и чашелистников) у 50 цветков ирисов, принадлежащих к трем различным видам - setosa, versicolor и virginica:

![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRScUmZqCyTspdxKSXGiS_BJKZdp9M059v-7eLoA2fs&s)

Это хорошо известный в сфере машинного обучения набор данных, который в используется, например, для иллюстрации того, как можно разработать модели, позволяющие предсказать принадлежность к одному из классов.

Мы можем использовать функцию `tapply()`, чтобы посчитать медианные значения ширины чашелистника для каждого вида:

```{r}
tapply(iris$Sepal.Width, iris$Species, median)# знак $ позволяет обратиться к отдельной переменной в наборе данных, Sepal.Width - переменная, хранящая значения ширины чашелистника, Species - переменная принадлежности к виду.
```

{{< iconify arcticons writer size=42px >}} **Самостоятельное задание**: попробуйте применить функцию `tapply()` к другим переменным набора - `Sepal.Length`, `Petal.Width`, `Petal.Length`, заменив медиану на максимальное значение (функция `max()`).

## Пользовательские функции

Кроме встроенных или находящихся в загруженных библиотеках мы легко можем создавать свои собственные функции. Они могут быть достаточно специфическими и использоваться для решения различных задач. Если какое-то однотипное действие выполняется множетсво раз, стоит подумать о создании функции, которая может автоматизировать этот процесс. Однажды созданная функция может потом использоваться наравне со встроенными.

Рассмотрим некоторые особенности создания и использования пользовательских функций.

### Пример простой функции

Предположим, нам нужна функция, которая бы возводила в квадрат какое-то число:

```{r}
square<- function(a) {
   return(a^2)
}	
# Пробуем вызвать эту функцию, задав в качестве аргумента цифру 6.
square(6)
```

Давайте посмотрим на то, как устроена эта функция.

-   Первая строка:

`square<- function(a) {`

Мы даем функции имя - **square** - оно должно нам подсказывать, что функция имеет дело с квадратами))) Впрочем, имя может быть любым, например, **my_function**.

Далее следует оператор присваивания `<-` и ключевое слово `function`, за которым в скобках указывается какой-то аргумент, с которым будут далее происходить какие-то трансформации.

Мы видим, что в нашей функции аргумент один - `a`.

Заканчивается строка открывающейся фигурной скобкой.

Далее следует **тело функции**.

-   Вторая строка:

`return(a^2)`

Поскольку функция простая, мы сразу получаем **return value** - возвращаемое значение.

Обратите внимание, что в конце функции обязательно ставится закрывающая фигурная скобка.

### Вызов функции без аргумента

Рассмотрим еще один пример:

```{r}
# Создаем функцию без аргумента
seq_squared5 <- function() {
  seq<-1:5
  return(seq^2)

}	

# Запускаем функцию
seq_squared5()
```

Что изменилось? Изменилось то, в первой функции мы указывали аргумент, а во второй все вычисления сразу "зашиты" в нашу функцию и она может выполнять только одно дело - формировать последовательность от 1 до 5 и возводить каждое число в квадрат.

### Создание функции с аргументами, различающимися по позиции и именам

Аргументы функции могут предоставляться в той же последовательности, в которой они написаны в функции, без указания имен, или в другой последовательности, но с обязательным указанием имени.

Рассмотрим пример функции, в которой есть три аргумента и которая выполняет следующие действия: первые два аргумента перемножаются, а затем к произведению прибавляется третий аргумент.

```{r}
# Создаем функцию с аргументами.
function3 <- function(a,b,c) {
   result <- a * b + c
   print(result)
}

# Вызываем функцию, перечисляя аргументы по порядку.
function3(5,3,11)

# Вызываем фунцию, называя аргументы поименно.
function3(a = 11, b = 5, c = 3)
```

Попробуйте поменять аргументы местами и посмотреть, как будет вести себя функция.

### Создание функции с аргументами по умолчанию

Мы можем определить значение аргумента функции в ходе ее определения и запустить функцию без дополнительного назначения аргументов. В этом случае мы получим некоторый результат по умолчанию. Но мы можем изменить эти исходные значения, и получить новый результат.

Простой пример такой функции:

```{r}
# Создаем новую функцию с аргументами.
function4 <- function(a = 3, b = 6) {
   result <- a * b
   print(result)
}

# Запускаем функцию без аргументов в скобках.
function4()

# Вызываем функцию с новыми значениями аргументов.
function4(9,5)
```

### "Ленивая" (Lazy) обработка аргументов функции

Аргументы в функции обрабатываются "лениво" (да-да, в жаргоне программистов есть именно такие выражения - "ленивая функция", "ленивая загрузка", "ленивая обработка"), что означает, что эти аргументы вызываются и обрабатываются только в определенный момент времени, когда это требует функция.

```{r eval=FALSE}
# Создаем функцию с двумя аргументами.
new.function <- function(a, b) {
   print(a^2)
   print(a)
   print(b)
}

# Пробуем применить функцию только с одним аргументом.
new.function(6)
```

Функция требует два аргумента, но мы предоставили только один, и поскольку имен мы не указывали, по умлочанию наша функция определила этот аргумент как первый, то есть аргумент a. До определенного момента все было "ок", поскольку аргумент b не был нужен, но как только дело дошло до строчки print(b) - обнаружилось, что аргумент b отсутствует, и появилась ошибка.

## Самостоятельная работа

**Упражнение 1** Создайте функцию, которая будет возвращать сумму двух чисел. Назовите функцию `mysum`.

**Упражнение 2** Создайте функцию, проверяющую принадлежность числа некоторому вектору. Если число в векторе содержится, функция должна вернуть `TRUE`.

**Упражнение 3** Создайте функцию, на входе которой будет даваться датафрейм, а на выходе - наименование каждой переменной и тип (класс) данных, которые в них содержатся. Например, переменная1 числовая.

**Упражнение 4** Создать функцию, аргументами которой являются вектор и число. На выходе функция должна показывать, сколько раз число встречается в данном векторе.

{"title":"Tidyverse и трансформация данных","markdown":{"yaml":{"title":"Tidyverse и трансформация данных"},"headingText":"Tidyverse - все нужные библиотеки в одном месте!","containsRefs":false,"markdown":"\n\n```{r setup, echo=FALSE}\nlibrary(kableExtra)\n```\n\n```{css, echo = FALSE}\n.output {\nmax-height: 500px;\noverflow-y: scroll;\n}\n```\n\nВ рамках данного занятия мы будем работать с библиотекой [tidyverse](https://www.tidyverse.org/), объединяющей возможности нескольких других библиотек и воплощающей общую философию, дизайн и грамматику обработки и анализа данных, разработанную RStudio: ![](https://hbctraining.github.io/Intro-to-R/img/tidyverse_website.png)\n\nОсновные библиотеки семейства tidyverse:\n\n-   **ggplot2** - библиотека для создания разнообразных визуализаций на основе пользовательских данных и заданных настроек.\n-   **dplyr** - библиотека для основных трансформаций данных (отбор, фильтрация, группировка, создание новых переменных, описательный анализ).\n-   **tidyr** - набор функций для подготовки данных к анализу (транспонирование, переструктурированые данных).\n-   **readr** работа с данными прямоугольного формата, представленными в формате csv, tsv или fwf.\n-   **tibble** - специальная библиотека для работы с датафреймами.\n-   **stringr** - набор функций для работы со строковыми переменными.\n-   **forcats** - библиотека для работы с факторными (категориальными - номинальными и порядковыми) перемннными.\n\n::: callout-tip\n\nНа предыдущем занятии мы осуществляли импорт и экспорт данных, используя некоторые библиотеки, входящие во вселенную `Tidyverse`. Загружая библиотеку Tidyverse, мы автоматически загружаем все остальные, и потребность в загрузке отдельных библиотек отпадает.\n:::\n\n## Прямоугольные и непрямоугольные таблицы, а также tidy и messy данные\n\nДанные могут быть представлены в различных формах, но на самом базовом уровне их можно представить в виде двух типов структур: данные представленные в виде прямоугольных таблиц и непрямоугольных данных.\n\nПрямоугольные данные имеют форму прямоугольника (действительно!), то есть каждое значение соответствует какой-то строке и столбцу. Большинство датафреймов содержат как раз прямоугольные данные.\n\nСоответственно непрямоугольные данные не могут так легко распределяться по строкам и столбцам, они, как правило, представляют собой совокупность различных структур данных, в которых между отдельными элементами имеется какое-то сходство. Обычно непрямоугольные данные хранятся в списках.\n\n**Tidy** по-английски означает \"чистый, аккуратный, опрятный\". По отношению к данным выражение - tidy data - \"чистые, правильным образом представленные данные\" противопоставляется \"messy data\" - \"грязным данным\", представленным в виде, не совсем пригодном или удобном для анализа.\n\n`Tidy data` - это когда данные имеют так называемый \"длинный формат\" - каждый столбец представляет собой отдельную переменную, а строка - наблюдение или случай.\n\n![](https://www.researchgate.net/publication/338569186/figure/fig1/AS:847073150775297@1578969385585/The-wide-versus-tidy-data-format-for-time-dependent-data-In-the-wide-spreadsheet-like.png){width=\"400\"}\n\nКак из «грязных» данных сделать «чистые»? Как привести набор данных к виду, пригодному для дальнейшего анализа, отобрать нужные переменные, преобразовать их в формат, который нужен для решения аналитической задачи?\n\nВ рамках данного раздела будут рассмотрены функции, которые используются для трансформации данных - их чистки, фильтрации, вычисления новых переменных и описательных статистик, а также перевода набора данных из «широкого» в «длинный» и обратно.\n\nВ основном мы будем работать с двумя библиотеками семейства `tidyverse` - `dplyr` и `tidyr`.\n\n![](https://dplyr.tidyverse.org/logo.png), ![](https://tidyr.tidyverse.org/logo.png)\n\nЭти библиотеки является одними из лучших для разнообразных трансформаций данных, потребность в которых возникает постоянно в процессе анализа.\n\nРассмотрим основные функции на примере набора данных `flights` из библиотеки - `nycflights13`, в котором содержится информация о 336 776 полетах, совершенных из аэропорта Нью-Йорка в 2013 году. Данные предоставлены Бюро по статистике США, справку по ним можно найти по запросу `?flights`.\n\n## Фильтрация строк - filter()\n\nПрежде, чем начать, установим библиотеки:\n\n```{r eval=FALSE, message=FALSE}\ninstall.packages(c(\"nycflights13\", \"tidyverse\"))\n```\n\nТеперь загрузим их в наше рабочее пространство:\n\n```{r message=FALSE}\nlibrary(tidyverse)\nlibrary(nycflights13)\n```\n\nВ наборе данных `flights` содержится следующая информация о переменных:\n\n-   year (год), month (месяц), day (день) - дата вылета\n-   dep_time - время вылета\n-   arr_time - время прилета\n-   sched_dep_time, sched_arr_time - время вылета и прилета по расписанию.\n-   dep_delay, arr_delay - задержка вылета и прилета в минутах. Отрицательные значения означают досрочные вылеты / прилеты.\n-   carrier - перевозчик\n-   flight - номер рейса\n-   tailnum - номер самолета\n-   origin, dest - место отправления, место назначения\n-   air_time - время полета в минутах\n-   distance - расстояние в милях\n-   hour, minute - часов, минут - время отлета, разбитое по часам и минутам\n-   time_hour - дата и время полета по расписанию в формате даты.\n\nДавайте сначала просто посмотрим на эти данные:\n\n```{r}\nhead(flights)\n```\n\nФункция `filter()` позволяет отобрать наблюдения, основываясь на значениях. Первый аргумент - имя датафрейма (массива, базы данных), второй и последующие аргументы - выражения, позволяющие отфильтровать данные. Например, мы хотим отобрать все полеты, которые произошли 1 января:\n\n```{r}\nfilter(flights, month == 1, day == 1)\n```\n\nКогда мы запускаем эту строку с кодом, `dplyr` выполняет фильтрующую операцию и выводит новый датафрейм. Однако, стоит учитывать, что исходные данные не меняются, и если нам необходимо сохранить эти изменения как отдельный объект, нам нужно использовать оператор присваивания, \\<-, и задать новое имя:\n\n```{r}\njan1 <- filter(flights, month == 1, day == 1)\n```\n\nR либо выводит на экран результаты либо сохраняет их в новую переменную (объект). Если мы хотим одновременно создать новую базу данных, сохранить в нее результаты фильтрации и вывести результат на экран, нужно код заключить в скобки:\n\n```{r}\n(dec25 <- filter(flights, month == 12, day == 25))\n```\n\n## Логические операторы\n\nОчень часто функция `filter()` сопровождается логическими операторами (\"и\", \"или\" и др.). В этом случае, результат каждого выражения должен быть истинным, для того, чтобы строки были отобраны в новый набор.\n\n::: callout-tip\n**Запомним основные операторы**\n\n**&** это “и”\n\n**\\|** это “или”\n\n**!** “не равно”\n:::\n\nГрафически различия между операторами можно представить следующим образом:\n\n![](https://d33wubrfki0l68.cloudfront.net/01f4b6d39d2be8269740a3ad7946faa79f7243cf/8369a/diagrams/transform-logical.png)\n\nНапример, давайте отфильтруем данные так, чтобы у нас отображались два месяца - ноябрь и декабрь.\n\n```{r}\nfilter(flights, month == 11 | month == 12)\n```\n\nДля некоторого упрощения кода полезно будет запомнить [\"законы де Моргана\"](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BA%D0%BE%D0%BD%D1%8B_%D0%B4%D0%B5_%D0%9C%D0%BE%D1%80%D0%B3%D0%B0%D0%BD%D0%B0):\n\n!(x & y) это то же самое, что и !x \\| !y,\n\n!(x \\| y) равносильно !x & !y.\n\nНапример, если нам нужно отобрать полеты, которые задерживались (по прилетам и отлетам) не более чем на два часа, мы могли бы пойти двумя путями:\n\n```{r}\nfilter(flights, !(arr_delay > 120 | dep_delay > 120))\n# Или (результат идентичный)\nfilter(flights, arr_delay <= 120, dep_delay <= 120)\n```\n\n{{< iconify arcticons writer size=42px >}} **Самостоятельное задание**:\n\n1.  Создайте набор данных `arr_depay_over120`, в который отберите рейсы, прилет которых (arr_delay) задерживался на 2 или более часа.\n2.  Выгрузите данные о рейсах в аэропорты Хьюстона - George Bush Intercontinental (IAH) или аэропорт William P Hobby (HOU) (по переменной `dest`) и сохраните их под именем `IAH_OR_HOU`.\n3.  Отберите из таблицы все полеты, которые совершались в летние месяцы, и сохраните их под именем `summer_flights`.\n\n## Упорядочение строк с функцией arrange()\n\nФункция `arrange()` работает практически идентично с `filter()`, однако, вместо отбора строк она меняет их порядок. На входе функция берет датафрейм и наименования столбцов, по которым нужно сделать сортировку.Если таких столбцов несколько, каждая дополнительная колонка может быть использована для сортировки значений по уже отсортированным значениям предыдущего столбца.\n\nНапример, отсортируем полеты по дате (сначала по месяцу, потом по дню):\n\n```{r}\narrange(flights, month, day)\n```\n\nЕсли нам нужно отсортировать что-то по убыванию, то функция `desc()` поможет нам перегруппировать значения в столбце. Например, отсортируем по убыванию значения задержки отлета:\n\n```{r}\narrange(flights, desc(dep_delay))\n```\n\n\\*\\* ! Пропущенные значения (NA) - всегда располагаются в конце списка, независимо от направления сортировки\\*\\*. Давайте воспроизведем это свойство на примере, содержащем небольшое количество строк:\n\n```{r}\ndf <- tibble(x = c(5, 2, NA))\narrange(df, x)\narrange(df, desc(x))\n```\n\n{{< iconify arcticons writer size=42px >}} **Самостоятельное задание**:\n\n1.  Отсортируйте полеты, чтобы найти те, что имеют наибольшие значения времени задержки прилета (`arr_delay`). Найдите также полеты, которые вылетели раньше времени по расписанию (вспоминаем функцию `tail()`).\n2.  Найдите самые короткие (быстрые) полеты по переменной `air_time`.\n\n## Отбор переменных с функцией select()\n\nДостаточно часто нам для анализа не нужен весь наш набор данных, а только ограниченный набор переменных, с которыми мы работаем в какой-то момент времени. Удобно и полезно отобрать эти переменные и работать только с ними, особенно - если данных очень много, и количество переменных исчисляется сотнями или тысячами. Функция `select()` позволяет быстро отобрать переменные по их именам:\n\n```{r}\nselect(flights, year, month, day)\n```\n\n```{r}\n\nselect(flights, year:day) # если переменные идут подряд, не обязательно перечислять все, можно воспользоваться оператором :\n```\n\n```{r}\nselect(flights, -(year:day))# знак минуса используется для того, чтобы, наоборот, исключить какие-то переменные\n```\n\nЕсть еще несколько полезных функций, которые идут в паре с select() и делают жизнь проще:\n\n`starts_with(\"abc\")`: имена переменных начинаются на “abc”.\n\n`ends_with(\"xyz\")`: имена переменных заканчиваются на “xyz”.\n\n`contains(\"ijk\")`: имя переменной содержит “ijk”.\n\nИногда, в процессе обработки нам требуется переименовать переменную другим способом. Для этой цели подходит функция `rename`:\n\n```{r}\nrename(flights, tail_num = tailnum)\n```\n\n{{< iconify arcticons writer size=42px >}} **Самостоятельное задание**:\n\n1.  Использовать все возможные способы для того, чтобы отобрать переменные dep_time, dep_delay, arr_time и arr_delay.\n2.  Что случится, если Вы включите одну и ту же переменную несколько раз в запрос функции select()?\n\n## Создаем новую переменную с функцией mutate()\n\nДа, сейчас явно что-то будет про мутации)))\n\nПомимо того, что в процессе анализа нам приходится что-то постоянно отбирать (например, только жителей сел или городов, какой-то регион исследования, лиц определенного возраста и пола), часто приходится вычислять новые переменные на основе старых - высчитывать возраст, средний доход, количество детей и т. д.\n\nВ этом нам может помочь функция `mutate()`.\n\n{{< iconify arcticons zte-task-manager size=42px >}}**Пример**: создадим новый набор `flights_sml`, куда отберем даты полета, расстояние и переменные, оканчивающиеся на \"delay\". Затем, содадим две новых переменных:\n\n-   скорость (speed)\n-   количество минут, которые самолет смог догнать при задержке рейса (как разность между задержкой вылета и прилета) (gain).\n\n```{r}\nflights_sml <- select(flights,\n  year:day,\n  ends_with(\"delay\"),\n  distance,\n  air_time\n)\nmutate(flights_sml,\n  gain = dep_delay - arr_delay,\n  speed = distance / (air_time / 60)\n)\n```\n\nОтметим, что мы можем «не отходя от кассы» использовать новые переменные в последующих расчетах для создания других переменных. Например, давайте создадим переменную `gain` (см. пример выше), но и посчитаем время полета в часах и среднее количество минут, которое нагонял самолет каждый час:\n\n```{r}\nmutate(flights_sml,\n  gain = dep_delay - arr_delay,\n  hours = air_time / 60,\n  gain_per_hour = gain / hours\n)\n```\n\n{{< iconify arcticons writer size=42px >}} **Самостоятельное задание**:\n\n1.  Сравните `` air_time` и `arr_time - dep_time ``. Что мы можем увидеть? Какие выводы можно сделать?\n2.  Сравните `dep_time`, `sched_dep_time` и `dep_delay`. Как эти переменные связаны друг с другом?\n3.  На основе уже знакомого нам набора `iris` создайте новую переменную - `sepal_ratio`, в которой посчитайте отношение длины чашелистника (`Sepal.Length`) к его ширине (`Sepal.Width`) и переменную `petal_ratio`, в которой посчитайте отношение длины лепестка (`Petal.Length`) к его ширине (`Petal.Width`). Сохраните данные в новом наборе `iris2`.\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Если трудно, код можно посмотреть здесь\"\niris2<- mutate(iris, sepal_ratio=Sepal.Length/Sepal.Width, petal_ratio=Petal.Length/Petal.Width)\n```\n\n## Изменения в нескольких переменных: mutate + across\n\nФункция `mutate()` не обязательно означает, что мы будем вычислять новые переменные, вполне возможно мы будем как-то видоизменять те переменные, которые у нас уже есть в наборе данных. Например, мы хотим округлить значение только что полученных нами переменных `sepal_ratio` `petal_ratio` (см. самостоятельная работа выше, упражнение 3) до одного знака после запятой.\n\n```{r echo=FALSE}\niris2<-as.tibble(iris2)\n```\n\n```{r message=FALSE, warning=FALSE}\nmutate(iris2, across(c(sepal_ratio, petal_ratio), round, 1))# функция round используется для округления, цифра 1 означает, что мы будем округлять до одного знака после запятой \n```\n\nМы могли бы написать наш код чуть по-другому:\n\n```{r}\niris2 %>%\n  mutate(across(c(sepal_ratio, petal_ratio), round, 1))\n```\n\n::: callout-info\nСтоп! Что за новый знак %\\>%?\n\nЭто оператор, который позволяет сократить код и написать его по типу \"матрешки\". По-английски это называется \"pipe-operator\", здесь явная аналогия с телескопическими трубами, которые как бы вкладываются друг с другом. Так и наши различные функции dplyr следуют друг за другом уже без лиших аргументов и дублирования информации о наборе данных, лишних скобок и знаков \\$, с помощью которых мы вводим имя переменной из набора. Код становится более читаемым и быстрым.\n:::\n\nГрафически это можно представить вот так:\n\n![](https://i0.wp.com/www.rforecology.com/pipes_image0.png) В `dplyr` оператор `%>%` попал из библиотеки `magrittr`, разработчики которой (Stefan Milton Bache, Hadley Wickham, Lionel Henry) преследовали две основных цели - сократить процесс написания кода и улучить его поддержку.\n\nНазвана библиотека в честь бельгийского художника-сюрреалиста Рене Магритта (1898-1967), который был известен своими остроумными и загадочными работами.\n\n![](https://www.marcianocontemporary.com/wp-content/uploads/2022/02/rene-magritte-surrealiste-4094.jpeg) Причем тут трубы, спросите вы? А вот причем. У Магритта есть одна знаменитая картина -- «Вероломство образов», которую автор создал в 1929 году, увлекшись исследованием связи в искусстве между словами и образами. На картине изображена курительная трубка, выглядит она очень правдоподобно и нарисована тщательно. Вдоль нижней кромки полотна идет надпись, сделанная крупным каллиграфическим почерком: «Ceci n'est pas une pipe» - «Это не трубка». Картина породила множество интерпретаций, а сам автор по поводу нее сказал следующее: «Разве я написал неправду? Да, на картине нарисована трубка, но разве вы можете раскурить ее? Нет, потому что это всего лишь репрезентация. И если бы я написал \"Это - трубка\", то я бы солгал!».\n\n![](https://arthive.net/res/media/img/oy800/work/3b9/295282@2x.webp) В общем, разработчики отдали дань творчеству автора, и в языке R появился новый оператор.\n\n::: callout-tip\nЧтобы быстро набрать пайп-оператор нужно одновременно нажать три клавиши:\n\n**Ctrl+Shift+M**\n:::\n\nНачиная с версии R 4.1.0. в базовом R появился свой, «нативный» оператор, почти аналогичный `%>%`. Выглядит он как `|<` и \"ведет себя\" почти всегда так же. Есть некоторые нюансы, однако обсуждать мы их пока не будем. В качестве дополнительного матерала для тех, кто хочет действительно разобраться, отсылаю к статье: https://www.tidyverse.org/blog/2023/04/base-vs-magrittr-pipe/\n\nВ настройках RStudio можно указать, какой именно операторв вы хотите использовать, но только один: ![](https://i.stack.imgur.com/wx9mN.png)\n\n## Вычисление основных статистик с функцией `summarise()` и `group_by()`\n\nЕще одна функция, которую мы изучим в рамках данного урока, -- `summarise()`. Как следует из названия, ее предназначение - рассчитывать какие-то новые значения на основе разнообразных функций - арифметических, статистических и др. Например, посчитаем среднее количество минут задержки вылета по набору полетов:\n\n```{r}\nsummarise(flights, dep_delay_mean = mean(dep_delay, na.rm = TRUE))#na.rm = TRUE - данный аргумент удаляет из анализа все пропущенные значения (na - not avaliable, rm - remove), в противном случае вычисление среднего не возможно.\n```\n\nФункция `summarise()` часто идет в паре с другой функцией - `group_by()`, позволяющей провести анализ в отдельных подгруппах. Соответственно, когда мы применяем функции `dplyr` к сгруппированным данным, они автоматически рассчитываются для каждой подгруппы по отдельности. Например, мы можем применить код из примера выше, но предварительно сгруппировать данные по месяцам. Получится следующее:\n\n```{r}\nflights %>%\ngroup_by(month) %>%\nsummarise(dep_delay_delay = mean(dep_delay, na.rm = TRUE))\n```\n\nИз таблицы видно, что рейсы в среднем задерживались чаще в летние месяцы (июне и июле) и декабре.\n\nПриведем еще один пример совместного использования функций: проведем группировку по месту назначения и посчитаем общее количество полетов, среднее расстояние и среднюю задержку вылета в минутах, а также отберем 5 направлений с максимальными средними значениями по задержке вылетов и 5 направлений с минимальным задержками:\n\n```{r}\ndelays <- flights %>%\n  group_by(dest) %>%\n  summarise(\n    Всего = n(),\n    Сред_расст = mean(distance, na.rm = TRUE),\n    Ср_задержка_вылета = mean(arr_delay, na.rm = TRUE)\n  ) %>% \n  arrange(desc(Ср_задержка_вылета)) %>% \n  slice(c(1:5, n()-5:n()))#slice отбирает строки, в скобках указываются номера, 1:5 - первые пять, а n()-5:n() - последние пять: n()-5 - номер строки минус 5 указывает на начало интервала,n() - общее количество строк - на конец. Мы могли бы указать это как 101:105, но допустим, мы не знаем, сколько строк, такой подход позволяет избежать ручного ввода номеров строк.\ndelays\n```\n\nХотя в таблице :::callout-note Другие полезные функции: - median() - медиана - sd() - стандартное отклонение - min() - минимум - max() - максимум - first() - первое значение - nth() - значение определенного порядка (2, 3 и т.д.) - last() - последнее - n() - количество, размер группы - n_distinct() - количество уникальных значений :::\n\nНапример:\n\n```{r}\nflights %>%\nna.omit() %>% #na.omit() - опускает пропущенные значения\ngroup_by(month) %>%\n  summarise(\n    first_dep = first(dep_time),\n    last_dep = last(dep_time)\n  )\n```\n\nЕще пример: сгруппируем полеты по месту назначения и посчитаем уникальных перевозчиков, отсортировав нашу таблицу по месту назначения.\n\n```{r}\nflights %>%\nna.omit() %>%\ngroup_by(dest) %>%\n  summarise(carriers = n_distinct(carrier)) %>%\n  arrange(desc(carriers))\n```\n\n## Сочетание нескольких трансформаций (mutate, filter, summarise)\n\nГруппировка обычно сопутствует функции `summarise()`,но ее также можно сочетать с `mutate()` и `filter()`:\n\nНапример, мы хотим оставить в наболе данные только по наиболее популярным направлениям, принявшим не менее 5000 полетов за год:\n\n```{r}\nflights %>%\n  group_by(dest) %>%\n  filter(n()>17000)\n```\n\nИли, например, нам понадобилось посчитать по каждому направлению среднее количество полетов и сохранить его в переменной `mean`:\n\n```{r}\nflights %>%\n  group_by(dest) %>%\n  mutate(mean=mean(n()), .keep = \"used\") #.keep = \"used\" - оставляет в наборе только используемые переменные, в противном случае останется весь набор\n```\n\n## Создание новых переменных из старых по условиям: `if_else()` и `case_when()`\n\nТакого рода перекодировки в исследовательской практике встречаются очень часто, когда мы хотим объединить некоторые значения в группы или заменить на другие значения. В решении этой задачи нам помогут две полезные функции: `if_else()`и `case_when()`.\n\n### if_else()\n\nЭта функция позволяет нам перекодировать значения, совпадающие или несовпадающие с некоторым условием, и одновременно обрабатывать отсутствующие значения. Для того, чтобы корректно применить эту функцию, нам нужно знать, какое значение в наших данных будет условно «истинным, корректным», какое «ложным, неправильным», и какое значение будут принимать пропущенные значения.\n\nОбщая формула для этой функции выглядит так:\n\n`if_else(condition, true, false, missing = NULL)`\n\nВ аргументах функции задается следующее: `condition` - условие, которое мы проверяем `true` - значение, которое присваиваем, если условие выполняется `false`- значение, которое присваиваем, если условие не выполняется.\n\nПриведем простой пример: Создадим вектор `x`, содержащий значения от -10 до +10, а затем все положительные значения заменим на 555:\n\n```{r}\nx <- c(-10:10)\nif_else(x > 0, 555, x)\n```\n\nКонструкция `if_else()` очень часто используется вместе с `mutate()`для того, чтобы создать новые переменные.\n\nДавайте создадим по набору `iris` новую переменную - `sepal_group`, которую перекодируем следующим образом: если значение `Sepal.Length` равно превышает среднее значение по всем наблюдениям - 1, если меньше - 0.\n\n```{r}\niris3<-iris %>%\n  mutate(sepal_group = if_else(Sepal.Length >= mean(Sepal.Length), 1, 0))\n```\n\n{{< iconify arcticons writer size=42px >}} **Самостоятельное задание**:\n\n1.Создайте в наборе`iris3` переменную `petal_group`, таким же способом, как мы только что создавали `sepal_group`. 2. Перекодируйте переменную `petal_group` с помощью `if_else()` так, чтобы 1 были трансформированы в \"Больше среднего\", а 0 - \"Меньше среднего\".\n\n### `case_when()`\n\nКогда условий несколько, можно использовать вложенные конструкции `if_else()`, но это не очень удобно. Вместо это лучше использовать специальную функцию `case_when()`, которая как раз предназначена для таких случаев.\n\nДопустим, нам нужно перекодировать полеты из набора `flights` в зависимости от расстояния (`dist`)и создать переменную `dist_group`, в которой бы все полеты были бы распределены по четырем категориям: \"менее 500 миль\", \"от 500 до 1000 миль\", \"от 1000 до 1500 миль\" и \"свыше 1500 миль\". Получается, что нам нужно сверить множество условий, и, значит, это работа для `case_when ()`:\n\n```{r}\nflights %>%\n  mutate(dist_group=  case_when(\n  distance < 500 ~ \"менее 500 миль\",\n  between(distance, 501, 1000) ~ \"от 500 до 1000 миль\",\n  between(distance, 1001, 1500) ~ \"от 1000 до 1500 миль\",\n  distance > 1500 ~ \"свыше 1500 миль\"), .keep=\"used\")\n\n```\n\n{{< iconify arcticons writer size=42px >}} **Самостоятельное задание**:\n\n1.  По набору `iris` создайте переменную sepal4cats, в которой бы содержались следующие значение о длине чашелистника: \"Меньше 5,0\", \"от 5,1 до 5.8\", \"от 5.9 до 6.4\" и \"свыше 6.5\".\n2.  Посчитайте количество ирисов в каждой группе.\n\n## Между «широким» и «длинным» форматом\n\nПоследнее, чем мы займемся в рамках данной темы, будет преобразование из «широкого» в «длинный» формат и обратно.\n\n### Случай 1. Из «широкого» в «длинное»\n\nИногда случается так, что данные представлены в виде двумерной таблицы, уже подготовленной для описания, но такие данные не очень подходят для дальнейшего анализа.\n\nНапример, давайте посмотрим на таблицу взаимосвязей между уровнем дохода и религиозной принадлежностью:\n\n```{r}\nrelig_income\n```\n\nФункция `pivot_longer()` приведет данные в более удобоваримый вид:\n\nКомментарии: - `cols`- на основе каких переменных мы \"переворачиваем\" данные - `names_to` - как будет называться новая переменная (или переменные, если их несколько) - `values_to`- как будет называться переменная, содержащая частоту\n\n```{r}\nrelig_income %>% \n  pivot_longer(\n    cols = !religion, \n    names_to = \"income\", \n    values_to = \"count\"\n  )\n```\n\nДавайте посмотрим на еще один вариант:\n\n```{r}\nbillboard\n```\n\nЭто данные о песнях их ротации по радиостанциям и о занимаемой позиции:\n\n```{r}\nbillboard %>% \n  pivot_longer(\n    cols = starts_with(\"wk\"), \n    names_to = \"week\", \n    values_to = \"rank\",\n    values_drop_na = TRUE\n  )\n```\n\nНам возможно было бы интересно, сколько недель какой-либо трек продержался в чарте, но для этого нужно превратить неделю из строковой переменной в числовую. Это можно сделать следующим образом:\n\n```{r}\nbillboard %>% \n  pivot_longer(\n    cols = starts_with(\"wk\"), \n    names_to = \"week\", \n    names_transform = readr::parse_number,\n    values_to = \"rank\",\n    values_drop_na = TRUE,\n  )\n```\n\n### Случай 2: из «длинного» в «широкий» формат\n\nФункция `pivot_wider()` является противоположной `pivot_longer()`: она расширяет набор данных за счет создания новых столбцов и сокращения количества строк. Например, это может быть полезно для написания отчетов или создания презентаций.\n\nЧтобы посмотреть на эту функцию в действии, давайте создадим \"длинные\" данные из [набора о пингвинах](https://allisonhorst.github.io/palmerpenguins/):\n\n```{r}\nlibrary(palmerpenguins)\npenguins_long <- penguins %>%  \n  mutate(sample = row_number()) %>%  \n  pivot_longer(contains(\"_\"),\n               names_to = c(\"part\", \"measure\" , \"unit\"),\n               names_sep = \"_\",\n               values_drop_na = TRUE)\npenguins_long\n```\n\nА теперь превратим их в широкий формат:\n\n```{r}\npenguins_long |> \n  pivot_wider(names_from = c(\"part\", \"measure\", \"unit\"),\n              names_sep = \"_\",\n              values_from = value)\n```\n\n## Самостоятельная работа\n\n1.  Для каждого направления (`dest`) по набору `flights` посчитайте общее пройденное расстояние, используя функцию `sum()`.\n2.  Перекодируйте переменную `month` таким образом, чтобы вместо цифр были названия месяцев.\n3.  На основе переменной `air_time`, показывающей время в полете в минутах, создайте переменную `air_time_hours`, в которой время переведено в часы.\n4.  Набор данных о пингвинах `penguins` из библиотеки `palmerpenguins`сгруппируйте по видам и полу пингвинов (`species`, `sex`) и посчитайте средний размер клюва в мм (`bill_length_mm`). Затем трансформируйте результаты так, чтобы получилась вот такая таблица (там будут пропущенные значения по полу, их нужно будет убрать):\n\n```{r echo=FALSE, message=FALSE}\nlibrary(palmerpenguins)\npenguins %>% \n  group_by(species, sex) %>% \n  summarise(mean_bill=mean(bill_length_mm)) %>% \n  na.omit() %>% \n  pivot_wider(names_from = sex, values_from = mean_bill) %>% \n  mutate(across(where(is.numeric), round, 1)) %>% \n  kbl() %>%\n  kable_styling()\n```\n\n5.  Все результаты оформить в виде документа RMarkdown и опубликовать на RPubs. Результаты прикрепить в виде ссылки.\n","srcMarkdownNoYaml":"\n\n```{r setup, echo=FALSE}\nlibrary(kableExtra)\n```\n\n```{css, echo = FALSE}\n.output {\nmax-height: 500px;\noverflow-y: scroll;\n}\n```\n\nВ рамках данного занятия мы будем работать с библиотекой [tidyverse](https://www.tidyverse.org/), объединяющей возможности нескольких других библиотек и воплощающей общую философию, дизайн и грамматику обработки и анализа данных, разработанную RStudio: ![](https://hbctraining.github.io/Intro-to-R/img/tidyverse_website.png)\n\nОсновные библиотеки семейства tidyverse:\n\n-   **ggplot2** - библиотека для создания разнообразных визуализаций на основе пользовательских данных и заданных настроек.\n-   **dplyr** - библиотека для основных трансформаций данных (отбор, фильтрация, группировка, создание новых переменных, описательный анализ).\n-   **tidyr** - набор функций для подготовки данных к анализу (транспонирование, переструктурированые данных).\n-   **readr** работа с данными прямоугольного формата, представленными в формате csv, tsv или fwf.\n-   **tibble** - специальная библиотека для работы с датафреймами.\n-   **stringr** - набор функций для работы со строковыми переменными.\n-   **forcats** - библиотека для работы с факторными (категориальными - номинальными и порядковыми) перемннными.\n\n::: callout-tip\n## Tidyverse - все нужные библиотеки в одном месте!\n\nНа предыдущем занятии мы осуществляли импорт и экспорт данных, используя некоторые библиотеки, входящие во вселенную `Tidyverse`. Загружая библиотеку Tidyverse, мы автоматически загружаем все остальные, и потребность в загрузке отдельных библиотек отпадает.\n:::\n\n## Прямоугольные и непрямоугольные таблицы, а также tidy и messy данные\n\nДанные могут быть представлены в различных формах, но на самом базовом уровне их можно представить в виде двух типов структур: данные представленные в виде прямоугольных таблиц и непрямоугольных данных.\n\nПрямоугольные данные имеют форму прямоугольника (действительно!), то есть каждое значение соответствует какой-то строке и столбцу. Большинство датафреймов содержат как раз прямоугольные данные.\n\nСоответственно непрямоугольные данные не могут так легко распределяться по строкам и столбцам, они, как правило, представляют собой совокупность различных структур данных, в которых между отдельными элементами имеется какое-то сходство. Обычно непрямоугольные данные хранятся в списках.\n\n**Tidy** по-английски означает \"чистый, аккуратный, опрятный\". По отношению к данным выражение - tidy data - \"чистые, правильным образом представленные данные\" противопоставляется \"messy data\" - \"грязным данным\", представленным в виде, не совсем пригодном или удобном для анализа.\n\n`Tidy data` - это когда данные имеют так называемый \"длинный формат\" - каждый столбец представляет собой отдельную переменную, а строка - наблюдение или случай.\n\n![](https://www.researchgate.net/publication/338569186/figure/fig1/AS:847073150775297@1578969385585/The-wide-versus-tidy-data-format-for-time-dependent-data-In-the-wide-spreadsheet-like.png){width=\"400\"}\n\nКак из «грязных» данных сделать «чистые»? Как привести набор данных к виду, пригодному для дальнейшего анализа, отобрать нужные переменные, преобразовать их в формат, который нужен для решения аналитической задачи?\n\nВ рамках данного раздела будут рассмотрены функции, которые используются для трансформации данных - их чистки, фильтрации, вычисления новых переменных и описательных статистик, а также перевода набора данных из «широкого» в «длинный» и обратно.\n\nВ основном мы будем работать с двумя библиотеками семейства `tidyverse` - `dplyr` и `tidyr`.\n\n![](https://dplyr.tidyverse.org/logo.png), ![](https://tidyr.tidyverse.org/logo.png)\n\nЭти библиотеки является одними из лучших для разнообразных трансформаций данных, потребность в которых возникает постоянно в процессе анализа.\n\nРассмотрим основные функции на примере набора данных `flights` из библиотеки - `nycflights13`, в котором содержится информация о 336 776 полетах, совершенных из аэропорта Нью-Йорка в 2013 году. Данные предоставлены Бюро по статистике США, справку по ним можно найти по запросу `?flights`.\n\n## Фильтрация строк - filter()\n\nПрежде, чем начать, установим библиотеки:\n\n```{r eval=FALSE, message=FALSE}\ninstall.packages(c(\"nycflights13\", \"tidyverse\"))\n```\n\nТеперь загрузим их в наше рабочее пространство:\n\n```{r message=FALSE}\nlibrary(tidyverse)\nlibrary(nycflights13)\n```\n\nВ наборе данных `flights` содержится следующая информация о переменных:\n\n-   year (год), month (месяц), day (день) - дата вылета\n-   dep_time - время вылета\n-   arr_time - время прилета\n-   sched_dep_time, sched_arr_time - время вылета и прилета по расписанию.\n-   dep_delay, arr_delay - задержка вылета и прилета в минутах. Отрицательные значения означают досрочные вылеты / прилеты.\n-   carrier - перевозчик\n-   flight - номер рейса\n-   tailnum - номер самолета\n-   origin, dest - место отправления, место назначения\n-   air_time - время полета в минутах\n-   distance - расстояние в милях\n-   hour, minute - часов, минут - время отлета, разбитое по часам и минутам\n-   time_hour - дата и время полета по расписанию в формате даты.\n\nДавайте сначала просто посмотрим на эти данные:\n\n```{r}\nhead(flights)\n```\n\nФункция `filter()` позволяет отобрать наблюдения, основываясь на значениях. Первый аргумент - имя датафрейма (массива, базы данных), второй и последующие аргументы - выражения, позволяющие отфильтровать данные. Например, мы хотим отобрать все полеты, которые произошли 1 января:\n\n```{r}\nfilter(flights, month == 1, day == 1)\n```\n\nКогда мы запускаем эту строку с кодом, `dplyr` выполняет фильтрующую операцию и выводит новый датафрейм. Однако, стоит учитывать, что исходные данные не меняются, и если нам необходимо сохранить эти изменения как отдельный объект, нам нужно использовать оператор присваивания, \\<-, и задать новое имя:\n\n```{r}\njan1 <- filter(flights, month == 1, day == 1)\n```\n\nR либо выводит на экран результаты либо сохраняет их в новую переменную (объект). Если мы хотим одновременно создать новую базу данных, сохранить в нее результаты фильтрации и вывести результат на экран, нужно код заключить в скобки:\n\n```{r}\n(dec25 <- filter(flights, month == 12, day == 25))\n```\n\n## Логические операторы\n\nОчень часто функция `filter()` сопровождается логическими операторами (\"и\", \"или\" и др.). В этом случае, результат каждого выражения должен быть истинным, для того, чтобы строки были отобраны в новый набор.\n\n::: callout-tip\n**Запомним основные операторы**\n\n**&** это “и”\n\n**\\|** это “или”\n\n**!** “не равно”\n:::\n\nГрафически различия между операторами можно представить следующим образом:\n\n![](https://d33wubrfki0l68.cloudfront.net/01f4b6d39d2be8269740a3ad7946faa79f7243cf/8369a/diagrams/transform-logical.png)\n\nНапример, давайте отфильтруем данные так, чтобы у нас отображались два месяца - ноябрь и декабрь.\n\n```{r}\nfilter(flights, month == 11 | month == 12)\n```\n\nДля некоторого упрощения кода полезно будет запомнить [\"законы де Моргана\"](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BA%D0%BE%D0%BD%D1%8B_%D0%B4%D0%B5_%D0%9C%D0%BE%D1%80%D0%B3%D0%B0%D0%BD%D0%B0):\n\n!(x & y) это то же самое, что и !x \\| !y,\n\n!(x \\| y) равносильно !x & !y.\n\nНапример, если нам нужно отобрать полеты, которые задерживались (по прилетам и отлетам) не более чем на два часа, мы могли бы пойти двумя путями:\n\n```{r}\nfilter(flights, !(arr_delay > 120 | dep_delay > 120))\n# Или (результат идентичный)\nfilter(flights, arr_delay <= 120, dep_delay <= 120)\n```\n\n{{< iconify arcticons writer size=42px >}} **Самостоятельное задание**:\n\n1.  Создайте набор данных `arr_depay_over120`, в который отберите рейсы, прилет которых (arr_delay) задерживался на 2 или более часа.\n2.  Выгрузите данные о рейсах в аэропорты Хьюстона - George Bush Intercontinental (IAH) или аэропорт William P Hobby (HOU) (по переменной `dest`) и сохраните их под именем `IAH_OR_HOU`.\n3.  Отберите из таблицы все полеты, которые совершались в летние месяцы, и сохраните их под именем `summer_flights`.\n\n## Упорядочение строк с функцией arrange()\n\nФункция `arrange()` работает практически идентично с `filter()`, однако, вместо отбора строк она меняет их порядок. На входе функция берет датафрейм и наименования столбцов, по которым нужно сделать сортировку.Если таких столбцов несколько, каждая дополнительная колонка может быть использована для сортировки значений по уже отсортированным значениям предыдущего столбца.\n\nНапример, отсортируем полеты по дате (сначала по месяцу, потом по дню):\n\n```{r}\narrange(flights, month, day)\n```\n\nЕсли нам нужно отсортировать что-то по убыванию, то функция `desc()` поможет нам перегруппировать значения в столбце. Например, отсортируем по убыванию значения задержки отлета:\n\n```{r}\narrange(flights, desc(dep_delay))\n```\n\n\\*\\* ! Пропущенные значения (NA) - всегда располагаются в конце списка, независимо от направления сортировки\\*\\*. Давайте воспроизведем это свойство на примере, содержащем небольшое количество строк:\n\n```{r}\ndf <- tibble(x = c(5, 2, NA))\narrange(df, x)\narrange(df, desc(x))\n```\n\n{{< iconify arcticons writer size=42px >}} **Самостоятельное задание**:\n\n1.  Отсортируйте полеты, чтобы найти те, что имеют наибольшие значения времени задержки прилета (`arr_delay`). Найдите также полеты, которые вылетели раньше времени по расписанию (вспоминаем функцию `tail()`).\n2.  Найдите самые короткие (быстрые) полеты по переменной `air_time`.\n\n## Отбор переменных с функцией select()\n\nДостаточно часто нам для анализа не нужен весь наш набор данных, а только ограниченный набор переменных, с которыми мы работаем в какой-то момент времени. Удобно и полезно отобрать эти переменные и работать только с ними, особенно - если данных очень много, и количество переменных исчисляется сотнями или тысячами. Функция `select()` позволяет быстро отобрать переменные по их именам:\n\n```{r}\nselect(flights, year, month, day)\n```\n\n```{r}\n\nselect(flights, year:day) # если переменные идут подряд, не обязательно перечислять все, можно воспользоваться оператором :\n```\n\n```{r}\nselect(flights, -(year:day))# знак минуса используется для того, чтобы, наоборот, исключить какие-то переменные\n```\n\nЕсть еще несколько полезных функций, которые идут в паре с select() и делают жизнь проще:\n\n`starts_with(\"abc\")`: имена переменных начинаются на “abc”.\n\n`ends_with(\"xyz\")`: имена переменных заканчиваются на “xyz”.\n\n`contains(\"ijk\")`: имя переменной содержит “ijk”.\n\nИногда, в процессе обработки нам требуется переименовать переменную другим способом. Для этой цели подходит функция `rename`:\n\n```{r}\nrename(flights, tail_num = tailnum)\n```\n\n{{< iconify arcticons writer size=42px >}} **Самостоятельное задание**:\n\n1.  Использовать все возможные способы для того, чтобы отобрать переменные dep_time, dep_delay, arr_time и arr_delay.\n2.  Что случится, если Вы включите одну и ту же переменную несколько раз в запрос функции select()?\n\n## Создаем новую переменную с функцией mutate()\n\nДа, сейчас явно что-то будет про мутации)))\n\nПомимо того, что в процессе анализа нам приходится что-то постоянно отбирать (например, только жителей сел или городов, какой-то регион исследования, лиц определенного возраста и пола), часто приходится вычислять новые переменные на основе старых - высчитывать возраст, средний доход, количество детей и т. д.\n\nВ этом нам может помочь функция `mutate()`.\n\n{{< iconify arcticons zte-task-manager size=42px >}}**Пример**: создадим новый набор `flights_sml`, куда отберем даты полета, расстояние и переменные, оканчивающиеся на \"delay\". Затем, содадим две новых переменных:\n\n-   скорость (speed)\n-   количество минут, которые самолет смог догнать при задержке рейса (как разность между задержкой вылета и прилета) (gain).\n\n```{r}\nflights_sml <- select(flights,\n  year:day,\n  ends_with(\"delay\"),\n  distance,\n  air_time\n)\nmutate(flights_sml,\n  gain = dep_delay - arr_delay,\n  speed = distance / (air_time / 60)\n)\n```\n\nОтметим, что мы можем «не отходя от кассы» использовать новые переменные в последующих расчетах для создания других переменных. Например, давайте создадим переменную `gain` (см. пример выше), но и посчитаем время полета в часах и среднее количество минут, которое нагонял самолет каждый час:\n\n```{r}\nmutate(flights_sml,\n  gain = dep_delay - arr_delay,\n  hours = air_time / 60,\n  gain_per_hour = gain / hours\n)\n```\n\n{{< iconify arcticons writer size=42px >}} **Самостоятельное задание**:\n\n1.  Сравните `` air_time` и `arr_time - dep_time ``. Что мы можем увидеть? Какие выводы можно сделать?\n2.  Сравните `dep_time`, `sched_dep_time` и `dep_delay`. Как эти переменные связаны друг с другом?\n3.  На основе уже знакомого нам набора `iris` создайте новую переменную - `sepal_ratio`, в которой посчитайте отношение длины чашелистника (`Sepal.Length`) к его ширине (`Sepal.Width`) и переменную `petal_ratio`, в которой посчитайте отношение длины лепестка (`Petal.Length`) к его ширине (`Petal.Width`). Сохраните данные в новом наборе `iris2`.\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Если трудно, код можно посмотреть здесь\"\niris2<- mutate(iris, sepal_ratio=Sepal.Length/Sepal.Width, petal_ratio=Petal.Length/Petal.Width)\n```\n\n## Изменения в нескольких переменных: mutate + across\n\nФункция `mutate()` не обязательно означает, что мы будем вычислять новые переменные, вполне возможно мы будем как-то видоизменять те переменные, которые у нас уже есть в наборе данных. Например, мы хотим округлить значение только что полученных нами переменных `sepal_ratio` `petal_ratio` (см. самостоятельная работа выше, упражнение 3) до одного знака после запятой.\n\n```{r echo=FALSE}\niris2<-as.tibble(iris2)\n```\n\n```{r message=FALSE, warning=FALSE}\nmutate(iris2, across(c(sepal_ratio, petal_ratio), round, 1))# функция round используется для округления, цифра 1 означает, что мы будем округлять до одного знака после запятой \n```\n\nМы могли бы написать наш код чуть по-другому:\n\n```{r}\niris2 %>%\n  mutate(across(c(sepal_ratio, petal_ratio), round, 1))\n```\n\n::: callout-info\nСтоп! Что за новый знак %\\>%?\n\nЭто оператор, который позволяет сократить код и написать его по типу \"матрешки\". По-английски это называется \"pipe-operator\", здесь явная аналогия с телескопическими трубами, которые как бы вкладываются друг с другом. Так и наши различные функции dplyr следуют друг за другом уже без лиших аргументов и дублирования информации о наборе данных, лишних скобок и знаков \\$, с помощью которых мы вводим имя переменной из набора. Код становится более читаемым и быстрым.\n:::\n\nГрафически это можно представить вот так:\n\n![](https://i0.wp.com/www.rforecology.com/pipes_image0.png) В `dplyr` оператор `%>%` попал из библиотеки `magrittr`, разработчики которой (Stefan Milton Bache, Hadley Wickham, Lionel Henry) преследовали две основных цели - сократить процесс написания кода и улучить его поддержку.\n\nНазвана библиотека в честь бельгийского художника-сюрреалиста Рене Магритта (1898-1967), который был известен своими остроумными и загадочными работами.\n\n![](https://www.marcianocontemporary.com/wp-content/uploads/2022/02/rene-magritte-surrealiste-4094.jpeg) Причем тут трубы, спросите вы? А вот причем. У Магритта есть одна знаменитая картина -- «Вероломство образов», которую автор создал в 1929 году, увлекшись исследованием связи в искусстве между словами и образами. На картине изображена курительная трубка, выглядит она очень правдоподобно и нарисована тщательно. Вдоль нижней кромки полотна идет надпись, сделанная крупным каллиграфическим почерком: «Ceci n'est pas une pipe» - «Это не трубка». Картина породила множество интерпретаций, а сам автор по поводу нее сказал следующее: «Разве я написал неправду? Да, на картине нарисована трубка, но разве вы можете раскурить ее? Нет, потому что это всего лишь репрезентация. И если бы я написал \"Это - трубка\", то я бы солгал!».\n\n![](https://arthive.net/res/media/img/oy800/work/3b9/295282@2x.webp) В общем, разработчики отдали дань творчеству автора, и в языке R появился новый оператор.\n\n::: callout-tip\nЧтобы быстро набрать пайп-оператор нужно одновременно нажать три клавиши:\n\n**Ctrl+Shift+M**\n:::\n\nНачиная с версии R 4.1.0. в базовом R появился свой, «нативный» оператор, почти аналогичный `%>%`. Выглядит он как `|<` и \"ведет себя\" почти всегда так же. Есть некоторые нюансы, однако обсуждать мы их пока не будем. В качестве дополнительного матерала для тех, кто хочет действительно разобраться, отсылаю к статье: https://www.tidyverse.org/blog/2023/04/base-vs-magrittr-pipe/\n\nВ настройках RStudio можно указать, какой именно операторв вы хотите использовать, но только один: ![](https://i.stack.imgur.com/wx9mN.png)\n\n## Вычисление основных статистик с функцией `summarise()` и `group_by()`\n\nЕще одна функция, которую мы изучим в рамках данного урока, -- `summarise()`. Как следует из названия, ее предназначение - рассчитывать какие-то новые значения на основе разнообразных функций - арифметических, статистических и др. Например, посчитаем среднее количество минут задержки вылета по набору полетов:\n\n```{r}\nsummarise(flights, dep_delay_mean = mean(dep_delay, na.rm = TRUE))#na.rm = TRUE - данный аргумент удаляет из анализа все пропущенные значения (na - not avaliable, rm - remove), в противном случае вычисление среднего не возможно.\n```\n\nФункция `summarise()` часто идет в паре с другой функцией - `group_by()`, позволяющей провести анализ в отдельных подгруппах. Соответственно, когда мы применяем функции `dplyr` к сгруппированным данным, они автоматически рассчитываются для каждой подгруппы по отдельности. Например, мы можем применить код из примера выше, но предварительно сгруппировать данные по месяцам. Получится следующее:\n\n```{r}\nflights %>%\ngroup_by(month) %>%\nsummarise(dep_delay_delay = mean(dep_delay, na.rm = TRUE))\n```\n\nИз таблицы видно, что рейсы в среднем задерживались чаще в летние месяцы (июне и июле) и декабре.\n\nПриведем еще один пример совместного использования функций: проведем группировку по месту назначения и посчитаем общее количество полетов, среднее расстояние и среднюю задержку вылета в минутах, а также отберем 5 направлений с максимальными средними значениями по задержке вылетов и 5 направлений с минимальным задержками:\n\n```{r}\ndelays <- flights %>%\n  group_by(dest) %>%\n  summarise(\n    Всего = n(),\n    Сред_расст = mean(distance, na.rm = TRUE),\n    Ср_задержка_вылета = mean(arr_delay, na.rm = TRUE)\n  ) %>% \n  arrange(desc(Ср_задержка_вылета)) %>% \n  slice(c(1:5, n()-5:n()))#slice отбирает строки, в скобках указываются номера, 1:5 - первые пять, а n()-5:n() - последние пять: n()-5 - номер строки минус 5 указывает на начало интервала,n() - общее количество строк - на конец. Мы могли бы указать это как 101:105, но допустим, мы не знаем, сколько строк, такой подход позволяет избежать ручного ввода номеров строк.\ndelays\n```\n\nХотя в таблице :::callout-note Другие полезные функции: - median() - медиана - sd() - стандартное отклонение - min() - минимум - max() - максимум - first() - первое значение - nth() - значение определенного порядка (2, 3 и т.д.) - last() - последнее - n() - количество, размер группы - n_distinct() - количество уникальных значений :::\n\nНапример:\n\n```{r}\nflights %>%\nna.omit() %>% #na.omit() - опускает пропущенные значения\ngroup_by(month) %>%\n  summarise(\n    first_dep = first(dep_time),\n    last_dep = last(dep_time)\n  )\n```\n\nЕще пример: сгруппируем полеты по месту назначения и посчитаем уникальных перевозчиков, отсортировав нашу таблицу по месту назначения.\n\n```{r}\nflights %>%\nna.omit() %>%\ngroup_by(dest) %>%\n  summarise(carriers = n_distinct(carrier)) %>%\n  arrange(desc(carriers))\n```\n\n## Сочетание нескольких трансформаций (mutate, filter, summarise)\n\nГруппировка обычно сопутствует функции `summarise()`,но ее также можно сочетать с `mutate()` и `filter()`:\n\nНапример, мы хотим оставить в наболе данные только по наиболее популярным направлениям, принявшим не менее 5000 полетов за год:\n\n```{r}\nflights %>%\n  group_by(dest) %>%\n  filter(n()>17000)\n```\n\nИли, например, нам понадобилось посчитать по каждому направлению среднее количество полетов и сохранить его в переменной `mean`:\n\n```{r}\nflights %>%\n  group_by(dest) %>%\n  mutate(mean=mean(n()), .keep = \"used\") #.keep = \"used\" - оставляет в наборе только используемые переменные, в противном случае останется весь набор\n```\n\n## Создание новых переменных из старых по условиям: `if_else()` и `case_when()`\n\nТакого рода перекодировки в исследовательской практике встречаются очень часто, когда мы хотим объединить некоторые значения в группы или заменить на другие значения. В решении этой задачи нам помогут две полезные функции: `if_else()`и `case_when()`.\n\n### if_else()\n\nЭта функция позволяет нам перекодировать значения, совпадающие или несовпадающие с некоторым условием, и одновременно обрабатывать отсутствующие значения. Для того, чтобы корректно применить эту функцию, нам нужно знать, какое значение в наших данных будет условно «истинным, корректным», какое «ложным, неправильным», и какое значение будут принимать пропущенные значения.\n\nОбщая формула для этой функции выглядит так:\n\n`if_else(condition, true, false, missing = NULL)`\n\nВ аргументах функции задается следующее: `condition` - условие, которое мы проверяем `true` - значение, которое присваиваем, если условие выполняется `false`- значение, которое присваиваем, если условие не выполняется.\n\nПриведем простой пример: Создадим вектор `x`, содержащий значения от -10 до +10, а затем все положительные значения заменим на 555:\n\n```{r}\nx <- c(-10:10)\nif_else(x > 0, 555, x)\n```\n\nКонструкция `if_else()` очень часто используется вместе с `mutate()`для того, чтобы создать новые переменные.\n\nДавайте создадим по набору `iris` новую переменную - `sepal_group`, которую перекодируем следующим образом: если значение `Sepal.Length` равно превышает среднее значение по всем наблюдениям - 1, если меньше - 0.\n\n```{r}\niris3<-iris %>%\n  mutate(sepal_group = if_else(Sepal.Length >= mean(Sepal.Length), 1, 0))\n```\n\n{{< iconify arcticons writer size=42px >}} **Самостоятельное задание**:\n\n1.Создайте в наборе`iris3` переменную `petal_group`, таким же способом, как мы только что создавали `sepal_group`. 2. Перекодируйте переменную `petal_group` с помощью `if_else()` так, чтобы 1 были трансформированы в \"Больше среднего\", а 0 - \"Меньше среднего\".\n\n### `case_when()`\n\nКогда условий несколько, можно использовать вложенные конструкции `if_else()`, но это не очень удобно. Вместо это лучше использовать специальную функцию `case_when()`, которая как раз предназначена для таких случаев.\n\nДопустим, нам нужно перекодировать полеты из набора `flights` в зависимости от расстояния (`dist`)и создать переменную `dist_group`, в которой бы все полеты были бы распределены по четырем категориям: \"менее 500 миль\", \"от 500 до 1000 миль\", \"от 1000 до 1500 миль\" и \"свыше 1500 миль\". Получается, что нам нужно сверить множество условий, и, значит, это работа для `case_when ()`:\n\n```{r}\nflights %>%\n  mutate(dist_group=  case_when(\n  distance < 500 ~ \"менее 500 миль\",\n  between(distance, 501, 1000) ~ \"от 500 до 1000 миль\",\n  between(distance, 1001, 1500) ~ \"от 1000 до 1500 миль\",\n  distance > 1500 ~ \"свыше 1500 миль\"), .keep=\"used\")\n\n```\n\n{{< iconify arcticons writer size=42px >}} **Самостоятельное задание**:\n\n1.  По набору `iris` создайте переменную sepal4cats, в которой бы содержались следующие значение о длине чашелистника: \"Меньше 5,0\", \"от 5,1 до 5.8\", \"от 5.9 до 6.4\" и \"свыше 6.5\".\n2.  Посчитайте количество ирисов в каждой группе.\n\n## Между «широким» и «длинным» форматом\n\nПоследнее, чем мы займемся в рамках данной темы, будет преобразование из «широкого» в «длинный» формат и обратно.\n\n### Случай 1. Из «широкого» в «длинное»\n\nИногда случается так, что данные представлены в виде двумерной таблицы, уже подготовленной для описания, но такие данные не очень подходят для дальнейшего анализа.\n\nНапример, давайте посмотрим на таблицу взаимосвязей между уровнем дохода и религиозной принадлежностью:\n\n```{r}\nrelig_income\n```\n\nФункция `pivot_longer()` приведет данные в более удобоваримый вид:\n\nКомментарии: - `cols`- на основе каких переменных мы \"переворачиваем\" данные - `names_to` - как будет называться новая переменная (или переменные, если их несколько) - `values_to`- как будет называться переменная, содержащая частоту\n\n```{r}\nrelig_income %>% \n  pivot_longer(\n    cols = !religion, \n    names_to = \"income\", \n    values_to = \"count\"\n  )\n```\n\nДавайте посмотрим на еще один вариант:\n\n```{r}\nbillboard\n```\n\nЭто данные о песнях их ротации по радиостанциям и о занимаемой позиции:\n\n```{r}\nbillboard %>% \n  pivot_longer(\n    cols = starts_with(\"wk\"), \n    names_to = \"week\", \n    values_to = \"rank\",\n    values_drop_na = TRUE\n  )\n```\n\nНам возможно было бы интересно, сколько недель какой-либо трек продержался в чарте, но для этого нужно превратить неделю из строковой переменной в числовую. Это можно сделать следующим образом:\n\n```{r}\nbillboard %>% \n  pivot_longer(\n    cols = starts_with(\"wk\"), \n    names_to = \"week\", \n    names_transform = readr::parse_number,\n    values_to = \"rank\",\n    values_drop_na = TRUE,\n  )\n```\n\n### Случай 2: из «длинного» в «широкий» формат\n\nФункция `pivot_wider()` является противоположной `pivot_longer()`: она расширяет набор данных за счет создания новых столбцов и сокращения количества строк. Например, это может быть полезно для написания отчетов или создания презентаций.\n\nЧтобы посмотреть на эту функцию в действии, давайте создадим \"длинные\" данные из [набора о пингвинах](https://allisonhorst.github.io/palmerpenguins/):\n\n```{r}\nlibrary(palmerpenguins)\npenguins_long <- penguins %>%  \n  mutate(sample = row_number()) %>%  \n  pivot_longer(contains(\"_\"),\n               names_to = c(\"part\", \"measure\" , \"unit\"),\n               names_sep = \"_\",\n               values_drop_na = TRUE)\npenguins_long\n```\n\nА теперь превратим их в широкий формат:\n\n```{r}\npenguins_long |> \n  pivot_wider(names_from = c(\"part\", \"measure\", \"unit\"),\n              names_sep = \"_\",\n              values_from = value)\n```\n\n## Самостоятельная работа\n\n1.  Для каждого направления (`dest`) по набору `flights` посчитайте общее пройденное расстояние, используя функцию `sum()`.\n2.  Перекодируйте переменную `month` таким образом, чтобы вместо цифр были названия месяцев.\n3.  На основе переменной `air_time`, показывающей время в полете в минутах, создайте переменную `air_time_hours`, в которой время переведено в часы.\n4.  Набор данных о пингвинах `penguins` из библиотеки `palmerpenguins`сгруппируйте по видам и полу пингвинов (`species`, `sex`) и посчитайте средний размер клюва в мм (`bill_length_mm`). Затем трансформируйте результаты так, чтобы получилась вот такая таблица (там будут пропущенные значения по полу, их нужно будет убрать):\n\n```{r echo=FALSE, message=FALSE}\nlibrary(palmerpenguins)\npenguins %>% \n  group_by(species, sex) %>% \n  summarise(mean_bill=mean(bill_length_mm)) %>% \n  na.omit() %>% \n  pivot_wider(names_from = sex, values_from = mean_bill) %>% \n  mutate(across(where(is.numeric), round, 1)) %>% \n  kbl() %>%\n  kable_styling()\n```\n\n5.  Все результаты оформить в виде документа RMarkdown и опубликовать на RPubs. Результаты прикрепить в виде ссылки.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["include/webex.css"],"include-after-body":["include/webex.js"],"embed-resources":false,"output-file":"TidyverseTransformations.html"},"language":{"toc-title-document":"Содержание","toc-title-website":"Содержание","related-formats-title":"Другие форматы","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Источник","other-links-title":"Другие ссылки","code-links-title":"Ссылки на код","launch-dev-container-title":"Запустить Dev Container","launch-binder-title":"Запустить Binder","article-notebook-label":"Блокнот статьи","notebook-preview-download":"Скачать блокнот","notebook-preview-download-src":"Скачать исходный код","notebook-preview-back":"Вернуться к статье","manuscript-meca-bundle":"Архив MECA","section-title-abstract":"Аннотация","section-title-appendices":"Приложения","section-title-footnotes":"Сноски","section-title-references":"использованная литература","section-title-reuse":"Повторное использование","section-title-copyright":"Авторские права","section-title-citation":"Цитата","appendix-attribution-cite-as":"Пожалуйста, цитируйте эту работу как:","appendix-attribution-bibtex":"BibTeX","appendix-view-license":"Просмотреть Лицензию","title-block-author-single":"Автор","title-block-author-plural":"Авторы","title-block-affiliation-single":"принадлежность","title-block-affiliation-plural":"Принадлежности","title-block-published":"Дата публикации","title-block-modified":"Файл изменен","title-block-keywords":"Ключевые слова","callout-tip-title":"Совет","callout-note-title":"Уведомление","callout-warning-title":"Предупреждение","callout-important-title":"Важное уведомление","callout-caution-title":"Осторожность","code-summary":"Код","code-tools-menu-caption":"Код","code-tools-show-all-code":"Развернуть код","code-tools-hide-all-code":"Скрыть код","code-tools-view-source":"Показать код","code-tools-source-code":"Исходный код","tools-share":"Share","tools-download":"Download","code-line":"Линия","code-lines":"Линии","copy-button-tooltip":"Скопировать текст","copy-button-tooltip-success":"Скопировано","repo-action-links-edit":"Редактировать страницу","repo-action-links-source":"Показать код","repo-action-links-issue":"Сообщить о проблеме","back-to-top":"Наверх","search-no-results-text":"Поиск не дал результатов","search-matching-documents-text":"Результаты поиска","search-copy-link-title":"Скопировать ссылку","search-hide-matches-text":"Скрыть дополнительные результаты","search-more-match-text":"дополнительный результат в этом документе","search-more-matches-text":"дополнительных результата(-ов) в этом документе","search-clear-button-title":"Очистить","search-text-placeholder":"","search-detached-cancel-button-title":"Отменить","search-submit-button-title":"Найти","search-label":"Поиск","toggle-section":"Переключить раздел","toggle-sidebar":"Переключить боковую панель навигации","toggle-dark-mode":"Переключить темный режим","toggle-reader-mode":"Переключить режим чтения","toggle-navigation":"Переключить навигацию","crossref-fig-title":"Рисунок","crossref-tbl-title":"Таблица","crossref-lst-title":"Список","crossref-thm-title":"Теорема","crossref-lem-title":"Лемма","crossref-cor-title":"Следствие","crossref-prp-title":"Утверждение","crossref-cnj-title":"Гипотеза","crossref-def-title":"Определение","crossref-exm-title":"Пример","crossref-exr-title":"Упражнение","crossref-ch-prefix":"Глава","crossref-apx-prefix":"Приложение","crossref-sec-prefix":"Глава","crossref-eq-prefix":"Уравнение","crossref-lof-title":"Список Иллюстраций","crossref-lot-title":"Список Таблиц","crossref-lol-title":"Список Каталогов","environment-proof-title":"Доказательство","environment-remark-title":"Примечание","environment-solution-title":"Решение","listing-page-order-by":"Сортировать по","listing-page-order-by-default":"предварительно выбранный","listing-page-order-by-date-asc":"Самый старый","listing-page-order-by-date-desc":"Новейшие","listing-page-order-by-number-desc":"нисходящий","listing-page-order-by-number-asc":"по возрастанию","listing-page-field-date":"Дата","listing-page-field-title":"Заголовок","listing-page-field-description":"Описание","listing-page-field-author":"Автор","listing-page-field-filename":"Имя файла","listing-page-field-filemodified":"Файл изменен","listing-page-field-subtitle":"Подзаголовок","listing-page-field-readingtime":"Время чтения","listing-page-field-wordcount":"Подсчет слов","listing-page-field-categories":"Категории","listing-page-minutes-compact":"{0} минут","listing-page-category-all":"Все","listing-page-no-matches":"Нет подходящих элементов","listing-page-words":"{0} слов","listing-page-filter":"Фильтр","draft":"Черновик"},"metadata":{"lang":"ru","fig-responsive":true,"quarto-version":"1.5.57","comments":{"hypothesis":true},"bibliography":["references.bib"],"editor":"visual","theme":"Pulse","title":"Tidyverse и трансформация данных"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}
{"title":"Основы визуализации в ggplot2","markdown":{"yaml":{"title":"Основы визуализации в ggplot2"},"headingText":"Создаем первый график ggplot","containsRefs":false,"markdown":"\n\n> “Простой график принес аналитику данных больше информации , чем какое-либо устройство\", ” — Джон Тьюки.\n\nВизуализация является очень важным этапом анализа данных, который может выполнять как вспомогательные, так и свои собственные, самостоятельные функции.\n\nМы уже освоили основы отбора и трансформации данных (tidy and transofrm), теперь настал черед познакомиться с некоторыми возможностями визуального представления данных, которое, наряду с моделированием, собственно и формирует исследовательский процесс:\n\n![](https://d33wubrfki0l68.cloudfront.net/795c039ba2520455d833b4034befc8cf360a70ba/558a5/diagrams/data-science-explore.png)\n\nНа сегодняшнем занятии мы научимся визуализировать данные, используя возможности библиотеки ggplot2. Вообще-то, в R есть различные способы создания графиков (на следующих занятиях мы обязательно попробуем разные), но библиотека ggplot2 является одной из наиболее продвинутых, чьи основы часто используются другими библиотеками (например, библиотекой для работы со шкалами Ликерта `likert`).\n\nСчитается, что обучение визуализации с помощью `ggplot2`подходит для тех, кто только начинает осваивать программирование (хотя есть и те, кто считает ggplot2 слишком сложным, поскольку график задается эксплицитно - мы должны в ручном режиме прописать все параметры, включая оформление, цвета, надписи осей и прочие элементы, которые excel, например, дает по умолчанию), а понимание графической \"грамматики\" - правил, на основе которых строются графики, дает практически безграничные возможности в плане представления результатов анализа данных. Возможно, по началу, вам будет казаться, что код громоздкий и что диаграммы в excel было бы сделать намного проще, со временем вы сможете понять всю красоту и гибкость такой визуализации.\n\nПосколькуо библиотека `ggplot2` является важным членом семьи `tidyverse`, чтобы получить доступ к встроенным наборам данных, справочным страницам и функциям, мы должны загрузить библиотеку `tidyverse` с помощью уже известной нам функции `library()`:\n\n```{r}\nlibrary(tidyverse)\n```\n\n\nДавайте попробуем создать наш первый график на основе набора данных `mpg`, встроенного в `ggplot2`, который содержит технические данные о 38 моделях автомобилей, выпущенных с 1999 по 2008 гг., собранные американским агентством по защите окружающей среды, включая следующие переменные: \n\n- производитель (manufacturer) \n- модель (model) \n- объем двигателя в литрах (displ) \n- год производства (year) \n- количество цилиндров (cyl) \n- тип трансмиссии (trans) \n- привод (drv, f - передний привод, r - задний привод, 4wd - полный привод) \n- расход топлива в городе (cty) \n- расход топлива на трассе (hwy) \n- тип топлива (fl) \n- класс машины (class, 2seater - маленькая машина на 2 пассажиров, compact - компактная, midsize - средних размеров, minivan - минивен, pickup - пикап, subcompact - субкомпактная, suv - кроссовер). Кому интересны подробности: https://en.wikipedia.org/wiki/Car_classification\n\nК примеру, мы можем задаться вопросом: потребляют ли большие машины (с большим объемом двигателя) больше топлива, чем малолитражки? Возможно, мы уже знаем ответ на данный вопрос, и все кажется очевидным, но мы можем еще раз удостовериться в своих предположениях. Какова в действительности взаимосвязь между объемом двигателя и потребляемым топливом? Является ли она положительной? Или отрицательной? Линейной? Или Нелинейной?\n\nПопробуем выяснить.\n\nПрежде всего давайте посмотрим, что представляют собой наши данные:\n\n```{r}\nmpg\n```\n\nЧтобы узнать больше о данном наборе данных, нужно запустить код `?mpg`.\n\n\nСоздадим график, визуализирующий взаимосвязь между объемом двигателя **displ** (по оси x) и расходом топлива на трассе **hwy** (по оси y):\n\n```{r}\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy))\n```\n\nГрафик показывает наличие негативной взаимосвязи между объемом двигателя и эффективностью потребления топлива (сколько миль пожно проехать на одном галлоне), другими словами, чем больше объем двигателя, тем больше топлива требуется и тем меньше эффективность двигателя. Подтверждает ли график наши изначальные гипотезы?\n\n## Основная синтаксическая конструкция ggplot2\n\nДавайте еще раз посмотрим на код, с помощью которого мы построили график:\n\n`ggplot(data = mpg) +   geom_point(mapping = aes(x = displ, y = hwy))`\n\nКод всегда начинается с функции `ggplot()`, которая создает систему координат, на которую накладываются дальнейшие графические слои.\n\nПервый аргумент - `data` - указывает, какие данные нужно использовать для построения графика. Но если мы просто напишем `ggplot(data = mpg)` - график будет пустым (можете попробовать сами), так как мы больше ничего, кроме данных не добавили.\n\nЧтобы график получился, мы должны добавить к `ggplot()` по крайней мере один слой. Функция `geom_point()` добавляет слой в виде диаграммы рассеяния. Существует множетсво различных geom-функций, каждая из которых добавляет свой тип графического представления (слой). В рамках данного урока мы постараемся охватить несколько различных типов графиков, которые можно построить с помощью различных geom-ов.\n\nВнутри функции geom располагаются mapping-аргументы, определяющие, какие визуальные свойства будут присвоены переменным из нашего набора данных.\n\nАргумент mapping всегда идет в паре с функцией `aes()` (aes - сокращенное от Aesthetics - в русском языке есть похожее слово \"эстетика\", одно из значений которого - \"красота, художественная сущность объекта\", то есть данный аргумент отвечает за внешний вид нашего графика), и аргументы **x** и **y** функции aes() определяют, какие переменные будут располагаться по осям **x** и **y**.\n\nОбщая формула (шаблон) для графика выглядит следующим образом:\n\n`ggplot(data = <DATA>) +   <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))`\n\nВ течение этого урока мы будем последовательно заменять различные части этого шаблона на реальные данные и настройки, чтобы строить графики различного типа.\n\nНачнем с компонента MAPPINGS.\n\nНа графике ниже, группа точек (закрашены в красный цвет), кажется, выпадает из общего тренда. В чем же дело? У этих машин явно лучше показатели эффективности топлива, чем мы могли бы ожидать. Как можно объяснить данное явление?\n\n```{r echo=FALSE}\nggplot(data = mpg) +\n  geom_point(aes(x=displ, y=hwy, colour = displ > 5 & hwy > 22, size = displ > 5 & hwy > 22))+\n  scale_colour_manual(values = c(\"blue\", \"red\")) + \n  scale_size_manual(values =c(1, 2))+\n  theme(legend.position = \"none\")\n```\n\nПредположим, что, возможно, это гибридные машины, сочетающие различные виды топлива (например, бензин и электричество). Чтобы проверить эту гипотезу, мы можем посмотреть на переменную класса машины, согласно которой все автомобили в наборе данных классицируются как компактные (compact), среднего размера (midsize) или кроссоверы (SUV). Гибридные машины скорее всего принадлежат к классу компактных или субкомпактных (когда данные собирались, гибридные машины еще не были так распространены.\n\nДавайте добавим третью переменную - класс - к нашему двумерному графику в качестве дополнительного агрумента функции `aes()`. Такими аргументами могут быть: размер (`size`), форма (`shape`) или цвет наших точек (`color`). Мы можем отобразить точки разными способами, меняя характеристики аргументов, вернее присваивая им определенные \"уровни\", например, сделать точки разного размера, формы или цвета:\n\n![](https://d33wubrfki0l68.cloudfront.net/e2ebb6c8b73ed7f4a931b18dd6ce1a3165bf22e6/0c5bc/visualize_files/figure-html/unnamed-chunk-6-1.png)\n\nДавайте раскрасим точки на графике в зависимости от класса машины.\n\n```{r}\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy, color = class))\n```\n\nЧто и требовалось доказать! Почти все точки выделенной группы - это красные точки, представляющие класс двухместных машин. На самом деле, это не совсем гибридные машины, это спортивные машины! У таких машин большие двигатели, как у кроссоверов или грузовиков, но маленькие кузова, как у компактных машин, что повышает их эффективность. То есть дело вовсе не в гибридности.\n\nЧтобы \"привязять\" аргумент `aesthetic` к переменной, нужно внутри функции `aes()` связать имя переменной с именем одного из аргументов (`color`, `size`, `shape`), и `ggplot2` автоматически присвоит уникальный уровень каждому уникальному значению переменной (этот процесс называется масштабированием, по-английски `scaling`). Кроме того, `ggplot2` автоматически добавит легенду, объясняющую, как уровни соответствуют значениям переменной.\n\nВ данном примере мы связали переменную \"класс\" с аргументом цвета, но мы могли бы таким же образом, вместо цвета выбрать другой аргумент, например \"размер\". В этом случае, размер точки указывал бы на принадлежность к отдельному классу. Если мы запустим подобный код, программа нам выдаст предостережение о том, что применять такую \"эстетику\" к неупорядоченным данным (классы не имеют уровней, которые можно было бы привязать к размерам) - не очень хорошая идея.\n\n```{r message=FALSE, warning=FALSE}\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy, size = class))\n```\n\nМы могли бы отметить класс с помощью атрибута alpha (отвечает за прозрачность) или с помощью атрибута формы (shape).\n\n```{r}\n# Выделяем разные классы с помощью прозрачности\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy, alpha = class))\n```\n\n```{r}\n# Выделяем классы с помощью форм для точек\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy, shape = class))\n```\n\nЧто произошло с кроссоверами? Почему программа выдала ошибку? Дело в том, что в ggplot2 есть только шесть различных форм, которые могут использоваться одновременно. По умолчанию, если групп больше шести, то они на графике не отображаются.\n\nВажно отметить, что функция `aes()` собирает вместе все аргументы `aesthetic`, используемые в одном слое, при этом, переменные `x` и `y` тоже могут иметь свои характеристики. При этом пользователь лишь задает имена переменных, а `ggplot2` заботится об остальном - подбирает нужную шкалу, обозначает оси именами переменных.\n\nМы можем установить дополнительные опции вручную, например, сделать все точки синего цвета:\n\nОбратите внимание, что `color = \"blue\"`указывается за скобками функции `aes()`, так как мы не создаем отдельного измерения (каким являлся класс, например), а присваеваем свойство цвета всему графику.\n\n```{r}\nggplot(data = mpg) +\n  geom_point(aes(x = displ, y = hwy), color = \"blue\")\n```\n\nИными словами, цвет тут не несет никакой информации о данных, это просто характеристика внешнего вида, такая же как фон, цвет линий, шрифта и пр.\n\nЧтобы установить такие настройки, нужно вынести имя аргумента за пределы функции aes() и установить такое значение, которое бы имело значение для него (которое поймет R).\n\nНапример, имя цвета (color) - это строковая переменная (\"red\", \"blue\", \"green\" огромный список имен цветов - http://www.stat.columbia.edu/\\~tzheng/files/Rcolor.pdf)\n\nРазмер (`size`) - размер в мм.\n\nФорма тоже задается с помощью чисел (см. рисунок ниже):\n\n![](https://d33wubrfki0l68.cloudfront.net/e28a1b57b6622cf67fd8a7e01c6a9955914f8fe9/635be/visualize_files/figure-html/shapes-1.png)\n\n{{< iconify arcticons writer size=42px >}} **Самостоятельное задание**:\n\n1. Что не так с этим кодом? (попробуйте запустить, посмотреть и разобраться и в ячейке внизу написать правильный код)\n\n`ggplot(data = mpg) +   geom_point(mapping = aes(x = displ, y = hwy, color = \"blue\"))`\n\n2.  Какие переменные в наборе mpg являются категориальными, а какие непрерывными? \n3.  Выберите одну из количественных переменных и включите ее в в код в качестве аргумента `color`, `size` или `shape`. Посмотрите, как различается представление категориальных и количественных переменных? В каком случае возникает ошибка? Почему?\n4.  Что произойдет, если одну и ту же переменную, например, drv, назначить в качестве аргумента в разных настройках (например, и в качестве shape и в качестве color)? Измените исходный код графика и запишите его ниже.\n5.  В функции geom_point есть еще несколько аргументов в функции aes(), например - stroke, fill и group. Посмотрите, примеры кода для построения графиков с такими аргументами и приведите один из примеров ниже.\n6.  Что произойдет, если вместо имены переменной указать что-то другое, наприме, aes(colour = displ \\< 5)? Попробуйте измеить код и вставить ниже.\n\n\n## Потенциальные проблемы\n\nКогда вы начнете писать код на R, вероятнее всего, вы будете допускать ошибки и сталкиваться с проблемами. Не отчаивайтесь! Так происходит со всеми, даже очень опытными пользователями (вспомните ситуацию на лекции, когда мы пытались перевести список в вектор, и ничего не получилось).\n\n> Совет: сравните свой код с кодом в примере, обращайте внимание на мелочи - расположение скобок и запятых, особенно знаков \"+\", связывающих разные слои графической информации. Также обязательно посчитайте количество скобок - каждая открывающая скобка должна иметь свою пару - закрывающую скобку, в противном случае, будут возникать ошибки.\n\nИногда вы можете запустить код, а ничего не происходит. Если вы работаете в RStudio, посмотрите в окно консоли - знак + будет означать, что в ваш код не закончен и \"чего-то не хватает\". В этом случае, чаще всего, лучше нажать клавишу Esc и начать все заново (ну, или кропотливо, символ за символом, проверить, что не так).\n\nОдна из часто встречающихся проблем при создании графиков ggplot2 постановка + в неправильном месте: знак должен быть в конце строки, не в начале. Удостоверьтесь, что ваш код не похож на такой:\n\n```{r}\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy))\n```\n\nЕсли вы не смогли исправить ошибку, не стесняйтесь обращаться за помощью к справочным материалам. По любой функции можно запустить справку с помощью кода `?имя_функции` в консоли или выбрать имя функции и нажать на клавишу F1 в RStudio. Полезные материалы можно найти на ресурсах: http://r-bloggers.com/, http://www.cookbook-r.com/, https://stackoverflow.com/questions/tagged/r и др.\n\nЕще один совет: тщательно читайте сообщение об ошибке. Чаще всего ответ кроется именно в нем. Можно \"загуглить\" сам текст ошибки: с большой вероятностью кто-то уже встречался с подобным случаем, и решение уже было найдено.\n\n## Facets (аспекты)\n\nКроме возможности отобразить переменные на графике в качестве эстетических атрибутов, можно их представить (особенно хорошо - если они категориальные) - на отдельных графиках, то есть разбить основной график на несколько мелких, в каждом из которых будет отражаться дополнительная информация, задаваемая путем разделения данных на отдельные поднаборы (подгруппы).\n\nЧтобы разбить график на отдельные подгруппы на основе одной переменной можно использовать функцию `facet_wrap()`. Ее первый аргумент - это формула, которая создается с помощью знака тильды \\~, за которым следует имя переменной (формула - это не уравнение, а тип структур данных, с помощью которых задается алгоритм анализа). Переменную, которую вы используете для `facet_wrap` должна быть дискретной (то есть иметь конкретные числовые значения). Например, разобьем наш график взаимосвязи между расходом топлива и объемом двигателя на основе переменной класса:\n\n```{r}\n#| colab: {base_uri: 'https://localhost:8080/', height: 96}\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy)) +\n  facet_wrap(~ class, nrow = 2)\n```\n\nЧтобы разбить график на основе **двух** дополнительных переменных, используется функция `facet_grid()`. Первый аргумент этой функции - тоже формула, но в ней уже должно содержаться две переменных, разделенных тильдой \\~.\n\n```{r}\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy)) +\n  facet_grid(drv ~ cyl)# разбиваем график на отдельные графики - по вертикали тип привода, по горизонтали - количество цилиндров.\n```\n\nЭту функцию можно использовать и с одной переменной, просто поставьте точку . вместо одного из имен переменных, например `+ facet_grid(. ~ cyl)`.\n\n```{r}\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy)) +\n  facet_grid(. ~ cyl)\n```\n\n**Упражнения:** 1. Что произойдет, если в функцию facet вставить непрерывную переменную? 2. Что означают пустые ячейки в графике с `facet_grid(drv ~ cyl)`?\n\nВставьте тут свой комментарий:\n\n## Геометрические объекты (geometric objects - geoms)\n\nЧем похожи эти два графика?\n\n![](https://d33wubrfki0l68.cloudfront.net/91aebc6de4de928abc810433b752274ba6a46d58/4e9f7/visualize_files/figure-html/unnamed-chunk-17-1.png)\n\n\n![](https://d33wubrfki0l68.cloudfront.net/43f153577e9c8e7f012c0606cbfbeb4d2e9ce409/17627/visualize_files/figure-html/unnamed-chunk-17-2.png)\n\n\nОба графика имеют одни и те же x и y переменные, оба - описывают одни и те же данные. Но все же они не идентичны. Каждый график представляет данные по своему, использует разные визуальные объекты. Каждый такой объект в синтаксисе ggplot2 называется **geom**.\n\nЛюди описывают графики по типу геометрического объекта, который лежит в его основе. Например, столбчатые диаграммы (bar charts) используют bar geom, линейчатаые диагранны (line chart) - line geom, ящичные (boxplot) - boxplot geom и так далее. Для диаграммы рассеяния есть point geom.\n\nМы можем использовать разные geom-ы, чтобы по-разному представлять наши данные. Так, на графике выше слева предствлена точечная диаграмма (диаграмма рассеяния), а справа приведена линейная диаграмма со сглаживанием (smooth geom), где линия соответствует степенной функции, максимально приближенной к исходным данным.\n\nЧтобы поменять геометрический объект на графике, нужно изменить функцию geom. Чтобы воспроизвести код на картинке:\n\n```{r}\n# Левый график\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy))\n\n# Правый график\nggplot(data = mpg) +\n  geom_smooth(mapping = aes(x = displ, y = hwy))\n```\n\nУ каждой функции geom в библиотеке ggplot2 есть свои аргументы mapping, но не с каждым geom будет работать каждый эстетический аргумент. Например, мы можем установить форму (shape) для точки, но не сможем сделать это для линии. А для линии возможно установить аргумент linetype (тип линии), и geom_smooth() нарисует различные линии для каждого уникального значения переменной, которая указана для данного аргумента.\n\nПример:\n\n```{r}\nggplot(data = mpg) +\n  geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv))\n```\n\nВ этом примере `geom_smooth()` разделяет машины на три группы, в зависимости от значения привода (drv), и по каждой группе отображает отдельную линию. Так, одна линия описывает все полноприводные машины (4), другая - переднеприводные (f), третья - заднеприводные (r).\n\nМы можем добавить цвета для наглядности:\n\n```{r}\nggplot(data = mpg) +\n  geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv, color=drv))+\n  geom_point(mapping = aes(x = displ, y = hwy, color=drv))\n```\n\nОбратите внимание, что этом графике мы использовали два слоя - точечную диаграмму и сглаживание!\n\nВ библиотеке ggplot2 содержится более 40 geom-функций, а в дополнительных библиотеках - еще больше (подробности можно посмотреть здесь: https://r-graph-gallery.com/, https://exts.ggplot2.tidyverse.org/gallery/). Чтобы узнать больше по каждой функции, запросите справку, например: `?geom_smooth`.\n\nДавайте рассмотрим еще один пример с двойным слоем, где одни и те же данные отображены на графике и как диаграмма сглаживания и как диаграмма рассеяния:\n\n```{r}\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy)) +\n  geom_smooth(mapping = aes(x = displ, y = hwy))\n```\n\nНаверняка вы заметили, что происходит дублирование кода (в скобках), и если нам бы понадобилось поменять переменную, то пришлось бы менять ее дважды - в каждом слое. Это не очень рационально, и можно сделать код более лаконичным благодаря переносу эстетических аргументов на уровень вверх, в основную функцию `ggplot()`. Тогда ggplot2 будет считать эти аргументы глобальными и применять ко всем геометрическим объектам графика.\n\nВот как можно было сделать:\n\n```{r}\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +\n  geom_point() +\n  geom_smooth()\n```\n\nСоответственно, если вы указываете эстетические аргументы внутри функции-geom, то ggplot2 рассматривает их как локальные аргументы слоя. В этом случае (поскольку код обрабатывается последовательно), настройки слоя \"переписывают\" глобальные настройки, что позволяет еще больше дифференцировать внешний вид нашего графика.\n\nПример:\n\n```{r}\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + #глобальные настройки\n  geom_point(mapping = aes(color = class)) + #локальные настройки для точечного графика\n  geom_smooth()\n```\n\nЭту идею можно развить дальше для того, чтобы каждый слой представлял только определенные данные. В примере ниже, сглаженная линия отображает только данные по одному классу - субкомпактных машин, и локальный аргумент фильтра данных в `geom_smooth()` как бы переписывает аргументы в глобальных настройках, но только для этого слоя.\n\n```{r}\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +\n  geom_point(mapping = aes(color = class)) +\n  geom_smooth(data = filter(mpg, class == \"subcompact\"), se = FALSE)\n```\n\n## Темы\n\nТе графики, которые мы только что создали, оформлены с помощью темы по умолчанию, но она может нас не устраивать. Возможно, кому-то не понравится решетка или серый фон, комку-то захочется убрать легенду или поменять оформление осей. Всеми этими параметрами управляет такой слой графика, как тема - `theme`. Параметром по умолчанию является тема - theme_grey().\n\nВ библиотеке ggplot2 встроено 11 разных тем.\n\nДавайте возьмем наш базовый график и попробуем применить к нему различные темы:\n\n-   theme_bw()\n-   theme_void()\n-   theme_dark()\n\n```{r}\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +\n  geom_point() +\n  geom_smooth() +\n  theme_bw()\n```\n\nКроме встроенных тем, есть по меньшей мере пять библиотек, специализирующихся на разработке тем для ggplot2.\n\n{{< iconify arcticons huawei-tips size=42px >}}**Дополнительный материал**: [https://r-charts.com/ggplot2/themes/](https://r-charts.com/ggplot2/themes/)\n\n## Статистические трансформации\n\nМы много времени уделили количественным переменными, давайте теперь посмотрим на качественные (категориальные), каких в социологических исследований встречается огромное количество. Чаще всего для их визуализации используются столбчатые диаграммы (bar chart), которые кажутся простыми, но только с первого взгляда, так как на самом деле не все так просто.\n\nПредставим себе базовый график, созданный с помощью функции `geom_bar()`. На графике ниже представлена информация о количестве бриллиантов из одноименного набора данных (diamonds), сгруппированных по критерию огранки (cut). Датасет `diamonds` прилагается к библиотеке `ggplot2` и содержит информацию о \\~54,000 бриллиантах, включая данные о цене (`price`) количестве каратов (`carat`), цвете (`color`), чистоте (`clarity`) и огранке (`cut`). График ниже показывает, что количество бриллиантов с хорошим качеством огранки больше, чем плохих бриллиантов с огранкой похуже.\n\n```{r}\nggplot(data = diamonds) +\n  geom_bar(mapping = aes(x = cut))\n```\n\nПо оси x у нас располагается переменная `cut` (огранка), а по оси y - количество (`count`).\n\nЗдесь может быть непонятный момент, откуда взялось количество, ведь такой переменной в наборе нет?\n\nЗдесь нужно пояснить, что многие типы графиков (типа диаграмм рассеяния) отображают на графике сами значения, тогда как другие - например барчарты или гистограммы, полигоны частот разделяют данные на группы (bins), а затем по каждой группе рассчитывают частоты или другие показатели.\n\nДиаграммы, демонстрирующие подгонку кривых, строят модель, а затем визуализируют предсказания данной модели.\n\nБоксплоты рассчитывают робастные показатели (медиану, квартили) и отображают их в характерном виде.\n\nСоответственно, алгоритм, который используется для подсчета новых значений, используемых в графике, называется статистической трансформацией.\n\nО том, какую статистику использует каждый `geom`, можно узнать, проинспектировав статистику, рассчитываемую по умолчанию. Так, `?geom_bar` показывает, что статистика по умолчанию для барчарта - это `stat_count()` - то есть простой подсчет количества.\n\nМы можем использовать geom-ы и статистические функции как взаимозаменяемые. Например, мы можем воспроизвести предыдущий график не с помощью `geom_bar ()`, а с помощью `stat_count()`, результат будет идентичным:\n\n```{r}\nggplot(data = diamonds) +\n  stat_count(mapping = aes(x = cut))\n```\n\nТакой подход работает, потому что у каждого `geom` есть своя статистика, а у каждой статистики - свой типичный график.\n\nИменно поэтому мы можем создавать графические слои, не беспокоясь о том, что нам могут потребоваться какие-то статистические расчеты.\n\nОднако иногда мы можем задавать статистику принудительно, вместо установок по умолчанию. Например, если мы хотим вместо количества (абсолютные значения) указать относительные частоты (проценты):\n\n```{r}\nggplot(data = diamonds) +\n  geom_bar(mapping = aes(x = cut, y = stat(prop), group = 1))\n```\n\n{{< iconify arcticons huawei-tips size=42px >}}**Дополнительный материал**:  в библиотеку ggplot2 включено более 20 статистических функций, которые мы можем использовать в своих визуализациях [https://ggplot2.tidyverse.org/reference/#stats](https://ggplot2.tidyverse.org/reference/#stats)\n\n## Дополнительные настройки цвета\n\nСо столбчатыми диаграммами связана еще одна «магическая история»: мы можем применять настройки цвета как в отношении контура (обычный аргумент `color`), так и заполнять цветом столбцы (аргумент `fill`):\n\n```{r}\n# Посмотрите на эти два графика и найдите отличия\nggplot(data = diamonds) +\n  geom_bar(mapping = aes(x = cut, colour = cut))\nggplot(data = diamonds) +\n  geom_bar(mapping = aes(x = cut, fill = cut))\n```\n\nЧто произойдет, если мы аргументу `fill` присвоим другую переменную, например чистоту (`clarity`): столбцы автоматически разделяются по группам, и каждый столбец представляет собой комбинацию огранки и чистоты.\n\n```{r}\nggplot(data = diamonds) +\n  geom_bar(mapping = aes(x = cut, fill = clarity))\n```\n\nЕсли мы не желаем, чтобы у нас получилась комбинированная диаграмма, мы должны использовать аргумент, задающий позицию элементов - `position`: `identity`, `dodge` или `fill`:\n\n- position = \"identity\" - поставит каждый объект на ту позицию, которую он занимает в контексте. С барчартами применять не очень актуально, поскольку получается пересечение категорий, что хорошо заметно, если вместо закрашивания использовать прозрачность или вообще убрать цвет, а вот для точечных диаграмм это позиция по умолчанию:\n\n```{r}\nggplot(data = diamonds, mapping = aes(x = cut, fill = clarity)) +\n  geom_bar(alpha = 1/5, position = \"identity\")\nggplot(data = diamonds, mapping = aes(x = cut, colour = clarity)) +\n  geom_bar(fill = NA, position = \"identity\")\n```\n\n- position = \"fill\" работает по типу накопленной диаграммы, приводит все столбцы к единой высоте, что позволяет более наглядно представить распределение ответов и сравнивать группы.\n\n```{r}\nggplot(data = diamonds) +\n  geom_bar(mapping = aes(x = cut, fill = clarity), position = \"fill\")\n```\n\n - position = \"dodge\" помещает пересекающиеся объекты рядом друг с другом, что позволяет сравнить индивидуальные значения по каждой категории.\n\n```{r}\nggplot(data = diamonds) +\n  geom_bar(mapping = aes(x = cut, fill = clarity), position = \"dodge\")\n```\n\nЕсть еще один тип уточнения позиции, который не очень подходит для барчартов, но может быть полезен для диаграмм рассеяния.\n\nПомните наш первый график? Отметили ли вы, что на графике всего 126 точек (может быть вы и не считали, но просто засомневались, что на графике отображены не все данные)? А ведь в наборе 234 наблюдения.\n\n::: {style=\"max-width:600px; margin-left: 0; margin-right: 0;\"}\n![](https://d33wubrfki0l68.cloudfront.net/91aebc6de4de928abc810433b752274ba6a46d58/acd97/visualize_files/figure-html/unnamed-chunk-41-1.png)\n:::\n\nЗначения переменных `hwy` и `displ` приводятся в округленном виде, что приводит к тому, что на графике точки располагаются одна над другой, происходит их пересечение. Соответственно, нам не очень хорошо видно скопление точек, это может быть очень критичный момент для анализа.\n\nЧтобы избежать такой ситуации, пожно применить аргумент мэппинга `position = \"jitter\"`, который добавляет немного статистического шума к каждой точке и, таким образом, раздвигает их немного в стороны.\n\n```{r}\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy), position = \"jitter\")\n```\n\nЧтобы узнать больше, просим запустить справку: ?position_dodge, ?position_fill, ?position_identity, ?position_jitter, ?position_stack.\n\n**Упражнения:** 1. Какие проблемы у этого графика? Как сделать его лучше?\n\n`ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +   geom_point()`\n\n2.  Создайте столбчатый график, покзывающий взаимосвязь между цветом и огранкой бриллиантов. Сделайте настройки так, чтобы столбцы были одинаковой длины.\n\n## Поворот системы координат\n\nПоследний вопрос, который мы рассмотрим, связан с поворотом системы координат, которое иногда применяется для того, чтобы сделать график более читаемым.\n\n`coord_flip()` меняет местами оси x и y. Применяется, например, для транспонирования боксплота, если метки переменных очень длинные и не входят по ширине:\n\n```{r}\nggplot(data = mpg, mapping = aes(x = class, y = hwy)) +\n  geom_boxplot()#обычный боксплот\n```\n\n```{r}\nggplot(data = mpg, mapping = aes(x = class, y = hwy)) +\n  geom_boxplot() +\n  coord_flip()#повернутый боксплот\n```\n\ncoord_polar() превращает столбчатую диаграмму в круговую, в итоге получается график - нечто среднее между столбчатым графиком и графиком \"петушиный гребень\".\n\n```{r}\nbar <- ggplot(data = diamonds) +\n  geom_bar(\n    mapping = aes(x = cut, fill = cut),\n    show.legend = FALSE,\n    width = 1\n  ) +\n  theme(aspect.ratio = 1) +\n  labs(x = NULL, y = NULL)\n\nbar + coord_flip()#линейчатая диаграмма (перевернутый барчарт)\n```\n\n```{r}\nbar + coord_polar()#диаграмма с круговыми координатами\n```\n\n## Самостоятельная работа\n\n1. Какой `geom` нужно использовать, чтобы нарисовать линейный график? А боксплот? А гистограмму? А диаграмму с областями (area chart)? Создайте такие графики для переменных набора mpg, mtcars или diamonds.\n\nИспользуйте памятку:\n![](https://www.dartistics.com/images/ggplot2_geoms.png)\n\n2.  Постройте вот такие графики:\n\n::: {style=\"max-width:500px; margin-left: 0; margin-right: 0;\"}\n![](https://d33wubrfki0l68.cloudfront.net/9ad169a7a48c6f1493bfb9eb1d89118975304cc2/df994/visualize_files/figure-html/unnamed-chunk-28-3.png)\n:::\n\n::: {style=\"max-width:500px; margin-left: 0; margin-right: 0;\"}\n![](https://d33wubrfki0l68.cloudfront.net/9a3c63edfc170c576ec5d34faa90df2dc2a43443/7f9e5/visualize_files/figure-html/unnamed-chunk-28-5.png)\n:::\n\n3.  Постройте перевернутый барчарт по одной из категориальных переменных набора данных `diamonds`.\n\n4.  Примените опцию `coord_polar()` к созданному графику.\n5. Все результаты оформить в виде документа RMarkdown и опубликовать на RPubs. Результаты прикрепить в виде ссылки. \n","srcMarkdownNoYaml":"\n\n> “Простой график принес аналитику данных больше информации , чем какое-либо устройство\", ” — Джон Тьюки.\n\nВизуализация является очень важным этапом анализа данных, который может выполнять как вспомогательные, так и свои собственные, самостоятельные функции.\n\nМы уже освоили основы отбора и трансформации данных (tidy and transofrm), теперь настал черед познакомиться с некоторыми возможностями визуального представления данных, которое, наряду с моделированием, собственно и формирует исследовательский процесс:\n\n![](https://d33wubrfki0l68.cloudfront.net/795c039ba2520455d833b4034befc8cf360a70ba/558a5/diagrams/data-science-explore.png)\n\nНа сегодняшнем занятии мы научимся визуализировать данные, используя возможности библиотеки ggplot2. Вообще-то, в R есть различные способы создания графиков (на следующих занятиях мы обязательно попробуем разные), но библиотека ggplot2 является одной из наиболее продвинутых, чьи основы часто используются другими библиотеками (например, библиотекой для работы со шкалами Ликерта `likert`).\n\nСчитается, что обучение визуализации с помощью `ggplot2`подходит для тех, кто только начинает осваивать программирование (хотя есть и те, кто считает ggplot2 слишком сложным, поскольку график задается эксплицитно - мы должны в ручном режиме прописать все параметры, включая оформление, цвета, надписи осей и прочие элементы, которые excel, например, дает по умолчанию), а понимание графической \"грамматики\" - правил, на основе которых строются графики, дает практически безграничные возможности в плане представления результатов анализа данных. Возможно, по началу, вам будет казаться, что код громоздкий и что диаграммы в excel было бы сделать намного проще, со временем вы сможете понять всю красоту и гибкость такой визуализации.\n\nПосколькуо библиотека `ggplot2` является важным членом семьи `tidyverse`, чтобы получить доступ к встроенным наборам данных, справочным страницам и функциям, мы должны загрузить библиотеку `tidyverse` с помощью уже известной нам функции `library()`:\n\n```{r}\nlibrary(tidyverse)\n```\n\n\nДавайте попробуем создать наш первый график на основе набора данных `mpg`, встроенного в `ggplot2`, который содержит технические данные о 38 моделях автомобилей, выпущенных с 1999 по 2008 гг., собранные американским агентством по защите окружающей среды, включая следующие переменные: \n\n- производитель (manufacturer) \n- модель (model) \n- объем двигателя в литрах (displ) \n- год производства (year) \n- количество цилиндров (cyl) \n- тип трансмиссии (trans) \n- привод (drv, f - передний привод, r - задний привод, 4wd - полный привод) \n- расход топлива в городе (cty) \n- расход топлива на трассе (hwy) \n- тип топлива (fl) \n- класс машины (class, 2seater - маленькая машина на 2 пассажиров, compact - компактная, midsize - средних размеров, minivan - минивен, pickup - пикап, subcompact - субкомпактная, suv - кроссовер). Кому интересны подробности: https://en.wikipedia.org/wiki/Car_classification\n\nК примеру, мы можем задаться вопросом: потребляют ли большие машины (с большим объемом двигателя) больше топлива, чем малолитражки? Возможно, мы уже знаем ответ на данный вопрос, и все кажется очевидным, но мы можем еще раз удостовериться в своих предположениях. Какова в действительности взаимосвязь между объемом двигателя и потребляемым топливом? Является ли она положительной? Или отрицательной? Линейной? Или Нелинейной?\n\nПопробуем выяснить.\n\nПрежде всего давайте посмотрим, что представляют собой наши данные:\n\n```{r}\nmpg\n```\n\nЧтобы узнать больше о данном наборе данных, нужно запустить код `?mpg`.\n\n## Создаем первый график ggplot\n\nСоздадим график, визуализирующий взаимосвязь между объемом двигателя **displ** (по оси x) и расходом топлива на трассе **hwy** (по оси y):\n\n```{r}\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy))\n```\n\nГрафик показывает наличие негативной взаимосвязи между объемом двигателя и эффективностью потребления топлива (сколько миль пожно проехать на одном галлоне), другими словами, чем больше объем двигателя, тем больше топлива требуется и тем меньше эффективность двигателя. Подтверждает ли график наши изначальные гипотезы?\n\n## Основная синтаксическая конструкция ggplot2\n\nДавайте еще раз посмотрим на код, с помощью которого мы построили график:\n\n`ggplot(data = mpg) +   geom_point(mapping = aes(x = displ, y = hwy))`\n\nКод всегда начинается с функции `ggplot()`, которая создает систему координат, на которую накладываются дальнейшие графические слои.\n\nПервый аргумент - `data` - указывает, какие данные нужно использовать для построения графика. Но если мы просто напишем `ggplot(data = mpg)` - график будет пустым (можете попробовать сами), так как мы больше ничего, кроме данных не добавили.\n\nЧтобы график получился, мы должны добавить к `ggplot()` по крайней мере один слой. Функция `geom_point()` добавляет слой в виде диаграммы рассеяния. Существует множетсво различных geom-функций, каждая из которых добавляет свой тип графического представления (слой). В рамках данного урока мы постараемся охватить несколько различных типов графиков, которые можно построить с помощью различных geom-ов.\n\nВнутри функции geom располагаются mapping-аргументы, определяющие, какие визуальные свойства будут присвоены переменным из нашего набора данных.\n\nАргумент mapping всегда идет в паре с функцией `aes()` (aes - сокращенное от Aesthetics - в русском языке есть похожее слово \"эстетика\", одно из значений которого - \"красота, художественная сущность объекта\", то есть данный аргумент отвечает за внешний вид нашего графика), и аргументы **x** и **y** функции aes() определяют, какие переменные будут располагаться по осям **x** и **y**.\n\nОбщая формула (шаблон) для графика выглядит следующим образом:\n\n`ggplot(data = <DATA>) +   <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))`\n\nВ течение этого урока мы будем последовательно заменять различные части этого шаблона на реальные данные и настройки, чтобы строить графики различного типа.\n\nНачнем с компонента MAPPINGS.\n\nНа графике ниже, группа точек (закрашены в красный цвет), кажется, выпадает из общего тренда. В чем же дело? У этих машин явно лучше показатели эффективности топлива, чем мы могли бы ожидать. Как можно объяснить данное явление?\n\n```{r echo=FALSE}\nggplot(data = mpg) +\n  geom_point(aes(x=displ, y=hwy, colour = displ > 5 & hwy > 22, size = displ > 5 & hwy > 22))+\n  scale_colour_manual(values = c(\"blue\", \"red\")) + \n  scale_size_manual(values =c(1, 2))+\n  theme(legend.position = \"none\")\n```\n\nПредположим, что, возможно, это гибридные машины, сочетающие различные виды топлива (например, бензин и электричество). Чтобы проверить эту гипотезу, мы можем посмотреть на переменную класса машины, согласно которой все автомобили в наборе данных классицируются как компактные (compact), среднего размера (midsize) или кроссоверы (SUV). Гибридные машины скорее всего принадлежат к классу компактных или субкомпактных (когда данные собирались, гибридные машины еще не были так распространены.\n\nДавайте добавим третью переменную - класс - к нашему двумерному графику в качестве дополнительного агрумента функции `aes()`. Такими аргументами могут быть: размер (`size`), форма (`shape`) или цвет наших точек (`color`). Мы можем отобразить точки разными способами, меняя характеристики аргументов, вернее присваивая им определенные \"уровни\", например, сделать точки разного размера, формы или цвета:\n\n![](https://d33wubrfki0l68.cloudfront.net/e2ebb6c8b73ed7f4a931b18dd6ce1a3165bf22e6/0c5bc/visualize_files/figure-html/unnamed-chunk-6-1.png)\n\nДавайте раскрасим точки на графике в зависимости от класса машины.\n\n```{r}\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy, color = class))\n```\n\nЧто и требовалось доказать! Почти все точки выделенной группы - это красные точки, представляющие класс двухместных машин. На самом деле, это не совсем гибридные машины, это спортивные машины! У таких машин большие двигатели, как у кроссоверов или грузовиков, но маленькие кузова, как у компактных машин, что повышает их эффективность. То есть дело вовсе не в гибридности.\n\nЧтобы \"привязять\" аргумент `aesthetic` к переменной, нужно внутри функции `aes()` связать имя переменной с именем одного из аргументов (`color`, `size`, `shape`), и `ggplot2` автоматически присвоит уникальный уровень каждому уникальному значению переменной (этот процесс называется масштабированием, по-английски `scaling`). Кроме того, `ggplot2` автоматически добавит легенду, объясняющую, как уровни соответствуют значениям переменной.\n\nВ данном примере мы связали переменную \"класс\" с аргументом цвета, но мы могли бы таким же образом, вместо цвета выбрать другой аргумент, например \"размер\". В этом случае, размер точки указывал бы на принадлежность к отдельному классу. Если мы запустим подобный код, программа нам выдаст предостережение о том, что применять такую \"эстетику\" к неупорядоченным данным (классы не имеют уровней, которые можно было бы привязать к размерам) - не очень хорошая идея.\n\n```{r message=FALSE, warning=FALSE}\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy, size = class))\n```\n\nМы могли бы отметить класс с помощью атрибута alpha (отвечает за прозрачность) или с помощью атрибута формы (shape).\n\n```{r}\n# Выделяем разные классы с помощью прозрачности\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy, alpha = class))\n```\n\n```{r}\n# Выделяем классы с помощью форм для точек\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy, shape = class))\n```\n\nЧто произошло с кроссоверами? Почему программа выдала ошибку? Дело в том, что в ggplot2 есть только шесть различных форм, которые могут использоваться одновременно. По умолчанию, если групп больше шести, то они на графике не отображаются.\n\nВажно отметить, что функция `aes()` собирает вместе все аргументы `aesthetic`, используемые в одном слое, при этом, переменные `x` и `y` тоже могут иметь свои характеристики. При этом пользователь лишь задает имена переменных, а `ggplot2` заботится об остальном - подбирает нужную шкалу, обозначает оси именами переменных.\n\nМы можем установить дополнительные опции вручную, например, сделать все точки синего цвета:\n\nОбратите внимание, что `color = \"blue\"`указывается за скобками функции `aes()`, так как мы не создаем отдельного измерения (каким являлся класс, например), а присваеваем свойство цвета всему графику.\n\n```{r}\nggplot(data = mpg) +\n  geom_point(aes(x = displ, y = hwy), color = \"blue\")\n```\n\nИными словами, цвет тут не несет никакой информации о данных, это просто характеристика внешнего вида, такая же как фон, цвет линий, шрифта и пр.\n\nЧтобы установить такие настройки, нужно вынести имя аргумента за пределы функции aes() и установить такое значение, которое бы имело значение для него (которое поймет R).\n\nНапример, имя цвета (color) - это строковая переменная (\"red\", \"blue\", \"green\" огромный список имен цветов - http://www.stat.columbia.edu/\\~tzheng/files/Rcolor.pdf)\n\nРазмер (`size`) - размер в мм.\n\nФорма тоже задается с помощью чисел (см. рисунок ниже):\n\n![](https://d33wubrfki0l68.cloudfront.net/e28a1b57b6622cf67fd8a7e01c6a9955914f8fe9/635be/visualize_files/figure-html/shapes-1.png)\n\n{{< iconify arcticons writer size=42px >}} **Самостоятельное задание**:\n\n1. Что не так с этим кодом? (попробуйте запустить, посмотреть и разобраться и в ячейке внизу написать правильный код)\n\n`ggplot(data = mpg) +   geom_point(mapping = aes(x = displ, y = hwy, color = \"blue\"))`\n\n2.  Какие переменные в наборе mpg являются категориальными, а какие непрерывными? \n3.  Выберите одну из количественных переменных и включите ее в в код в качестве аргумента `color`, `size` или `shape`. Посмотрите, как различается представление категориальных и количественных переменных? В каком случае возникает ошибка? Почему?\n4.  Что произойдет, если одну и ту же переменную, например, drv, назначить в качестве аргумента в разных настройках (например, и в качестве shape и в качестве color)? Измените исходный код графика и запишите его ниже.\n5.  В функции geom_point есть еще несколько аргументов в функции aes(), например - stroke, fill и group. Посмотрите, примеры кода для построения графиков с такими аргументами и приведите один из примеров ниже.\n6.  Что произойдет, если вместо имены переменной указать что-то другое, наприме, aes(colour = displ \\< 5)? Попробуйте измеить код и вставить ниже.\n\n\n## Потенциальные проблемы\n\nКогда вы начнете писать код на R, вероятнее всего, вы будете допускать ошибки и сталкиваться с проблемами. Не отчаивайтесь! Так происходит со всеми, даже очень опытными пользователями (вспомните ситуацию на лекции, когда мы пытались перевести список в вектор, и ничего не получилось).\n\n> Совет: сравните свой код с кодом в примере, обращайте внимание на мелочи - расположение скобок и запятых, особенно знаков \"+\", связывающих разные слои графической информации. Также обязательно посчитайте количество скобок - каждая открывающая скобка должна иметь свою пару - закрывающую скобку, в противном случае, будут возникать ошибки.\n\nИногда вы можете запустить код, а ничего не происходит. Если вы работаете в RStudio, посмотрите в окно консоли - знак + будет означать, что в ваш код не закончен и \"чего-то не хватает\". В этом случае, чаще всего, лучше нажать клавишу Esc и начать все заново (ну, или кропотливо, символ за символом, проверить, что не так).\n\nОдна из часто встречающихся проблем при создании графиков ggplot2 постановка + в неправильном месте: знак должен быть в конце строки, не в начале. Удостоверьтесь, что ваш код не похож на такой:\n\n```{r}\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy))\n```\n\nЕсли вы не смогли исправить ошибку, не стесняйтесь обращаться за помощью к справочным материалам. По любой функции можно запустить справку с помощью кода `?имя_функции` в консоли или выбрать имя функции и нажать на клавишу F1 в RStudio. Полезные материалы можно найти на ресурсах: http://r-bloggers.com/, http://www.cookbook-r.com/, https://stackoverflow.com/questions/tagged/r и др.\n\nЕще один совет: тщательно читайте сообщение об ошибке. Чаще всего ответ кроется именно в нем. Можно \"загуглить\" сам текст ошибки: с большой вероятностью кто-то уже встречался с подобным случаем, и решение уже было найдено.\n\n## Facets (аспекты)\n\nКроме возможности отобразить переменные на графике в качестве эстетических атрибутов, можно их представить (особенно хорошо - если они категориальные) - на отдельных графиках, то есть разбить основной график на несколько мелких, в каждом из которых будет отражаться дополнительная информация, задаваемая путем разделения данных на отдельные поднаборы (подгруппы).\n\nЧтобы разбить график на отдельные подгруппы на основе одной переменной можно использовать функцию `facet_wrap()`. Ее первый аргумент - это формула, которая создается с помощью знака тильды \\~, за которым следует имя переменной (формула - это не уравнение, а тип структур данных, с помощью которых задается алгоритм анализа). Переменную, которую вы используете для `facet_wrap` должна быть дискретной (то есть иметь конкретные числовые значения). Например, разобьем наш график взаимосвязи между расходом топлива и объемом двигателя на основе переменной класса:\n\n```{r}\n#| colab: {base_uri: 'https://localhost:8080/', height: 96}\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy)) +\n  facet_wrap(~ class, nrow = 2)\n```\n\nЧтобы разбить график на основе **двух** дополнительных переменных, используется функция `facet_grid()`. Первый аргумент этой функции - тоже формула, но в ней уже должно содержаться две переменных, разделенных тильдой \\~.\n\n```{r}\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy)) +\n  facet_grid(drv ~ cyl)# разбиваем график на отдельные графики - по вертикали тип привода, по горизонтали - количество цилиндров.\n```\n\nЭту функцию можно использовать и с одной переменной, просто поставьте точку . вместо одного из имен переменных, например `+ facet_grid(. ~ cyl)`.\n\n```{r}\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy)) +\n  facet_grid(. ~ cyl)\n```\n\n**Упражнения:** 1. Что произойдет, если в функцию facet вставить непрерывную переменную? 2. Что означают пустые ячейки в графике с `facet_grid(drv ~ cyl)`?\n\nВставьте тут свой комментарий:\n\n## Геометрические объекты (geometric objects - geoms)\n\nЧем похожи эти два графика?\n\n![](https://d33wubrfki0l68.cloudfront.net/91aebc6de4de928abc810433b752274ba6a46d58/4e9f7/visualize_files/figure-html/unnamed-chunk-17-1.png)\n\n\n![](https://d33wubrfki0l68.cloudfront.net/43f153577e9c8e7f012c0606cbfbeb4d2e9ce409/17627/visualize_files/figure-html/unnamed-chunk-17-2.png)\n\n\nОба графика имеют одни и те же x и y переменные, оба - описывают одни и те же данные. Но все же они не идентичны. Каждый график представляет данные по своему, использует разные визуальные объекты. Каждый такой объект в синтаксисе ggplot2 называется **geom**.\n\nЛюди описывают графики по типу геометрического объекта, который лежит в его основе. Например, столбчатые диаграммы (bar charts) используют bar geom, линейчатаые диагранны (line chart) - line geom, ящичные (boxplot) - boxplot geom и так далее. Для диаграммы рассеяния есть point geom.\n\nМы можем использовать разные geom-ы, чтобы по-разному представлять наши данные. Так, на графике выше слева предствлена точечная диаграмма (диаграмма рассеяния), а справа приведена линейная диаграмма со сглаживанием (smooth geom), где линия соответствует степенной функции, максимально приближенной к исходным данным.\n\nЧтобы поменять геометрический объект на графике, нужно изменить функцию geom. Чтобы воспроизвести код на картинке:\n\n```{r}\n# Левый график\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy))\n\n# Правый график\nggplot(data = mpg) +\n  geom_smooth(mapping = aes(x = displ, y = hwy))\n```\n\nУ каждой функции geom в библиотеке ggplot2 есть свои аргументы mapping, но не с каждым geom будет работать каждый эстетический аргумент. Например, мы можем установить форму (shape) для точки, но не сможем сделать это для линии. А для линии возможно установить аргумент linetype (тип линии), и geom_smooth() нарисует различные линии для каждого уникального значения переменной, которая указана для данного аргумента.\n\nПример:\n\n```{r}\nggplot(data = mpg) +\n  geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv))\n```\n\nВ этом примере `geom_smooth()` разделяет машины на три группы, в зависимости от значения привода (drv), и по каждой группе отображает отдельную линию. Так, одна линия описывает все полноприводные машины (4), другая - переднеприводные (f), третья - заднеприводные (r).\n\nМы можем добавить цвета для наглядности:\n\n```{r}\nggplot(data = mpg) +\n  geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv, color=drv))+\n  geom_point(mapping = aes(x = displ, y = hwy, color=drv))\n```\n\nОбратите внимание, что этом графике мы использовали два слоя - точечную диаграмму и сглаживание!\n\nВ библиотеке ggplot2 содержится более 40 geom-функций, а в дополнительных библиотеках - еще больше (подробности можно посмотреть здесь: https://r-graph-gallery.com/, https://exts.ggplot2.tidyverse.org/gallery/). Чтобы узнать больше по каждой функции, запросите справку, например: `?geom_smooth`.\n\nДавайте рассмотрим еще один пример с двойным слоем, где одни и те же данные отображены на графике и как диаграмма сглаживания и как диаграмма рассеяния:\n\n```{r}\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy)) +\n  geom_smooth(mapping = aes(x = displ, y = hwy))\n```\n\nНаверняка вы заметили, что происходит дублирование кода (в скобках), и если нам бы понадобилось поменять переменную, то пришлось бы менять ее дважды - в каждом слое. Это не очень рационально, и можно сделать код более лаконичным благодаря переносу эстетических аргументов на уровень вверх, в основную функцию `ggplot()`. Тогда ggplot2 будет считать эти аргументы глобальными и применять ко всем геометрическим объектам графика.\n\nВот как можно было сделать:\n\n```{r}\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +\n  geom_point() +\n  geom_smooth()\n```\n\nСоответственно, если вы указываете эстетические аргументы внутри функции-geom, то ggplot2 рассматривает их как локальные аргументы слоя. В этом случае (поскольку код обрабатывается последовательно), настройки слоя \"переписывают\" глобальные настройки, что позволяет еще больше дифференцировать внешний вид нашего графика.\n\nПример:\n\n```{r}\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + #глобальные настройки\n  geom_point(mapping = aes(color = class)) + #локальные настройки для точечного графика\n  geom_smooth()\n```\n\nЭту идею можно развить дальше для того, чтобы каждый слой представлял только определенные данные. В примере ниже, сглаженная линия отображает только данные по одному классу - субкомпактных машин, и локальный аргумент фильтра данных в `geom_smooth()` как бы переписывает аргументы в глобальных настройках, но только для этого слоя.\n\n```{r}\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +\n  geom_point(mapping = aes(color = class)) +\n  geom_smooth(data = filter(mpg, class == \"subcompact\"), se = FALSE)\n```\n\n## Темы\n\nТе графики, которые мы только что создали, оформлены с помощью темы по умолчанию, но она может нас не устраивать. Возможно, кому-то не понравится решетка или серый фон, комку-то захочется убрать легенду или поменять оформление осей. Всеми этими параметрами управляет такой слой графика, как тема - `theme`. Параметром по умолчанию является тема - theme_grey().\n\nВ библиотеке ggplot2 встроено 11 разных тем.\n\nДавайте возьмем наш базовый график и попробуем применить к нему различные темы:\n\n-   theme_bw()\n-   theme_void()\n-   theme_dark()\n\n```{r}\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +\n  geom_point() +\n  geom_smooth() +\n  theme_bw()\n```\n\nКроме встроенных тем, есть по меньшей мере пять библиотек, специализирующихся на разработке тем для ggplot2.\n\n{{< iconify arcticons huawei-tips size=42px >}}**Дополнительный материал**: [https://r-charts.com/ggplot2/themes/](https://r-charts.com/ggplot2/themes/)\n\n## Статистические трансформации\n\nМы много времени уделили количественным переменными, давайте теперь посмотрим на качественные (категориальные), каких в социологических исследований встречается огромное количество. Чаще всего для их визуализации используются столбчатые диаграммы (bar chart), которые кажутся простыми, но только с первого взгляда, так как на самом деле не все так просто.\n\nПредставим себе базовый график, созданный с помощью функции `geom_bar()`. На графике ниже представлена информация о количестве бриллиантов из одноименного набора данных (diamonds), сгруппированных по критерию огранки (cut). Датасет `diamonds` прилагается к библиотеке `ggplot2` и содержит информацию о \\~54,000 бриллиантах, включая данные о цене (`price`) количестве каратов (`carat`), цвете (`color`), чистоте (`clarity`) и огранке (`cut`). График ниже показывает, что количество бриллиантов с хорошим качеством огранки больше, чем плохих бриллиантов с огранкой похуже.\n\n```{r}\nggplot(data = diamonds) +\n  geom_bar(mapping = aes(x = cut))\n```\n\nПо оси x у нас располагается переменная `cut` (огранка), а по оси y - количество (`count`).\n\nЗдесь может быть непонятный момент, откуда взялось количество, ведь такой переменной в наборе нет?\n\nЗдесь нужно пояснить, что многие типы графиков (типа диаграмм рассеяния) отображают на графике сами значения, тогда как другие - например барчарты или гистограммы, полигоны частот разделяют данные на группы (bins), а затем по каждой группе рассчитывают частоты или другие показатели.\n\nДиаграммы, демонстрирующие подгонку кривых, строят модель, а затем визуализируют предсказания данной модели.\n\nБоксплоты рассчитывают робастные показатели (медиану, квартили) и отображают их в характерном виде.\n\nСоответственно, алгоритм, который используется для подсчета новых значений, используемых в графике, называется статистической трансформацией.\n\nО том, какую статистику использует каждый `geom`, можно узнать, проинспектировав статистику, рассчитываемую по умолчанию. Так, `?geom_bar` показывает, что статистика по умолчанию для барчарта - это `stat_count()` - то есть простой подсчет количества.\n\nМы можем использовать geom-ы и статистические функции как взаимозаменяемые. Например, мы можем воспроизвести предыдущий график не с помощью `geom_bar ()`, а с помощью `stat_count()`, результат будет идентичным:\n\n```{r}\nggplot(data = diamonds) +\n  stat_count(mapping = aes(x = cut))\n```\n\nТакой подход работает, потому что у каждого `geom` есть своя статистика, а у каждой статистики - свой типичный график.\n\nИменно поэтому мы можем создавать графические слои, не беспокоясь о том, что нам могут потребоваться какие-то статистические расчеты.\n\nОднако иногда мы можем задавать статистику принудительно, вместо установок по умолчанию. Например, если мы хотим вместо количества (абсолютные значения) указать относительные частоты (проценты):\n\n```{r}\nggplot(data = diamonds) +\n  geom_bar(mapping = aes(x = cut, y = stat(prop), group = 1))\n```\n\n{{< iconify arcticons huawei-tips size=42px >}}**Дополнительный материал**:  в библиотеку ggplot2 включено более 20 статистических функций, которые мы можем использовать в своих визуализациях [https://ggplot2.tidyverse.org/reference/#stats](https://ggplot2.tidyverse.org/reference/#stats)\n\n## Дополнительные настройки цвета\n\nСо столбчатыми диаграммами связана еще одна «магическая история»: мы можем применять настройки цвета как в отношении контура (обычный аргумент `color`), так и заполнять цветом столбцы (аргумент `fill`):\n\n```{r}\n# Посмотрите на эти два графика и найдите отличия\nggplot(data = diamonds) +\n  geom_bar(mapping = aes(x = cut, colour = cut))\nggplot(data = diamonds) +\n  geom_bar(mapping = aes(x = cut, fill = cut))\n```\n\nЧто произойдет, если мы аргументу `fill` присвоим другую переменную, например чистоту (`clarity`): столбцы автоматически разделяются по группам, и каждый столбец представляет собой комбинацию огранки и чистоты.\n\n```{r}\nggplot(data = diamonds) +\n  geom_bar(mapping = aes(x = cut, fill = clarity))\n```\n\nЕсли мы не желаем, чтобы у нас получилась комбинированная диаграмма, мы должны использовать аргумент, задающий позицию элементов - `position`: `identity`, `dodge` или `fill`:\n\n- position = \"identity\" - поставит каждый объект на ту позицию, которую он занимает в контексте. С барчартами применять не очень актуально, поскольку получается пересечение категорий, что хорошо заметно, если вместо закрашивания использовать прозрачность или вообще убрать цвет, а вот для точечных диаграмм это позиция по умолчанию:\n\n```{r}\nggplot(data = diamonds, mapping = aes(x = cut, fill = clarity)) +\n  geom_bar(alpha = 1/5, position = \"identity\")\nggplot(data = diamonds, mapping = aes(x = cut, colour = clarity)) +\n  geom_bar(fill = NA, position = \"identity\")\n```\n\n- position = \"fill\" работает по типу накопленной диаграммы, приводит все столбцы к единой высоте, что позволяет более наглядно представить распределение ответов и сравнивать группы.\n\n```{r}\nggplot(data = diamonds) +\n  geom_bar(mapping = aes(x = cut, fill = clarity), position = \"fill\")\n```\n\n - position = \"dodge\" помещает пересекающиеся объекты рядом друг с другом, что позволяет сравнить индивидуальные значения по каждой категории.\n\n```{r}\nggplot(data = diamonds) +\n  geom_bar(mapping = aes(x = cut, fill = clarity), position = \"dodge\")\n```\n\nЕсть еще один тип уточнения позиции, который не очень подходит для барчартов, но может быть полезен для диаграмм рассеяния.\n\nПомните наш первый график? Отметили ли вы, что на графике всего 126 точек (может быть вы и не считали, но просто засомневались, что на графике отображены не все данные)? А ведь в наборе 234 наблюдения.\n\n::: {style=\"max-width:600px; margin-left: 0; margin-right: 0;\"}\n![](https://d33wubrfki0l68.cloudfront.net/91aebc6de4de928abc810433b752274ba6a46d58/acd97/visualize_files/figure-html/unnamed-chunk-41-1.png)\n:::\n\nЗначения переменных `hwy` и `displ` приводятся в округленном виде, что приводит к тому, что на графике точки располагаются одна над другой, происходит их пересечение. Соответственно, нам не очень хорошо видно скопление точек, это может быть очень критичный момент для анализа.\n\nЧтобы избежать такой ситуации, пожно применить аргумент мэппинга `position = \"jitter\"`, который добавляет немного статистического шума к каждой точке и, таким образом, раздвигает их немного в стороны.\n\n```{r}\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy), position = \"jitter\")\n```\n\nЧтобы узнать больше, просим запустить справку: ?position_dodge, ?position_fill, ?position_identity, ?position_jitter, ?position_stack.\n\n**Упражнения:** 1. Какие проблемы у этого графика? Как сделать его лучше?\n\n`ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +   geom_point()`\n\n2.  Создайте столбчатый график, покзывающий взаимосвязь между цветом и огранкой бриллиантов. Сделайте настройки так, чтобы столбцы были одинаковой длины.\n\n## Поворот системы координат\n\nПоследний вопрос, который мы рассмотрим, связан с поворотом системы координат, которое иногда применяется для того, чтобы сделать график более читаемым.\n\n`coord_flip()` меняет местами оси x и y. Применяется, например, для транспонирования боксплота, если метки переменных очень длинные и не входят по ширине:\n\n```{r}\nggplot(data = mpg, mapping = aes(x = class, y = hwy)) +\n  geom_boxplot()#обычный боксплот\n```\n\n```{r}\nggplot(data = mpg, mapping = aes(x = class, y = hwy)) +\n  geom_boxplot() +\n  coord_flip()#повернутый боксплот\n```\n\ncoord_polar() превращает столбчатую диаграмму в круговую, в итоге получается график - нечто среднее между столбчатым графиком и графиком \"петушиный гребень\".\n\n```{r}\nbar <- ggplot(data = diamonds) +\n  geom_bar(\n    mapping = aes(x = cut, fill = cut),\n    show.legend = FALSE,\n    width = 1\n  ) +\n  theme(aspect.ratio = 1) +\n  labs(x = NULL, y = NULL)\n\nbar + coord_flip()#линейчатая диаграмма (перевернутый барчарт)\n```\n\n```{r}\nbar + coord_polar()#диаграмма с круговыми координатами\n```\n\n## Самостоятельная работа\n\n1. Какой `geom` нужно использовать, чтобы нарисовать линейный график? А боксплот? А гистограмму? А диаграмму с областями (area chart)? Создайте такие графики для переменных набора mpg, mtcars или diamonds.\n\nИспользуйте памятку:\n![](https://www.dartistics.com/images/ggplot2_geoms.png)\n\n2.  Постройте вот такие графики:\n\n::: {style=\"max-width:500px; margin-left: 0; margin-right: 0;\"}\n![](https://d33wubrfki0l68.cloudfront.net/9ad169a7a48c6f1493bfb9eb1d89118975304cc2/df994/visualize_files/figure-html/unnamed-chunk-28-3.png)\n:::\n\n::: {style=\"max-width:500px; margin-left: 0; margin-right: 0;\"}\n![](https://d33wubrfki0l68.cloudfront.net/9a3c63edfc170c576ec5d34faa90df2dc2a43443/7f9e5/visualize_files/figure-html/unnamed-chunk-28-5.png)\n:::\n\n3.  Постройте перевернутый барчарт по одной из категориальных переменных набора данных `diamonds`.\n\n4.  Примените опцию `coord_polar()` к созданному графику.\n5. Все результаты оформить в виде документа RMarkdown и опубликовать на RPubs. Результаты прикрепить в виде ссылки. \n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["include/webex.css"],"include-after-body":["include/webex.js"],"embed-resources":false,"output-file":"Base_ggplot2.html"},"language":{"toc-title-document":"Содержание","toc-title-website":"Содержание","related-formats-title":"Другие форматы","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Источник","other-links-title":"Другие ссылки","code-links-title":"Ссылки на код","launch-dev-container-title":"Запустить Dev Container","launch-binder-title":"Запустить Binder","article-notebook-label":"Блокнот статьи","notebook-preview-download":"Скачать блокнот","notebook-preview-download-src":"Скачать исходный код","notebook-preview-back":"Вернуться к статье","manuscript-meca-bundle":"Архив MECA","section-title-abstract":"Аннотация","section-title-appendices":"Приложения","section-title-footnotes":"Сноски","section-title-references":"использованная литература","section-title-reuse":"Повторное использование","section-title-copyright":"Авторские права","section-title-citation":"Цитата","appendix-attribution-cite-as":"Пожалуйста, цитируйте эту работу как:","appendix-attribution-bibtex":"BibTeX","appendix-view-license":"Просмотреть Лицензию","title-block-author-single":"Автор","title-block-author-plural":"Авторы","title-block-affiliation-single":"принадлежность","title-block-affiliation-plural":"Принадлежности","title-block-published":"Дата публикации","title-block-modified":"Файл изменен","title-block-keywords":"Ключевые слова","callout-tip-title":"Совет","callout-note-title":"Уведомление","callout-warning-title":"Предупреждение","callout-important-title":"Важное уведомление","callout-caution-title":"Осторожность","code-summary":"Код","code-tools-menu-caption":"Код","code-tools-show-all-code":"Развернуть код","code-tools-hide-all-code":"Скрыть код","code-tools-view-source":"Показать код","code-tools-source-code":"Исходный код","tools-share":"Share","tools-download":"Download","code-line":"Линия","code-lines":"Линии","copy-button-tooltip":"Скопировать текст","copy-button-tooltip-success":"Скопировано","repo-action-links-edit":"Редактировать страницу","repo-action-links-source":"Показать код","repo-action-links-issue":"Сообщить о проблеме","back-to-top":"Наверх","search-no-results-text":"Поиск не дал результатов","search-matching-documents-text":"Результаты поиска","search-copy-link-title":"Скопировать ссылку","search-hide-matches-text":"Скрыть дополнительные результаты","search-more-match-text":"дополнительный результат в этом документе","search-more-matches-text":"дополнительных результата(-ов) в этом документе","search-clear-button-title":"Очистить","search-text-placeholder":"","search-detached-cancel-button-title":"Отменить","search-submit-button-title":"Найти","search-label":"Поиск","toggle-section":"Переключить раздел","toggle-sidebar":"Переключить боковую панель навигации","toggle-dark-mode":"Переключить темный режим","toggle-reader-mode":"Переключить режим чтения","toggle-navigation":"Переключить навигацию","crossref-fig-title":"Рисунок","crossref-tbl-title":"Таблица","crossref-lst-title":"Список","crossref-thm-title":"Теорема","crossref-lem-title":"Лемма","crossref-cor-title":"Следствие","crossref-prp-title":"Утверждение","crossref-cnj-title":"Гипотеза","crossref-def-title":"Определение","crossref-exm-title":"Пример","crossref-exr-title":"Упражнение","crossref-ch-prefix":"Глава","crossref-apx-prefix":"Приложение","crossref-sec-prefix":"Глава","crossref-eq-prefix":"Уравнение","crossref-lof-title":"Список Иллюстраций","crossref-lot-title":"Список Таблиц","crossref-lol-title":"Список Каталогов","environment-proof-title":"Доказательство","environment-remark-title":"Примечание","environment-solution-title":"Решение","listing-page-order-by":"Сортировать по","listing-page-order-by-default":"предварительно выбранный","listing-page-order-by-date-asc":"Самый старый","listing-page-order-by-date-desc":"Новейшие","listing-page-order-by-number-desc":"нисходящий","listing-page-order-by-number-asc":"по возрастанию","listing-page-field-date":"Дата","listing-page-field-title":"Заголовок","listing-page-field-description":"Описание","listing-page-field-author":"Автор","listing-page-field-filename":"Имя файла","listing-page-field-filemodified":"Файл изменен","listing-page-field-subtitle":"Подзаголовок","listing-page-field-readingtime":"Время чтения","listing-page-field-wordcount":"Подсчет слов","listing-page-field-categories":"Категории","listing-page-minutes-compact":"{0} минут","listing-page-category-all":"Все","listing-page-no-matches":"Нет подходящих элементов","listing-page-words":"{0} слов","listing-page-filter":"Фильтр","draft":"Черновик"},"metadata":{"lang":"ru","fig-responsive":true,"quarto-version":"1.5.57","comments":{"hypothesis":true},"bibliography":["references.bib"],"editor":"visual","theme":"Pulse","title":"Основы визуализации в ggplot2"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}
{"title":"Типы и структуры данных","markdown":{"yaml":{"title":"Типы и структуры данных"},"headingText":"Типы данных в R","containsRefs":false,"markdown":"\n\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = FALSE)\nlibrary(webexercises)\n```\n\nТип данных (встречается также термин «вид данных») — фундаментальное понятие теории программирования.\n\nТип данных определяет множество значений, набор операций, которые можно применять к таким значениям и способ реализации хранения значений и выполнения операций. Любые данные, которыми оперируют программы, относятся к определённым типам.\n\nR может хранить и обрабатывать различные виды информации и типы данных:\n\n![](https://static.javatpoint.com/tutorial/r/images/r-programming-data-types.png)\n\n-   **Логический (logical)** – TRUE, FALSE – ИСТИНА, ЛОЖЬ.\n\n```{r dt1, echo=TRUE}\n2>3\n```\n\nМы можем присваивать логические значения в качестве значений переменных, используя полный или краткий вариант:\n\n```{r, echo=TRUE, eval=F}\na<-TRUE\nb<-FALSE\n#Или\na<-T\nb<-F\n```\n\nС логическим типом могут происходить интересные вещи, в частности, этот тип может рассматриваться как число. В таком случае TRUE принимается за 1, а FALSE как 0.\n\nИ если мы будем производить манипуляции над логическими значениями, в результате у нас будут числа!\n\nНапример:\n\n```{r dt1_3, echo=TRUE}\nTRUE + TRUE  # TRUE считается как 1\n```\n\n```{r dt1_4, echo=TRUE}\nFALSE * 7 # FALSE принимается за 0\n```\n\nИли, вот еще интересный пример:\n\n```{r dt1_5, echo=TRUE}\n(2 < 3) + (1 == 2)  # Что тут вообще происходит?\n```\n\nПочему получился именно такой результат?\n\n2 \\< 3 - TRUE, то есть 1\n\n1 == 2 - FALSE, то есть 0\n\nTRUE+FALSE=1+0=1\n\n-   **Числовой (numeric)** – целые и дробные, положительные и отрицательные.\n\n```{r dt3, echo=TRUE}\nis.numeric(-5.6)\na <- -11\nb <- 13.37\nc <- 1/137\nclass(a)\nclass(b)\nclass(c)\n```\n\nС числовыми переменными мы можем совершать различные математические операции:\n\n```{r dt3_1, echo=TRUE}\na <- -11\nb <- 13.37\nc <- 1/137\nprint(a+b*c)\nprint(a^2+sqrt(b)-c/5)\n```\n\n-   **Целое, целочисленное (integer)** – целые числа, положительные и отрицательные\n\n```{r dt4, echo=TRUE}\nx <- pi * 23.5\nclass(x)\n#Проверим, является ли x целым числом\nis.integer(x)\n#Создадим переменную y\ny<-25L #при вводе, для того, чтобы R понял, что число именно целое, добавляется буква L\n#Проверим, является ли y целым числом\nis.integer(y)\n#Проверим, является ли y числовой переменной\nis.numeric(y)\n```\n\n-   **Комплексные (complex)** – это уже абстрактная математика (числа состоящие из действительной (реальной) и мнимой части), например, 3+2i. Нам они вряд ли пригодятся, но на всякий случай запомним.\n\n```{r dt5, echo=TRUE}\nz <- 1:2 + 1i*(8:9)\nstr(z)\n```\n\n-   **Текстовые, строковые (character)** – «Привет, мир!», «а», «4В»\n\n```{r dt6, echo=TRUE}\ncolor<-\"Red\"\nclass(color)\nis.character(color)\n```\n\nВозможные варианты написания:\n\n```{r dt6_1, echo=TRUE}\nd <- \"Hello\"         # С помощью двойных кавычек \ne <- 'how are you?'  # С помощью одинарных кавычек\nd\ne\n```\n\nОднако, нельзя использовать и те, и другие сразу, будет ошибка:\n\n```{r dt6_2, echo=TRUE, eval=FALSE}\nf <- \"Так работать не будет' \n```\n\nИногда вместо текста нет ничего, но это все равно будет строковая переменная (пустая строка):\n\n```{r dt6_3, echo=TRUE}\nh <- \"\"              # Это пустая строка!\n```\n\nС числовыми переменными мы можем совершать различные операции, что же делать со строковыми переменными? К ним тоже можно применять разные функции, и их довольно много. Вот некоторые:\n\nПосчитаем количество символов в строке:\n\n```{r dt6_4, echo=TRUE}\ng<-\"Как упоительны в России вечера!\"\nnchar(g)\n```\n\nЕсли нам нужен какой-то определенный фрагмент текста, мы можем его \"вытащить\" оттуда:\n\n```{r dt6_5, echo=TRUE}\ng<-\"Как упоительны в России вечера!\"\nsubstr(g, 4, 25) \n```\n\nДовольно часто при анализе текстовых данных их нужно разделить на отдельные кусочки:\n\n```{r dt6_6, echo=TRUE}\ng<-\"Как упоительны в России вечера!\"\nstrsplit(g, \" \")   \n```\n\nВ данном случае мы использовали пробел в качестве разделителя.\n\n-   **Факторные переменные (factor)** – могут быть строковыми и числовыми, задают уровни или как правило являются номинальными переменными: пол, семейный статус, цвет волос и т. д., служат категоризации\n\n```{r dt7, echo=TRUE}\nx <- c(\"single\",\"married\",\"married\",\"single\")\nclass(x)\n```\n\n`factor ()` - функция, которая создает факторные переменные. Аргумент `levels` используется для обозначения уровней (порядка, если он нужен).\n\n```{r dt8, echo=TRUE}\nx <- factor(c(\"single\", \"married\", \"married\", \"single\"), levels = c(\"single\", \"married\", \"divorced\"))\nclass(x)\nstr(x)# функция str() дает больше информации о переменной, не только какого она типа, но сколько элементов содержит, какие в ней значения, уровни и т. д.\n```\n\n`as.factor()` - данная функция превращает в факторный тип переменные другого типа, даже если они числовые.\n\n```{r dt9, echo=TRUE}\ncolors<-c(\"red\", \"yellow\", \"green\")\ncolors<-as.factor(colors)\nstr(colors)\n```\n\nПример порядковой переменной с уровнями:\n\n```{r dt10, echo=TRUE}\nstatus <- c(\"Poor\", \"Middle-class\", \"Rich\")\nstatus <- factor(status, ordered=TRUE) # ordered=TRUE - делает переменную не просто категориальной, но и порядковой\nstr(status)\n```\n\nПолучилось не совсем то, что нам нужно, так как программа автоматически отсортировывает по алфавиту. Чтобы поменять порядок, нужно задать уровни \"принудительно\":\n\n```{r dt11, echo=TRUE}\nstatus <- c(\"Poor\", \"Middle-class\", \"Rich\")\nstatus <- factor(status, order=TRUE,levels=c(\"Poor\", \"Middle-class\", \"Rich\"))\nstr(status)\n```\n\n### Вопросы для самопроверки\n\n**1. К какому типу переменных относится число -3,5?**\n\n```{r}\n    type_data <- c(\n        answer =\"numeric\",\n       \"character\",\n       \"complex\", \n       \"integer\"\n    )\n```\n\n`r longmcq(type_data)`\n\n**2. Какой результат получится, если попытаться превратить в число строковую переменную?**\n\n```{r}\n    string_to_number <- c(\n        answer =\"NA\",\n       \"TRUE\",\n       \"NAs introduced by coercion\"\n    )\n```\n\n`r longmcq(string_to_number)`\n\n**3. Какая функция используется для проверки принадлежности переменной к факторному типу?**\n\n```{r}\n    check_factor <- c(\n        answer =\"is.factor()\",\n       \"as.factor()\",\n       \"factor()\"\n    )\n```\n\n`r longmcq(check_factor)`\n\n**4. Могут ли логические переменные быть представлены в числовом виде?**\n\n```{r}\n    logical_numbers <- c(\n        answer =\"Да()\",\n       \"Нет\",\n       \"Затрудняюсь ответить\"\n    )\n```\n\n`r longmcq(logical_numbers)`\n\n### Самостоятельная работа\n\n[Самостоятельная работа № 1](https://socio-asu.shinyapps.io/Assignment1/){.btn .btn-outline-primary .btn role=\"button\"}\n\n## Структуры данных\n\n**Структура данных** — это способ организации информации для более эффективного использования. В программировании структурой обычно называют набор данных, связанных определённым образом.\n\nОсновные структуры данных в R это векторы, матрицы, массивы, списки и таблицы данных.\n\nРассмотрим их подробнее.\n\n![](images/DataStructures/1.png)\n\n### Векторы\n\n-   **Вектор** – одномерный массив проиндексированных (пронумерованных) элементов, набор однотипных элементов (либо числа, либо буквы) без их сочетания. Векторы могут быть такими же, как и типы данных - числовыми, строковыми, логическими и пр.\n\nВот пример того, как можно создать числовой вектор, содержащий числа от 1 до 10:\n\n```{r vec1, echo=TRUE}\nx<-1:10\nx\n```\n\nА вот так - вектор с текстовыми элементами:\n\n```{r vec2, echo=TRUE}\ny<-c(\"Красный\", \"Синий\", \"Желтый\")\ny\n```\n\nЗаметьте, чтобы создать вектор с наименованиями цветов, мы использовали функцию `c()`, в которой `c` является производной от`combine`. В этом есть смысл, поскольку мы соединяем, как бы \"комбинируем\", несколько числовых или текстовых объектов в один ряд.\n\n::: callout-important\n## Про имена (важно!)\n\nКак назвать вектор (да и другие структуры данных) правильно? Есть несколько простых правил. Имя может содержать:\n\n-   буквы\n-   числа\n-   точку или символ «подчеркивания\" (\\_)\n\nи обязательно должно начинаться с буквы или точки, но за точкой нельзя поставить цифру.\n\nТак, например, имя \".2b\" не является валидным, а \".b2\" - вполне годится для именования.\n\nНельзя также использовать в именах **зарезервированные слова**,такие как `if,else, repeat, while, function, for, in, next, break, TRUE, FALSE, NULL, Inf, NaN, NA, NA_integer_, NA_real_, NA_complex_, NA_character_` некоторых других, которые являются базовыми конструкциями языка и используются в качестве аргументов при вызове функций.\n:::\n\nНапример, если мы попробуем создать вот такой вектор, то программа выдаст ошибку:\n\n```{r, echo=TRUE}\n#| error: true\nbreak<-1:5\n```\n\nДлину числового вектора можно определить с помощью функции `length()`:\n\n```{r vec3, echo=TRUE}\nx<-1:3\nlength(x)\n```\n\nФункция `class()` помогает определить, какой тип данных хранится в векторе. Напомним, что вектор содержит данные одного типа.\n\n```{r vec4, echo=TRUE}\nx<-c(1:3)\nclass(x)\n```\n\nЕще примеры создания логических и текстовых векторов:\n\n```{r vec5, echo=TRUE}\ny <- c(TRUE, TRUE, FALSE, TRUE)\nz <- c(\"to\", \"be\", \"or\", \"not\", \"to\", \"be\") \nclass(y)\nlength(y)\nclass(z)\nlength(z)\n```\n\n::: callout-important\nЕсли мы попытаемся соединить два вектора - числовой и строковый - то цифры \"превратятся\" в буквы, поскольку R автоматически переведет все элементы к наиболее подходящему общему типу данных. Поскольку слова в цифры превратить нельзя, то таким общим типом будет строковый.\n:::\n\n```{r vec6, echo=TRUE}\nx<-c(1:10)\ny<-c(\"Красный\", \"Синий\", \"Желтый\")\nz<-c(x,y)\nx\ny\nz\n```\n\nТо, что произошло в коде выше, называется *конверсией типов*. Такая конверсия случается тогда, когда элементы вектора разные. Запомниим, что вектор всегда хранит данные только одного типа!\n\n**Задание**. Попробуйте создать вектор, сочетающий числовые, строковые и логические значения:\n\nА что будет, если мы соединим вместе логические и числовые?\n\n```{r vec8, echo=TRUE}\nx<-c(TRUE, 5, FALSE, 6)\nx\n```\n\nМы можем также создавать \"пустые\" вектора, обозначая только тип данных, и сколько элементов в них содержится.\n\nНапример:\n\n```{r vec9, echo=TRUE}\nempty <- numeric(10)   # Создаем пустой числовой вектор с 10 элементами\nprint(empty)\n```\n\nЗаметьте, что даже если мы не просили R внести какие-то значения, в числовом векторе всем элементам автоматически были присвоены нули - значение *по умолчанию*.\n\nВот таким образом можно создать пустые вектора других типов:\n\n```{r, echo=TRUE}\nempty_int <- integer(45)   # числовой вектор с 45 элементами\nempty_cha <- character(2)  # строковый вектор с 2 элементами\nempty_log <- logical(1000)    # логический вектор с 1000 элементами\n```\n\nPfПопробуйте в RStudio создать эти вектора и посмотреть их. Обратите внимание, какие значения по умолчанию присваиваются в логическом и строковом векторах!\n\n#### Адресация и изменение элементов вектора\n\nПосле того, как вектор создан, как мы можем посмотреть или изменить его элементы. Это сделать достаточно просто:\n\nПоменять элемент в векторе:\n\n```{r vec10, echo=TRUE}\na <- c(1, 2, 3)  # Создадим числовой вектор с 3 элементами\na[2] <- 4        # Изменим значение второго элемента на 4\na                # Посмотрим, что получилось\n```\n\nКак вы уже догадались, чтобы обратиться к какому-то элементу вектора, нужно набрать его порядковый номер в квадратных скобках \\[ порядковыйномер \\]:\n\n```{r vec11, echo=TRUE}\na <- c(1, 2, 3)  # Создадим числовой вектор с 3 элементами\na[3]             # Попросим R вывести третий элемент\n```\n\nКак вы думаете, что будет если запустить следующий код? Каким будет результат?\n\n```{r, echo=TRUE, eval=FALSE}\nvec <- c(4, 5, 6)\nvec[3] == 6\n```\n\nДогадались? Попробуйте теперь запустить этот код и проверить, правы вы или нет:\n\n```{r vec12, echo=TRUE}\n\n```\n\n#### Операции над векторами\n\nС векторами можно производить большое количество действий, которые позволяют те типы данных, которые в них содержатся.\n\nПроще всего совершать арифметические действия:\n\n```{r vec13, echo=TRUE}\na <- 3   # Создаем единичный числовой объект\na + 4  # Прибавляем к нему константу\n```\n\nМы можем прибавить число не только к другому числу, но и ко всему вектору:\n\n```{r vec14, echo=TRUE}\na <- c(1, 2, 3)   # Создаем числовой вектор\na + 4   # Прибавляем к нему константу\n```\n\nТакой тип \"поведения\" программы называется *поэлементным*. То есть операция производится над каждым элементом по отдельности.\n\nЕще примеры:\n\n```{r vec15, echo=TRUE}\na <- c(1, 2, 3)\na - 3 \na * 1.5\na ^ 2\na == 2\n```\n\nВ последнем случае мы сравнивали каждый элемент со значением два и в результате получили новый вектор, состоящий из логических значений.\n\nВ R имеется много различных функций для трансформации, мы с ними будем активно работать на следующих занятиях. Но самая простая функциюя - `sum()`, которая просто складывает все элементы вектора вместе:\n\n```{r vec16, echo=TRUE}\na <- c(1, 2, 3)\nsum(a)\n```\n\nНекоторые операции можно производить над векторами, если у них одинаковая длина:\n\n```{r vec18, echo=TRUE}\na <- c(1, 2, 3)\nb <- c(1, 0, 1)\na + b\nb * a\na ^ b\n\n```\n\nМы можем даже сравнить два вектора и сохранить результат в отдельном логическом векторе\n\n```{r vec19, echo=TRUE}\na <- c(1, 2, 3)\nb <- c(1, 0, 1)\nz <- a > b   # сравниваем a и b, поэлементно, результат сохраняем в векторе z\nz\nz == TRUE\nz == FALSE\n!z #выдает противоположное значение\n\n```\n\nА что можно делать со строковыми векторами?\n\nДавайте создадим пару векторов и попробуем с ними совершить какие-нибудь действия, например, сравним их попарно:\n\n```{r vec20, echo=TRUE}\na <- c(\"собака\", \"молоко\", \"квартира\", \"чай\", \"морозы\", \"душа\")\nb <- c(\"собака\", \"мыло\", \"сахар\", \"чай\", \"малина\", \"душа\")\na==b\n\n```\n\nЧтобы найти какой-то текстовый элемент и его место в векторе, можно использовать функцию `grep()`:\n\n```{r vec21, echo=TRUE}\na <- c(\"собака\", \"молоко\", \"квартира\", \"чай\", \"морозы\", \"квартира\", \"душа\")\ngrep(\"квартира\", a)\n\n```\n\nРезультат показывает, что слово \"квартира\" встречается два раза, это третий и шестой элементы. Что будет, если поищем то, чего нет?\n\n```{r vec22, echo=TRUE}\na <- c(\"собака\", \"молоко\", \"квартира\", \"чай\", \"морозы\", \"квартира\", \"душа\")\ngrep(\"редиска\", a)\n\n```\n\nЕсли вектора разного типа, то иногда с ними можно что-то сделать, иногда нет, зависит от типа данных:\n\n```{r vec23, echo=TRUE, eval=FALSE}\na <- c(1, 2, 3)\nb <- c(\"one\", \"two\", \"three\")\nc <- c(TRUE, TRUE, FALSE)\na+b\n```\n\nНичего не получилось, потому что нельзя к словам прибавлять числа. А вот если сложить вектора a и c, все получится:\n\n```{r vec23_1, echo=TRUE}\na <- c(1, 2, 3)\nb <- c(\"one\", \"two\", \"three\")\nc <- c(TRUE, TRUE, FALSE)\na+c\n```\n\n#### Некторые полезные функции для работы с векторами\n\n-   Создать вектор случайных чисел в определенном диапазоне:\n\n```{r vec24, echo=TRUE}\nx <- runif(10, min = -5, max = 5)\nx\n```\n\n-   Создать вектор с повторяющимися значениями с помощью функции `rep()` – повторить (что, сколько раз):\n\n```{r vec25, echo=TRUE}\nb<- rep(c(1,2,3),4)\nb\n```\n\n-   Создать вектор из повторяющихся значений определенной длины с помощью функции `rep()` – повторить (что, до каких пор, какой длины):\n\n```{r vec26, echo=TRUE}\nc<- rep(c(4,5,6), length.out=10)\nc\n```\n\n-   Создать вектор через последовательность определенных значений с помощью функции `seq()` – задать последовательность (от, до, с каким шагом)\n\n```{r vec27, echo=TRUE}\nseq <- seq(from=2,to=15,by=0.5)\nseq\n```\n\n-   Проверить, является ли какой-то объект вектором с помощью функции `is.vector()` :\n\n```{r vec28, echo=TRUE}\nseq <- seq(from=2,to=15,by=0.5)\nis.vector(seq)\n```\n\n-   Проверить, удовлетворяет ли хотя бы один элемент вектора какому-либо условию с помощью функции `any()`:\n\n```{r vec29, echo=TRUE}\nvec <- as.integer(c(34,23,53,42,16,42,64,32,76))\nany(vec,vec>50)\n```\n\n-   Проверить, удовлетворяют ли все элементы вектора какому-либо условию с помощью функции `all()`:\n\n```{r vec30, echo=TRUE}\nvec <- as.integer(c(34,23,53,42,16,42,64,32,76))\nall(vec,vec>10)\n```\n\n-   Применить какую-либо функцию преобразования ко всем элементам вектора с помощью функции `sapply()`:\n\n```{r vec31, echo=TRUE}\nvec <- as.integer(c(34,23,53,42,16,42,64,32,76))\nvec3<-sapply(vec, sqrt)\nvec3\n```\n\nВ принципе, можно это сделать и проще:\n\n```{r vec32, echo=TRUE}\nvec <- as.integer(c(34,23,53,42,16,42,64,32,76))\nsqrt(vec)\n```\n\nНо иногда, когда у нас не вектор, а более сложный объект, функция `sapply()` и ее родные сестры `apply()` и `lapply()`часто очень выручают. Подробнее эти функции будут рассмотрены на следующих занятиях.\n\n### Матрицы\n\n-   **Матрица** – двумерная совокупность числовых, логических или текстовых величин. Чтобы создать матрицу, нужно воспользоваться функцией matrix(). Можно думать о матрице как о решетке каких-то числовых величин.\n\nПростой пример:\n\n```{r mat1, echo=TRUE}\ndata <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA <- matrix(data, ncol=3, nrow=3)\nA\n\n```\n\nМы создали матрицу с тремя строками и тремя колонками на основе данных, изначально хранящихся в виде числового вектора.\n\n::: callout-important\nR заполняет матрицу сверху вниз, колонку за колонкой, двигаясь справа налево.\n:::\n\nЕсли мы хотим это изменить, нужно поменять параметр `byrow`:\n\n```{r mat, echo=TRUE}\ndata <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA <- matrix(data, ncol=3, nrow=3, byrow = T)\nA\n\n```\n\n#### Полезные функции и операции над матрицами\n\n-   Как обратиться к одному из элементов матрицы? В случае с вектором мы задавали один элемент в квадратных скобках, а что теперь? Матрица - двумерный объект, поэтому мы должны теперь в квадратных скобках задать две координаты - номер строки (первое число) и номер колонки (второе число) - через запятую:\n\n```{r mat2, echo=TRUE}\ndata <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA <- matrix(data, ncol=3, nrow=3, byrow = T)\nA\nA[1,1] # Первый элемент первой строки\nA[2,3] # Третий элемент второй строки\nA[1,]  # Первая строка полностью\nA[,3]  # Третий столбец полностью\n```\n\nЧтобы получить диагональные элементы, есть специальная функция - `diag()`\n\n```{r mat3, echo=TRUE}\ndata <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA <- matrix(data, ncol=3, nrow=3, byrow = T)\ndiag(A)\n```\n\nЧтобы узнать размерность матрицы (количество строк и столбцов) - можно использовать функцию `dim()`:\n\n```{r mat4, echo=TRUE}\ndata <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA <- matrix(data, ncol=3, nrow=3, byrow = T)\ndim(A)\n```\n\nВ результате применения функции мы получаем числовой вектор, первое значение в котором обозначает количество строк, второе - столбцов.\n\n**Задание**: воспроизведите еще раз матрицу A и напишите код, позволяющий получить произведение первого элемента второй строки и третьего элемента третьей строки.\n\nС матрицами, как и с векторами, можно совершать разные математические операции - сложение, умножение, вычитание и т.д.:\n\n-   Например, прибавить единицу к каждому элементу матрицы:\n\n```{r mat6, echo=TRUE}\ndata <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA <- matrix(data, ncol=3, nrow=3, byrow = T)\nA\nA+1   \n```\n\n-   Умножить каждый элемент на 2:\n\n```{r mat7, echo=TRUE}\ndata <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA <- matrix(data, ncol=3, nrow=3, byrow = T)\nA\nA*2\n```\n\n-   Возвести в квадрат:\n\n```{r mat8, echo=TRUE}\ndata <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA <- matrix(data, ncol=3, nrow=3, byrow = T)\nA\nA^2\n```\n\n-   Довольно часто возникает необходимость транспонирования, когда строки становятся столбцами и наоборот:\n\n```{r mat9, echo=TRUE}\ndata <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA <- matrix(data, ncol=3, nrow=3, byrow = T)\nA\nt(A)\n```\n\n-   Найдти след матрицы\n\n*След матрицы - это сумма диагональных элементов*:\n\n```{r mat10, echo=TRUE}\ndata <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA <- matrix(data, ncol=3, nrow=3, byrow = T)\nsum(diag(A))\n```\n\n-   Сложить две матрицы\n\n```{r mat11, echo=TRUE}\ndata <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA <- matrix(data, ncol=3, nrow=3, byrow = T)\nB <- matrix(1, 3, 3)\nA + B\n```\n\nЗаметьте, как мы это сделали: мы создали матрицу В одной строкой (матрица 3\\*3, состоящая из одних единиц).\n\n-   Перемножить элементы двух матриц:\n\n```{r mat12, echo=TRUE}\ndata <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA <- matrix(data, ncol=3, nrow=3, byrow = T)\nB <- matrix(2, 3, 3)\nA * B\n```\n\n-   Осуществить матричное умножение:\n\n```{r mat13, echo=TRUE}\ndata <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA <- matrix(data, ncol=3, nrow=3, byrow = T)\nB <- matrix(2, 3, 3)\nA %*%  B\n```\n\nВ чем разница между двумя умножениями? В первом случае элементы поэлементно умножаются друг на друга, во втором - происходит умножение матриц по законам линейной алгебры.\n\n**Задание**. Воспроизведите матрицу А из примера выше и осуществите матричное умножение между матрицей А и транспонированной матрицей А.\n\n### Массивы\n\n-   **Массив (array)** – объект в R, в котором хранится данные, содержащие более двух измерений. Например, если мы создадим массив с параметрами (2, 3, 4), у нас получится 4 прямоугольные матрицы размером 2 на 3. В массивах хранятся данные только одного типа.\n\nДля того, чтобы создать массив, есть специальная функция `array()`. Она принимает на входе вектора и использует значения параметра `dim`, чтобы создать массив.\n\nПример:\n\n```{r arr1, echo=TRUE}\nvector1 <- c(5,9,3)\nvector2 <- c(10,11,12,13,14,15)\narr1 <- array(c(vector1,vector2),dim = c(3,3,2))\narr1\n```\n\nМы можем присвоить имена строкам, колонкам и матрицам массива с помощью параметра `dimnames`:\n\n```{r arr2, echo=TRUE}\nvector1 <- c(5,9,3)\nvector2 <- c(10,11,12,13,14,15)\ncolumn.names <- c(\"COL1\",\"COL2\",\"COL3\")\nrow.names <- c(\"ROW1\",\"ROW2\",\"ROW3\")\nmatrix.names <- c(\"Matrix1\",\"Matrix2\")\nresult <- array(c(vector1,vector2),dim = c(3,3,2),dimnames = list(row.names,column.names,\n   matrix.names))\nresult\n```\n\n#### Манипуляции с элементами массива\n\nТак как массив - это по сути совокупность нескольких матриц, то и операции мы с массивами мы можем производить практически такие же.\n\n-   Обращение к элементам\n\nОбращение к элементам массива практически такое же, как и в случае с матрицами, чуть сложнее, поскольку добавляются новые измерения, но общая логика остается та же - мы в квадратных скобках указываем координаты элемента, которые нам нужны:\n\n```{r arr3, echo=TRUE}\nvector1 <- c(5,9,3)\nvector2 <- c(10,11,12,13,14,15)\ncolumn.names <- c(\"COL1\",\"COL2\",\"COL3\")\nrow.names <- c(\"ROW1\",\"ROW2\",\"ROW3\")\nmatrix.names <- c(\"Matrix1\",\"Matrix2\")\nresult <- array(c(vector1,vector2),dim = c(3,3,2),dimnames = list(row.names,column.names,\n   matrix.names))\nresult[3,,2] # Третья строка второй матрицы\nresult[1,3,1] # Третий элемент первой строки первой матрицы\nresult[,,2] #Вся вторая матрица\n```\n\n-   Создание матрицы на основе массива:\n\n```{r arr4, echo=TRUE}\nvector1 <- c(5,9,3)\nvector2 <- c(10,11,12,13,14,15)\ncolumn.names <- c(\"COL1\",\"COL2\",\"COL3\")\nrow.names <- c(\"ROW1\",\"ROW2\",\"ROW3\")\nmatrix.names <- c(\"Matrix1\",\"Matrix2\")\narray1 <- array(c(vector1,vector2),dim = c(3,3,2),dimnames = list(row.names,column.names,\n   matrix.names))\nmatrix1 <- array1[,,1]\nmatrix2 <- array1[,,2]\nmatrix1\nmatrix2\n```\n\n-   Арифметические действия с элементами:\n\n```{r arr5, echo=TRUE}\nvector1 <- c(5,9,3)\nvector2 <- c(10,11,12,13,14,15)\ncolumn.names <- c(\"COL1\",\"COL2\",\"COL3\")\nrow.names <- c(\"ROW1\",\"ROW2\",\"ROW3\")\nmatrix.names <- c(\"Matrix1\",\"Matrix2\")\narray1 <- array(c(vector1,vector2),dim = c(3,3,2),dimnames = list(row.names,column.names,\n   matrix.names))\narray1[1,2,1]+array1[3,2,2]\n```\n\n### Списки (lists)\n\nСписок(list) - сложный объект, в котором могут храниться данные разных типов и структуры, включая вектора, матрицы и т.д.\n\nПример:\n\n```{r list1, echo=TRUE}\nA <- list(\"Red\", \"Green\", c(21,32,11), matrix(c(1:9), nrow=3, ncol=3), TRUE, 51.23, 119.1)\nA\n```\n\nСписки могут даже содержать внутри другие списки!\n\n```{r list2, echo=TRUE}\nA <- list(\"Red\", \"Green\", c(21,32,11), matrix(c(1:9), nrow=3, ncol=3), TRUE, 51.23, 119.1)\nA[[8]]<-list(\"One\", 256, TRUE)\nA\n```\n\nКомпоненты списка также могут иметь имена:\n\n```{r list3, echo=TRUE}\nA <- list(\"Red\", \"Green\", c(21,32,11), matrix(c(1:9), nrow=3, ncol=3), TRUE, 51.23, 119.1)\nA[[\"color\"]] <- \"yellow\"\nA\n\n```\n\nТаким образом, обратиться к компоненту списка можно по имени или по порядковому номеру элемента:\n\n```{r list4, echo=TRUE}\nA <- list(\"Red\", \"Green\", c(21,32,11), matrix(c(1:9), nrow=3, ncol=3), TRUE, 51.23, 119.1)\nA[[\"color\"]] <- \"yellow\"\nA[[\"color\"]]\nA$color #Альтернативный вариант обращения по имени\nA[[8]]\n```\n\n## Таблицы данных (data frame)\n\nДля аналитиков данных это самый важный объект, с которым приходится работать чаще всего. Большинство из тех данных, с которыми нам приходится иметь дело, хранятся именно в формате датафрейма.\n\nТаблица данных (data frame) - может включать данные разного типа, но только по столбцам. Иными словами, в таблице может быть несколько типов данных, но в каждом столбце может быть только один тип.\n\n```{r df1, echo=TRUE}\ndf<- data.frame(id = c(1:4), city = c(\"Москва\",\"Лондон\",\"Париж\",\"Нью-Йорк\"), population = c(16555000, 10840000,10960000,21045000))\ndf\n```\n\nОбращаться к элементам таблицы данных можно точно так же, как и к элементам матрицы:\n\n```{r df2, echo=TRUE}\ndf<- data.frame(id = c(1:4), city = c(\"Москва\",\"Лондон\",\"Париж\",\"Нью-Йорк\"), population = c(16555000, 10840000,10960000,21045000))\ndf[1,2]\n```\n\nЧтобы добавить новую переменную, нужно использовать знак `$`:\n\n```{r df3, echo=TRUE}\ndf<- data.frame(id = c(1:4), city = c(\"Москва\",\"Лондон\",\"Париж\",\"Нью-Йорк\"), population = c(16555000, 10840000,10960000,21045000))\ndf$country<-c(\"Россия\", \"Великобритания\", \"Франция\", \"США\")\ndf$pop2<-df$population/1000\ndf\n```\n\nС помощью этого же знака, можно вывести все значения той или иной переменной:\n\nЧтобы добавить новую переменную, нужно использовать знак `$`:\n\n```{r df4, echo=TRUE}\ndf<- data.frame(id = c(1:4), city = c(\"Москва\",\"Лондон\",\"Париж\",\"Нью-Йорк\"), population = c(16555000, 10840000,10960000,21045000))\ndf$country<-c(\"Россия\", \"Великобритания\", \"Франция\", \"США\")\ndf$pop2<-df$population/1000\ndf$city\n```\n\nЧтобы узнать размерность таблицы, можно воспользоваться уже известной нам функции `dim()`:\n\n```{r df5, echo=TRUE}\ndf<- data.frame(id = c(1:4), city = c(\"Москва\",\"Лондон\",\"Париж\",\"Нью-Йорк\"), population = c(16555000, 10840000,10960000,21045000))\ndf$country<-c(\"Россия\", \"Великобритания\", \"Франция\", \"США\")\ndf$pop2<-df$population/1000\ndim(df)\n```\n\nЕсли у нас есть список векторов, мы можем их легко трансформировать в датафрейм:\n\n```{r df6, echo=TRUE}\npeople <- list(name=c(\"Alice\", \"Bob\", \"Charlie\"), \n               grade=c(99.4, 87.6, 22.1), \n               sex=c(\"F\", \"M\", \"M\"))\nas.data.frame(people)\n```\n\nВ R содержатся много загруженных наборов данных, таких например, как `mtcars`, в котором содержатся данные по 32 маркам автомобилей:\n\n```{r df7, echo=TRUE}\nmtcars\n```\n\nСамые простые операции с таблицами данных заключаются в выводе данных, наименований строк и столбцов.\n\nКак вывести первые несколько наблюдений?\n\n```{r df8, echo=TRUE}\nhead(mtcars)\n```\n\nКак вывести последние несколько наблюдений?\n\n```{r df9, echo=TRUE}\ntail(mtcars)\n```\n\nКакие переменные содержатся в наборе mtcars?\n\n```{r df10, echo=TRUE}\nnames(mtcars)\n```\n\nНу, и напоследок, представим сводку о данных, содержащихся в этом наборе:\n\n```{r df11, echo=TRUE}\nsummary(mtcars)\n```\n\n## Самостоятельная работа\n\n[Самостоятельная работа №2](https://socio-asu.shinyapps.io/Assignment2/){.btn .btn-outline-primary .btn role=\"button\"}2\n","srcMarkdownNoYaml":"\n\n## Типы данных в R\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = FALSE)\nlibrary(webexercises)\n```\n\nТип данных (встречается также термин «вид данных») — фундаментальное понятие теории программирования.\n\nТип данных определяет множество значений, набор операций, которые можно применять к таким значениям и способ реализации хранения значений и выполнения операций. Любые данные, которыми оперируют программы, относятся к определённым типам.\n\nR может хранить и обрабатывать различные виды информации и типы данных:\n\n![](https://static.javatpoint.com/tutorial/r/images/r-programming-data-types.png)\n\n-   **Логический (logical)** – TRUE, FALSE – ИСТИНА, ЛОЖЬ.\n\n```{r dt1, echo=TRUE}\n2>3\n```\n\nМы можем присваивать логические значения в качестве значений переменных, используя полный или краткий вариант:\n\n```{r, echo=TRUE, eval=F}\na<-TRUE\nb<-FALSE\n#Или\na<-T\nb<-F\n```\n\nС логическим типом могут происходить интересные вещи, в частности, этот тип может рассматриваться как число. В таком случае TRUE принимается за 1, а FALSE как 0.\n\nИ если мы будем производить манипуляции над логическими значениями, в результате у нас будут числа!\n\nНапример:\n\n```{r dt1_3, echo=TRUE}\nTRUE + TRUE  # TRUE считается как 1\n```\n\n```{r dt1_4, echo=TRUE}\nFALSE * 7 # FALSE принимается за 0\n```\n\nИли, вот еще интересный пример:\n\n```{r dt1_5, echo=TRUE}\n(2 < 3) + (1 == 2)  # Что тут вообще происходит?\n```\n\nПочему получился именно такой результат?\n\n2 \\< 3 - TRUE, то есть 1\n\n1 == 2 - FALSE, то есть 0\n\nTRUE+FALSE=1+0=1\n\n-   **Числовой (numeric)** – целые и дробные, положительные и отрицательные.\n\n```{r dt3, echo=TRUE}\nis.numeric(-5.6)\na <- -11\nb <- 13.37\nc <- 1/137\nclass(a)\nclass(b)\nclass(c)\n```\n\nС числовыми переменными мы можем совершать различные математические операции:\n\n```{r dt3_1, echo=TRUE}\na <- -11\nb <- 13.37\nc <- 1/137\nprint(a+b*c)\nprint(a^2+sqrt(b)-c/5)\n```\n\n-   **Целое, целочисленное (integer)** – целые числа, положительные и отрицательные\n\n```{r dt4, echo=TRUE}\nx <- pi * 23.5\nclass(x)\n#Проверим, является ли x целым числом\nis.integer(x)\n#Создадим переменную y\ny<-25L #при вводе, для того, чтобы R понял, что число именно целое, добавляется буква L\n#Проверим, является ли y целым числом\nis.integer(y)\n#Проверим, является ли y числовой переменной\nis.numeric(y)\n```\n\n-   **Комплексные (complex)** – это уже абстрактная математика (числа состоящие из действительной (реальной) и мнимой части), например, 3+2i. Нам они вряд ли пригодятся, но на всякий случай запомним.\n\n```{r dt5, echo=TRUE}\nz <- 1:2 + 1i*(8:9)\nstr(z)\n```\n\n-   **Текстовые, строковые (character)** – «Привет, мир!», «а», «4В»\n\n```{r dt6, echo=TRUE}\ncolor<-\"Red\"\nclass(color)\nis.character(color)\n```\n\nВозможные варианты написания:\n\n```{r dt6_1, echo=TRUE}\nd <- \"Hello\"         # С помощью двойных кавычек \ne <- 'how are you?'  # С помощью одинарных кавычек\nd\ne\n```\n\nОднако, нельзя использовать и те, и другие сразу, будет ошибка:\n\n```{r dt6_2, echo=TRUE, eval=FALSE}\nf <- \"Так работать не будет' \n```\n\nИногда вместо текста нет ничего, но это все равно будет строковая переменная (пустая строка):\n\n```{r dt6_3, echo=TRUE}\nh <- \"\"              # Это пустая строка!\n```\n\nС числовыми переменными мы можем совершать различные операции, что же делать со строковыми переменными? К ним тоже можно применять разные функции, и их довольно много. Вот некоторые:\n\nПосчитаем количество символов в строке:\n\n```{r dt6_4, echo=TRUE}\ng<-\"Как упоительны в России вечера!\"\nnchar(g)\n```\n\nЕсли нам нужен какой-то определенный фрагмент текста, мы можем его \"вытащить\" оттуда:\n\n```{r dt6_5, echo=TRUE}\ng<-\"Как упоительны в России вечера!\"\nsubstr(g, 4, 25) \n```\n\nДовольно часто при анализе текстовых данных их нужно разделить на отдельные кусочки:\n\n```{r dt6_6, echo=TRUE}\ng<-\"Как упоительны в России вечера!\"\nstrsplit(g, \" \")   \n```\n\nВ данном случае мы использовали пробел в качестве разделителя.\n\n-   **Факторные переменные (factor)** – могут быть строковыми и числовыми, задают уровни или как правило являются номинальными переменными: пол, семейный статус, цвет волос и т. д., служат категоризации\n\n```{r dt7, echo=TRUE}\nx <- c(\"single\",\"married\",\"married\",\"single\")\nclass(x)\n```\n\n`factor ()` - функция, которая создает факторные переменные. Аргумент `levels` используется для обозначения уровней (порядка, если он нужен).\n\n```{r dt8, echo=TRUE}\nx <- factor(c(\"single\", \"married\", \"married\", \"single\"), levels = c(\"single\", \"married\", \"divorced\"))\nclass(x)\nstr(x)# функция str() дает больше информации о переменной, не только какого она типа, но сколько элементов содержит, какие в ней значения, уровни и т. д.\n```\n\n`as.factor()` - данная функция превращает в факторный тип переменные другого типа, даже если они числовые.\n\n```{r dt9, echo=TRUE}\ncolors<-c(\"red\", \"yellow\", \"green\")\ncolors<-as.factor(colors)\nstr(colors)\n```\n\nПример порядковой переменной с уровнями:\n\n```{r dt10, echo=TRUE}\nstatus <- c(\"Poor\", \"Middle-class\", \"Rich\")\nstatus <- factor(status, ordered=TRUE) # ordered=TRUE - делает переменную не просто категориальной, но и порядковой\nstr(status)\n```\n\nПолучилось не совсем то, что нам нужно, так как программа автоматически отсортировывает по алфавиту. Чтобы поменять порядок, нужно задать уровни \"принудительно\":\n\n```{r dt11, echo=TRUE}\nstatus <- c(\"Poor\", \"Middle-class\", \"Rich\")\nstatus <- factor(status, order=TRUE,levels=c(\"Poor\", \"Middle-class\", \"Rich\"))\nstr(status)\n```\n\n### Вопросы для самопроверки\n\n**1. К какому типу переменных относится число -3,5?**\n\n```{r}\n    type_data <- c(\n        answer =\"numeric\",\n       \"character\",\n       \"complex\", \n       \"integer\"\n    )\n```\n\n`r longmcq(type_data)`\n\n**2. Какой результат получится, если попытаться превратить в число строковую переменную?**\n\n```{r}\n    string_to_number <- c(\n        answer =\"NA\",\n       \"TRUE\",\n       \"NAs introduced by coercion\"\n    )\n```\n\n`r longmcq(string_to_number)`\n\n**3. Какая функция используется для проверки принадлежности переменной к факторному типу?**\n\n```{r}\n    check_factor <- c(\n        answer =\"is.factor()\",\n       \"as.factor()\",\n       \"factor()\"\n    )\n```\n\n`r longmcq(check_factor)`\n\n**4. Могут ли логические переменные быть представлены в числовом виде?**\n\n```{r}\n    logical_numbers <- c(\n        answer =\"Да()\",\n       \"Нет\",\n       \"Затрудняюсь ответить\"\n    )\n```\n\n`r longmcq(logical_numbers)`\n\n### Самостоятельная работа\n\n[Самостоятельная работа № 1](https://socio-asu.shinyapps.io/Assignment1/){.btn .btn-outline-primary .btn role=\"button\"}\n\n## Структуры данных\n\n**Структура данных** — это способ организации информации для более эффективного использования. В программировании структурой обычно называют набор данных, связанных определённым образом.\n\nОсновные структуры данных в R это векторы, матрицы, массивы, списки и таблицы данных.\n\nРассмотрим их подробнее.\n\n![](images/DataStructures/1.png)\n\n### Векторы\n\n-   **Вектор** – одномерный массив проиндексированных (пронумерованных) элементов, набор однотипных элементов (либо числа, либо буквы) без их сочетания. Векторы могут быть такими же, как и типы данных - числовыми, строковыми, логическими и пр.\n\nВот пример того, как можно создать числовой вектор, содержащий числа от 1 до 10:\n\n```{r vec1, echo=TRUE}\nx<-1:10\nx\n```\n\nА вот так - вектор с текстовыми элементами:\n\n```{r vec2, echo=TRUE}\ny<-c(\"Красный\", \"Синий\", \"Желтый\")\ny\n```\n\nЗаметьте, чтобы создать вектор с наименованиями цветов, мы использовали функцию `c()`, в которой `c` является производной от`combine`. В этом есть смысл, поскольку мы соединяем, как бы \"комбинируем\", несколько числовых или текстовых объектов в один ряд.\n\n::: callout-important\n## Про имена (важно!)\n\nКак назвать вектор (да и другие структуры данных) правильно? Есть несколько простых правил. Имя может содержать:\n\n-   буквы\n-   числа\n-   точку или символ «подчеркивания\" (\\_)\n\nи обязательно должно начинаться с буквы или точки, но за точкой нельзя поставить цифру.\n\nТак, например, имя \".2b\" не является валидным, а \".b2\" - вполне годится для именования.\n\nНельзя также использовать в именах **зарезервированные слова**,такие как `if,else, repeat, while, function, for, in, next, break, TRUE, FALSE, NULL, Inf, NaN, NA, NA_integer_, NA_real_, NA_complex_, NA_character_` некоторых других, которые являются базовыми конструкциями языка и используются в качестве аргументов при вызове функций.\n:::\n\nНапример, если мы попробуем создать вот такой вектор, то программа выдаст ошибку:\n\n```{r, echo=TRUE}\n#| error: true\nbreak<-1:5\n```\n\nДлину числового вектора можно определить с помощью функции `length()`:\n\n```{r vec3, echo=TRUE}\nx<-1:3\nlength(x)\n```\n\nФункция `class()` помогает определить, какой тип данных хранится в векторе. Напомним, что вектор содержит данные одного типа.\n\n```{r vec4, echo=TRUE}\nx<-c(1:3)\nclass(x)\n```\n\nЕще примеры создания логических и текстовых векторов:\n\n```{r vec5, echo=TRUE}\ny <- c(TRUE, TRUE, FALSE, TRUE)\nz <- c(\"to\", \"be\", \"or\", \"not\", \"to\", \"be\") \nclass(y)\nlength(y)\nclass(z)\nlength(z)\n```\n\n::: callout-important\nЕсли мы попытаемся соединить два вектора - числовой и строковый - то цифры \"превратятся\" в буквы, поскольку R автоматически переведет все элементы к наиболее подходящему общему типу данных. Поскольку слова в цифры превратить нельзя, то таким общим типом будет строковый.\n:::\n\n```{r vec6, echo=TRUE}\nx<-c(1:10)\ny<-c(\"Красный\", \"Синий\", \"Желтый\")\nz<-c(x,y)\nx\ny\nz\n```\n\nТо, что произошло в коде выше, называется *конверсией типов*. Такая конверсия случается тогда, когда элементы вектора разные. Запомниим, что вектор всегда хранит данные только одного типа!\n\n**Задание**. Попробуйте создать вектор, сочетающий числовые, строковые и логические значения:\n\nА что будет, если мы соединим вместе логические и числовые?\n\n```{r vec8, echo=TRUE}\nx<-c(TRUE, 5, FALSE, 6)\nx\n```\n\nМы можем также создавать \"пустые\" вектора, обозначая только тип данных, и сколько элементов в них содержится.\n\nНапример:\n\n```{r vec9, echo=TRUE}\nempty <- numeric(10)   # Создаем пустой числовой вектор с 10 элементами\nprint(empty)\n```\n\nЗаметьте, что даже если мы не просили R внести какие-то значения, в числовом векторе всем элементам автоматически были присвоены нули - значение *по умолчанию*.\n\nВот таким образом можно создать пустые вектора других типов:\n\n```{r, echo=TRUE}\nempty_int <- integer(45)   # числовой вектор с 45 элементами\nempty_cha <- character(2)  # строковый вектор с 2 элементами\nempty_log <- logical(1000)    # логический вектор с 1000 элементами\n```\n\nPfПопробуйте в RStudio создать эти вектора и посмотреть их. Обратите внимание, какие значения по умолчанию присваиваются в логическом и строковом векторах!\n\n#### Адресация и изменение элементов вектора\n\nПосле того, как вектор создан, как мы можем посмотреть или изменить его элементы. Это сделать достаточно просто:\n\nПоменять элемент в векторе:\n\n```{r vec10, echo=TRUE}\na <- c(1, 2, 3)  # Создадим числовой вектор с 3 элементами\na[2] <- 4        # Изменим значение второго элемента на 4\na                # Посмотрим, что получилось\n```\n\nКак вы уже догадались, чтобы обратиться к какому-то элементу вектора, нужно набрать его порядковый номер в квадратных скобках \\[ порядковыйномер \\]:\n\n```{r vec11, echo=TRUE}\na <- c(1, 2, 3)  # Создадим числовой вектор с 3 элементами\na[3]             # Попросим R вывести третий элемент\n```\n\nКак вы думаете, что будет если запустить следующий код? Каким будет результат?\n\n```{r, echo=TRUE, eval=FALSE}\nvec <- c(4, 5, 6)\nvec[3] == 6\n```\n\nДогадались? Попробуйте теперь запустить этот код и проверить, правы вы или нет:\n\n```{r vec12, echo=TRUE}\n\n```\n\n#### Операции над векторами\n\nС векторами можно производить большое количество действий, которые позволяют те типы данных, которые в них содержатся.\n\nПроще всего совершать арифметические действия:\n\n```{r vec13, echo=TRUE}\na <- 3   # Создаем единичный числовой объект\na + 4  # Прибавляем к нему константу\n```\n\nМы можем прибавить число не только к другому числу, но и ко всему вектору:\n\n```{r vec14, echo=TRUE}\na <- c(1, 2, 3)   # Создаем числовой вектор\na + 4   # Прибавляем к нему константу\n```\n\nТакой тип \"поведения\" программы называется *поэлементным*. То есть операция производится над каждым элементом по отдельности.\n\nЕще примеры:\n\n```{r vec15, echo=TRUE}\na <- c(1, 2, 3)\na - 3 \na * 1.5\na ^ 2\na == 2\n```\n\nВ последнем случае мы сравнивали каждый элемент со значением два и в результате получили новый вектор, состоящий из логических значений.\n\nВ R имеется много различных функций для трансформации, мы с ними будем активно работать на следующих занятиях. Но самая простая функциюя - `sum()`, которая просто складывает все элементы вектора вместе:\n\n```{r vec16, echo=TRUE}\na <- c(1, 2, 3)\nsum(a)\n```\n\nНекоторые операции можно производить над векторами, если у них одинаковая длина:\n\n```{r vec18, echo=TRUE}\na <- c(1, 2, 3)\nb <- c(1, 0, 1)\na + b\nb * a\na ^ b\n\n```\n\nМы можем даже сравнить два вектора и сохранить результат в отдельном логическом векторе\n\n```{r vec19, echo=TRUE}\na <- c(1, 2, 3)\nb <- c(1, 0, 1)\nz <- a > b   # сравниваем a и b, поэлементно, результат сохраняем в векторе z\nz\nz == TRUE\nz == FALSE\n!z #выдает противоположное значение\n\n```\n\nА что можно делать со строковыми векторами?\n\nДавайте создадим пару векторов и попробуем с ними совершить какие-нибудь действия, например, сравним их попарно:\n\n```{r vec20, echo=TRUE}\na <- c(\"собака\", \"молоко\", \"квартира\", \"чай\", \"морозы\", \"душа\")\nb <- c(\"собака\", \"мыло\", \"сахар\", \"чай\", \"малина\", \"душа\")\na==b\n\n```\n\nЧтобы найти какой-то текстовый элемент и его место в векторе, можно использовать функцию `grep()`:\n\n```{r vec21, echo=TRUE}\na <- c(\"собака\", \"молоко\", \"квартира\", \"чай\", \"морозы\", \"квартира\", \"душа\")\ngrep(\"квартира\", a)\n\n```\n\nРезультат показывает, что слово \"квартира\" встречается два раза, это третий и шестой элементы. Что будет, если поищем то, чего нет?\n\n```{r vec22, echo=TRUE}\na <- c(\"собака\", \"молоко\", \"квартира\", \"чай\", \"морозы\", \"квартира\", \"душа\")\ngrep(\"редиска\", a)\n\n```\n\nЕсли вектора разного типа, то иногда с ними можно что-то сделать, иногда нет, зависит от типа данных:\n\n```{r vec23, echo=TRUE, eval=FALSE}\na <- c(1, 2, 3)\nb <- c(\"one\", \"two\", \"three\")\nc <- c(TRUE, TRUE, FALSE)\na+b\n```\n\nНичего не получилось, потому что нельзя к словам прибавлять числа. А вот если сложить вектора a и c, все получится:\n\n```{r vec23_1, echo=TRUE}\na <- c(1, 2, 3)\nb <- c(\"one\", \"two\", \"three\")\nc <- c(TRUE, TRUE, FALSE)\na+c\n```\n\n#### Некторые полезные функции для работы с векторами\n\n-   Создать вектор случайных чисел в определенном диапазоне:\n\n```{r vec24, echo=TRUE}\nx <- runif(10, min = -5, max = 5)\nx\n```\n\n-   Создать вектор с повторяющимися значениями с помощью функции `rep()` – повторить (что, сколько раз):\n\n```{r vec25, echo=TRUE}\nb<- rep(c(1,2,3),4)\nb\n```\n\n-   Создать вектор из повторяющихся значений определенной длины с помощью функции `rep()` – повторить (что, до каких пор, какой длины):\n\n```{r vec26, echo=TRUE}\nc<- rep(c(4,5,6), length.out=10)\nc\n```\n\n-   Создать вектор через последовательность определенных значений с помощью функции `seq()` – задать последовательность (от, до, с каким шагом)\n\n```{r vec27, echo=TRUE}\nseq <- seq(from=2,to=15,by=0.5)\nseq\n```\n\n-   Проверить, является ли какой-то объект вектором с помощью функции `is.vector()` :\n\n```{r vec28, echo=TRUE}\nseq <- seq(from=2,to=15,by=0.5)\nis.vector(seq)\n```\n\n-   Проверить, удовлетворяет ли хотя бы один элемент вектора какому-либо условию с помощью функции `any()`:\n\n```{r vec29, echo=TRUE}\nvec <- as.integer(c(34,23,53,42,16,42,64,32,76))\nany(vec,vec>50)\n```\n\n-   Проверить, удовлетворяют ли все элементы вектора какому-либо условию с помощью функции `all()`:\n\n```{r vec30, echo=TRUE}\nvec <- as.integer(c(34,23,53,42,16,42,64,32,76))\nall(vec,vec>10)\n```\n\n-   Применить какую-либо функцию преобразования ко всем элементам вектора с помощью функции `sapply()`:\n\n```{r vec31, echo=TRUE}\nvec <- as.integer(c(34,23,53,42,16,42,64,32,76))\nvec3<-sapply(vec, sqrt)\nvec3\n```\n\nВ принципе, можно это сделать и проще:\n\n```{r vec32, echo=TRUE}\nvec <- as.integer(c(34,23,53,42,16,42,64,32,76))\nsqrt(vec)\n```\n\nНо иногда, когда у нас не вектор, а более сложный объект, функция `sapply()` и ее родные сестры `apply()` и `lapply()`часто очень выручают. Подробнее эти функции будут рассмотрены на следующих занятиях.\n\n### Матрицы\n\n-   **Матрица** – двумерная совокупность числовых, логических или текстовых величин. Чтобы создать матрицу, нужно воспользоваться функцией matrix(). Можно думать о матрице как о решетке каких-то числовых величин.\n\nПростой пример:\n\n```{r mat1, echo=TRUE}\ndata <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA <- matrix(data, ncol=3, nrow=3)\nA\n\n```\n\nМы создали матрицу с тремя строками и тремя колонками на основе данных, изначально хранящихся в виде числового вектора.\n\n::: callout-important\nR заполняет матрицу сверху вниз, колонку за колонкой, двигаясь справа налево.\n:::\n\nЕсли мы хотим это изменить, нужно поменять параметр `byrow`:\n\n```{r mat, echo=TRUE}\ndata <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA <- matrix(data, ncol=3, nrow=3, byrow = T)\nA\n\n```\n\n#### Полезные функции и операции над матрицами\n\n-   Как обратиться к одному из элементов матрицы? В случае с вектором мы задавали один элемент в квадратных скобках, а что теперь? Матрица - двумерный объект, поэтому мы должны теперь в квадратных скобках задать две координаты - номер строки (первое число) и номер колонки (второе число) - через запятую:\n\n```{r mat2, echo=TRUE}\ndata <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA <- matrix(data, ncol=3, nrow=3, byrow = T)\nA\nA[1,1] # Первый элемент первой строки\nA[2,3] # Третий элемент второй строки\nA[1,]  # Первая строка полностью\nA[,3]  # Третий столбец полностью\n```\n\nЧтобы получить диагональные элементы, есть специальная функция - `diag()`\n\n```{r mat3, echo=TRUE}\ndata <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA <- matrix(data, ncol=3, nrow=3, byrow = T)\ndiag(A)\n```\n\nЧтобы узнать размерность матрицы (количество строк и столбцов) - можно использовать функцию `dim()`:\n\n```{r mat4, echo=TRUE}\ndata <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA <- matrix(data, ncol=3, nrow=3, byrow = T)\ndim(A)\n```\n\nВ результате применения функции мы получаем числовой вектор, первое значение в котором обозначает количество строк, второе - столбцов.\n\n**Задание**: воспроизведите еще раз матрицу A и напишите код, позволяющий получить произведение первого элемента второй строки и третьего элемента третьей строки.\n\nС матрицами, как и с векторами, можно совершать разные математические операции - сложение, умножение, вычитание и т.д.:\n\n-   Например, прибавить единицу к каждому элементу матрицы:\n\n```{r mat6, echo=TRUE}\ndata <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA <- matrix(data, ncol=3, nrow=3, byrow = T)\nA\nA+1   \n```\n\n-   Умножить каждый элемент на 2:\n\n```{r mat7, echo=TRUE}\ndata <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA <- matrix(data, ncol=3, nrow=3, byrow = T)\nA\nA*2\n```\n\n-   Возвести в квадрат:\n\n```{r mat8, echo=TRUE}\ndata <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA <- matrix(data, ncol=3, nrow=3, byrow = T)\nA\nA^2\n```\n\n-   Довольно часто возникает необходимость транспонирования, когда строки становятся столбцами и наоборот:\n\n```{r mat9, echo=TRUE}\ndata <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA <- matrix(data, ncol=3, nrow=3, byrow = T)\nA\nt(A)\n```\n\n-   Найдти след матрицы\n\n*След матрицы - это сумма диагональных элементов*:\n\n```{r mat10, echo=TRUE}\ndata <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA <- matrix(data, ncol=3, nrow=3, byrow = T)\nsum(diag(A))\n```\n\n-   Сложить две матрицы\n\n```{r mat11, echo=TRUE}\ndata <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA <- matrix(data, ncol=3, nrow=3, byrow = T)\nB <- matrix(1, 3, 3)\nA + B\n```\n\nЗаметьте, как мы это сделали: мы создали матрицу В одной строкой (матрица 3\\*3, состоящая из одних единиц).\n\n-   Перемножить элементы двух матриц:\n\n```{r mat12, echo=TRUE}\ndata <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA <- matrix(data, ncol=3, nrow=3, byrow = T)\nB <- matrix(2, 3, 3)\nA * B\n```\n\n-   Осуществить матричное умножение:\n\n```{r mat13, echo=TRUE}\ndata <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA <- matrix(data, ncol=3, nrow=3, byrow = T)\nB <- matrix(2, 3, 3)\nA %*%  B\n```\n\nВ чем разница между двумя умножениями? В первом случае элементы поэлементно умножаются друг на друга, во втором - происходит умножение матриц по законам линейной алгебры.\n\n**Задание**. Воспроизведите матрицу А из примера выше и осуществите матричное умножение между матрицей А и транспонированной матрицей А.\n\n### Массивы\n\n-   **Массив (array)** – объект в R, в котором хранится данные, содержащие более двух измерений. Например, если мы создадим массив с параметрами (2, 3, 4), у нас получится 4 прямоугольные матрицы размером 2 на 3. В массивах хранятся данные только одного типа.\n\nДля того, чтобы создать массив, есть специальная функция `array()`. Она принимает на входе вектора и использует значения параметра `dim`, чтобы создать массив.\n\nПример:\n\n```{r arr1, echo=TRUE}\nvector1 <- c(5,9,3)\nvector2 <- c(10,11,12,13,14,15)\narr1 <- array(c(vector1,vector2),dim = c(3,3,2))\narr1\n```\n\nМы можем присвоить имена строкам, колонкам и матрицам массива с помощью параметра `dimnames`:\n\n```{r arr2, echo=TRUE}\nvector1 <- c(5,9,3)\nvector2 <- c(10,11,12,13,14,15)\ncolumn.names <- c(\"COL1\",\"COL2\",\"COL3\")\nrow.names <- c(\"ROW1\",\"ROW2\",\"ROW3\")\nmatrix.names <- c(\"Matrix1\",\"Matrix2\")\nresult <- array(c(vector1,vector2),dim = c(3,3,2),dimnames = list(row.names,column.names,\n   matrix.names))\nresult\n```\n\n#### Манипуляции с элементами массива\n\nТак как массив - это по сути совокупность нескольких матриц, то и операции мы с массивами мы можем производить практически такие же.\n\n-   Обращение к элементам\n\nОбращение к элементам массива практически такое же, как и в случае с матрицами, чуть сложнее, поскольку добавляются новые измерения, но общая логика остается та же - мы в квадратных скобках указываем координаты элемента, которые нам нужны:\n\n```{r arr3, echo=TRUE}\nvector1 <- c(5,9,3)\nvector2 <- c(10,11,12,13,14,15)\ncolumn.names <- c(\"COL1\",\"COL2\",\"COL3\")\nrow.names <- c(\"ROW1\",\"ROW2\",\"ROW3\")\nmatrix.names <- c(\"Matrix1\",\"Matrix2\")\nresult <- array(c(vector1,vector2),dim = c(3,3,2),dimnames = list(row.names,column.names,\n   matrix.names))\nresult[3,,2] # Третья строка второй матрицы\nresult[1,3,1] # Третий элемент первой строки первой матрицы\nresult[,,2] #Вся вторая матрица\n```\n\n-   Создание матрицы на основе массива:\n\n```{r arr4, echo=TRUE}\nvector1 <- c(5,9,3)\nvector2 <- c(10,11,12,13,14,15)\ncolumn.names <- c(\"COL1\",\"COL2\",\"COL3\")\nrow.names <- c(\"ROW1\",\"ROW2\",\"ROW3\")\nmatrix.names <- c(\"Matrix1\",\"Matrix2\")\narray1 <- array(c(vector1,vector2),dim = c(3,3,2),dimnames = list(row.names,column.names,\n   matrix.names))\nmatrix1 <- array1[,,1]\nmatrix2 <- array1[,,2]\nmatrix1\nmatrix2\n```\n\n-   Арифметические действия с элементами:\n\n```{r arr5, echo=TRUE}\nvector1 <- c(5,9,3)\nvector2 <- c(10,11,12,13,14,15)\ncolumn.names <- c(\"COL1\",\"COL2\",\"COL3\")\nrow.names <- c(\"ROW1\",\"ROW2\",\"ROW3\")\nmatrix.names <- c(\"Matrix1\",\"Matrix2\")\narray1 <- array(c(vector1,vector2),dim = c(3,3,2),dimnames = list(row.names,column.names,\n   matrix.names))\narray1[1,2,1]+array1[3,2,2]\n```\n\n### Списки (lists)\n\nСписок(list) - сложный объект, в котором могут храниться данные разных типов и структуры, включая вектора, матрицы и т.д.\n\nПример:\n\n```{r list1, echo=TRUE}\nA <- list(\"Red\", \"Green\", c(21,32,11), matrix(c(1:9), nrow=3, ncol=3), TRUE, 51.23, 119.1)\nA\n```\n\nСписки могут даже содержать внутри другие списки!\n\n```{r list2, echo=TRUE}\nA <- list(\"Red\", \"Green\", c(21,32,11), matrix(c(1:9), nrow=3, ncol=3), TRUE, 51.23, 119.1)\nA[[8]]<-list(\"One\", 256, TRUE)\nA\n```\n\nКомпоненты списка также могут иметь имена:\n\n```{r list3, echo=TRUE}\nA <- list(\"Red\", \"Green\", c(21,32,11), matrix(c(1:9), nrow=3, ncol=3), TRUE, 51.23, 119.1)\nA[[\"color\"]] <- \"yellow\"\nA\n\n```\n\nТаким образом, обратиться к компоненту списка можно по имени или по порядковому номеру элемента:\n\n```{r list4, echo=TRUE}\nA <- list(\"Red\", \"Green\", c(21,32,11), matrix(c(1:9), nrow=3, ncol=3), TRUE, 51.23, 119.1)\nA[[\"color\"]] <- \"yellow\"\nA[[\"color\"]]\nA$color #Альтернативный вариант обращения по имени\nA[[8]]\n```\n\n## Таблицы данных (data frame)\n\nДля аналитиков данных это самый важный объект, с которым приходится работать чаще всего. Большинство из тех данных, с которыми нам приходится иметь дело, хранятся именно в формате датафрейма.\n\nТаблица данных (data frame) - может включать данные разного типа, но только по столбцам. Иными словами, в таблице может быть несколько типов данных, но в каждом столбце может быть только один тип.\n\n```{r df1, echo=TRUE}\ndf<- data.frame(id = c(1:4), city = c(\"Москва\",\"Лондон\",\"Париж\",\"Нью-Йорк\"), population = c(16555000, 10840000,10960000,21045000))\ndf\n```\n\nОбращаться к элементам таблицы данных можно точно так же, как и к элементам матрицы:\n\n```{r df2, echo=TRUE}\ndf<- data.frame(id = c(1:4), city = c(\"Москва\",\"Лондон\",\"Париж\",\"Нью-Йорк\"), population = c(16555000, 10840000,10960000,21045000))\ndf[1,2]\n```\n\nЧтобы добавить новую переменную, нужно использовать знак `$`:\n\n```{r df3, echo=TRUE}\ndf<- data.frame(id = c(1:4), city = c(\"Москва\",\"Лондон\",\"Париж\",\"Нью-Йорк\"), population = c(16555000, 10840000,10960000,21045000))\ndf$country<-c(\"Россия\", \"Великобритания\", \"Франция\", \"США\")\ndf$pop2<-df$population/1000\ndf\n```\n\nС помощью этого же знака, можно вывести все значения той или иной переменной:\n\nЧтобы добавить новую переменную, нужно использовать знак `$`:\n\n```{r df4, echo=TRUE}\ndf<- data.frame(id = c(1:4), city = c(\"Москва\",\"Лондон\",\"Париж\",\"Нью-Йорк\"), population = c(16555000, 10840000,10960000,21045000))\ndf$country<-c(\"Россия\", \"Великобритания\", \"Франция\", \"США\")\ndf$pop2<-df$population/1000\ndf$city\n```\n\nЧтобы узнать размерность таблицы, можно воспользоваться уже известной нам функции `dim()`:\n\n```{r df5, echo=TRUE}\ndf<- data.frame(id = c(1:4), city = c(\"Москва\",\"Лондон\",\"Париж\",\"Нью-Йорк\"), population = c(16555000, 10840000,10960000,21045000))\ndf$country<-c(\"Россия\", \"Великобритания\", \"Франция\", \"США\")\ndf$pop2<-df$population/1000\ndim(df)\n```\n\nЕсли у нас есть список векторов, мы можем их легко трансформировать в датафрейм:\n\n```{r df6, echo=TRUE}\npeople <- list(name=c(\"Alice\", \"Bob\", \"Charlie\"), \n               grade=c(99.4, 87.6, 22.1), \n               sex=c(\"F\", \"M\", \"M\"))\nas.data.frame(people)\n```\n\nВ R содержатся много загруженных наборов данных, таких например, как `mtcars`, в котором содержатся данные по 32 маркам автомобилей:\n\n```{r df7, echo=TRUE}\nmtcars\n```\n\nСамые простые операции с таблицами данных заключаются в выводе данных, наименований строк и столбцов.\n\nКак вывести первые несколько наблюдений?\n\n```{r df8, echo=TRUE}\nhead(mtcars)\n```\n\nКак вывести последние несколько наблюдений?\n\n```{r df9, echo=TRUE}\ntail(mtcars)\n```\n\nКакие переменные содержатся в наборе mtcars?\n\n```{r df10, echo=TRUE}\nnames(mtcars)\n```\n\nНу, и напоследок, представим сводку о данных, содержащихся в этом наборе:\n\n```{r df11, echo=TRUE}\nsummary(mtcars)\n```\n\n## Самостоятельная работа\n\n[Самостоятельная работа №2](https://socio-asu.shinyapps.io/Assignment2/){.btn .btn-outline-primary .btn role=\"button\"}2\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["include/webex.css"],"include-after-body":["include/webex.js"],"embed-resources":false,"output-file":"Data-types-and-structures.html"},"language":{"toc-title-document":"Содержание","toc-title-website":"Содержание","related-formats-title":"Другие форматы","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Источник","other-links-title":"Другие ссылки","code-links-title":"Ссылки на код","launch-dev-container-title":"Запустить Dev Container","launch-binder-title":"Запустить Binder","article-notebook-label":"Блокнот статьи","notebook-preview-download":"Скачать блокнот","notebook-preview-download-src":"Скачать исходный код","notebook-preview-back":"Вернуться к статье","manuscript-meca-bundle":"Архив MECA","section-title-abstract":"Аннотация","section-title-appendices":"Приложения","section-title-footnotes":"Сноски","section-title-references":"использованная литература","section-title-reuse":"Повторное использование","section-title-copyright":"Авторские права","section-title-citation":"Цитата","appendix-attribution-cite-as":"Пожалуйста, цитируйте эту работу как:","appendix-attribution-bibtex":"BibTeX","appendix-view-license":"Просмотреть Лицензию","title-block-author-single":"Автор","title-block-author-plural":"Авторы","title-block-affiliation-single":"принадлежность","title-block-affiliation-plural":"Принадлежности","title-block-published":"Дата публикации","title-block-modified":"Файл изменен","title-block-keywords":"Ключевые слова","callout-tip-title":"Совет","callout-note-title":"Уведомление","callout-warning-title":"Предупреждение","callout-important-title":"Важное уведомление","callout-caution-title":"Осторожность","code-summary":"Код","code-tools-menu-caption":"Код","code-tools-show-all-code":"Развернуть код","code-tools-hide-all-code":"Скрыть код","code-tools-view-source":"Показать код","code-tools-source-code":"Исходный код","tools-share":"Share","tools-download":"Download","code-line":"Линия","code-lines":"Линии","copy-button-tooltip":"Скопировать текст","copy-button-tooltip-success":"Скопировано","repo-action-links-edit":"Редактировать страницу","repo-action-links-source":"Показать код","repo-action-links-issue":"Сообщить о проблеме","back-to-top":"Наверх","search-no-results-text":"Поиск не дал результатов","search-matching-documents-text":"Результаты поиска","search-copy-link-title":"Скопировать ссылку","search-hide-matches-text":"Скрыть дополнительные результаты","search-more-match-text":"дополнительный результат в этом документе","search-more-matches-text":"дополнительных результата(-ов) в этом документе","search-clear-button-title":"Очистить","search-text-placeholder":"","search-detached-cancel-button-title":"Отменить","search-submit-button-title":"Найти","search-label":"Поиск","toggle-section":"Переключить раздел","toggle-sidebar":"Переключить боковую панель навигации","toggle-dark-mode":"Переключить темный режим","toggle-reader-mode":"Переключить режим чтения","toggle-navigation":"Переключить навигацию","crossref-fig-title":"Рисунок","crossref-tbl-title":"Таблица","crossref-lst-title":"Список","crossref-thm-title":"Теорема","crossref-lem-title":"Лемма","crossref-cor-title":"Следствие","crossref-prp-title":"Утверждение","crossref-cnj-title":"Гипотеза","crossref-def-title":"Определение","crossref-exm-title":"Пример","crossref-exr-title":"Упражнение","crossref-ch-prefix":"Глава","crossref-apx-prefix":"Приложение","crossref-sec-prefix":"Глава","crossref-eq-prefix":"Уравнение","crossref-lof-title":"Список Иллюстраций","crossref-lot-title":"Список Таблиц","crossref-lol-title":"Список Каталогов","environment-proof-title":"Доказательство","environment-remark-title":"Примечание","environment-solution-title":"Решение","listing-page-order-by":"Сортировать по","listing-page-order-by-default":"предварительно выбранный","listing-page-order-by-date-asc":"Самый старый","listing-page-order-by-date-desc":"Новейшие","listing-page-order-by-number-desc":"нисходящий","listing-page-order-by-number-asc":"по возрастанию","listing-page-field-date":"Дата","listing-page-field-title":"Заголовок","listing-page-field-description":"Описание","listing-page-field-author":"Автор","listing-page-field-filename":"Имя файла","listing-page-field-filemodified":"Файл изменен","listing-page-field-subtitle":"Подзаголовок","listing-page-field-readingtime":"Время чтения","listing-page-field-wordcount":"Подсчет слов","listing-page-field-categories":"Категории","listing-page-minutes-compact":"{0} минут","listing-page-category-all":"Все","listing-page-no-matches":"Нет подходящих элементов","listing-page-words":"{0} слов","listing-page-filter":"Фильтр","draft":"Черновик"},"metadata":{"lang":"ru","fig-responsive":true,"quarto-version":"1.5.57","comments":{"hypothesis":true},"bibliography":["references.bib"],"editor":"visual","theme":"Pulse","title":"Типы и структуры данных"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}
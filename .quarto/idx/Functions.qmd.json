{"title":"Основы функционального программирования","markdown":{"yaml":{"title":"Основы функционального программирования"},"headingText":"Понятие функции и ее основные элементы","containsRefs":false,"markdown":"\n\nКроме того, что R является интерпретируемым языком, это еще и язык функционального программирования (ФП). Это означает, что R содержит множество инструментов для создания и манипулирования функциями. Более того, функции могут быть рассмотрены как [*объекты первого класса*](https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8_%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%B3%D0%BE_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0), то есть мы можем делать с функциями то же самое, что и с векторами: присваивать их переменным, сохранять их как списки, передавать в качестве аргументов другим функциям, создавать функции внутри функций и даже возвращать их в качестве результата.\n\nЗачем нам, социологам, уметь разбираться и писать собственные функции? Это важно по нескольким причинам. Во-первых, знание о том, как функции устроены, поможет нам использовать R более осознанно, с четким пониманием того, что происходит, когда мы запускаем ту или иную команду. Поначалу может казаться, что писать свои функции это нечто запредельное, что-то доступное только программистам или специалистам с техническим образованием. Но по мере того, как вы будете овладевать языком, писать больше кода и проводить анализ на R, вы поймете, что собственные, пусть и не очень сложные функции, могут помочь автоматизировать некоторые рутинные задачи (например, по перекодировке или чистке данных, создани. однотипных объектов, таких как таблицы или графики) и, в конечном итоге, сделают вашу работу в R быстрой и эффективной.\n\nТак, что же такое функция? Давайте разбираться.\n\n\nФункция представляет собой набор утверждений, организованных вместе для выполнения определенной задачи.\n\nЭто часть программного кода, имеющий определенное имя, который может быть вызван сам по себе или в других частях программы.\n\n::: {.callout-note appearance=\"minimal\"}\nВ R имеется множество встроенных функций, и огромное количество дополнительных функций можно найти в различных библиотеках. Каждый пользователь может создавать свои собственные функции.\n:::\n\n::: {.callout-important appearance=\"minimal\"}\nФункция является объектом, и значит интерпретатор R может проверить, насколько хорошо функция выполняется, нужны ли функции какие-то аргументы для выполнения и есть ли у программы достаточно информации, чтобы все сделать так, как описано в функции.\n:::\n\n::: {.callout-note appearance=\"minimal\"}\nВ свою очередь функция выполняет задачу и выдает (возвращает, return) какие-то результаты, которые могут быть сохранены в дальнейшем как отдельные объекты.\n:::\n\n**Формула функции**\n\nВ R функция создается очень просто - с помощью ключевого слова `function`. Базовый синтаксис у функции следующий:\n\n```{r eval=F}\n\nfunction_name <- function(arg_1, arg_2, ...) {\n   Function body \n}\n```\n\n**Компоненты функции**\n\nУ функции есть несколько частей\n\n::: {.alert .alert-info role=\"alert\"}\n**Function Name (имя функции)** − тут все просто - это имя функции, которое хранится в окружении и обозначает конкретный объект (то есть саму функцию). Зная имя функции, ее можно вызвать в любое время и вставить в любую часть программного кода.\n:::\n\n::: {.alert .alert-danger role=\"alert\"}\n**Arguments (аргументы)** − это те элементы, параметры, значения, которые вводятся в функцию, чтобы она работала. Аргументы не являются обзательными, функция может иногда работать и без них, либо они могут быть указаны по умолчанию.\n:::\n\n::: {.alert .alert-success role=\"alert\"}\n**Function Body (тело функции)** − пожалуй, самая главная часть функции, содержащая утверждения, определяющие то, что именно делает данная функция.\n:::\n\n::: {.alert .alert-warning role=\"alert\"}\n**Return Value (возвращаемое значение)** − возвращаемое значение - это результат обработки последнего выражения в теле функции, то есть ее конечный результат. Если в функции заложено множество действий - то это последнее действие.\n:::\n\n## Встроенные функции\n\nМожно привести огромное количество базовых функций, таких как `seq()`, `mean()`, `max()`, `sum(x)`, `paste(...)` и т. д. Они вызываются напрямую при написании программы.\n\n```{r eval=F}\n# Создать последовательность чисел от 32 до 44\nseq(32,44)\n\n# Найти среднее чисел от 25 до 82.\nmean(25:82)\n\n# Найти сумму чисел от 41 до 68.\nsum(41:68)\n```\n\n## Функции apply(), lapply(), sapply(), tapply()\n\nСемейство функций `apply()` позволяет производить различные преобразования с отдельными элементами векторов, матриц и датафреймов. Такие действия в процессе анализа данных приходится проводить довольно часто. Например, нам может потребоваться сдвинуть значения переменных на какую либо константу, или провести трансформации, необходимые для нормализации данных.\n\n### apply()\n\nОбщая формула для функции `apply()`:\n\n`apply(data, MARGIN, FUN)`,\n\nГде:\n\n-   `data`: массив или матрица\n-   `MARGIN`: данный аргумент принимает значения 1 или 2\n-   `MARGIN=1`: манипуляции проводятся со строками\n-   `MARGIN=2`: манипуляции проводятся со столбцами\n-   `MARGIN=c(1,2)`: манипуляции проводятся со строками и столбцами одновременно\n-   `FUN`: функция, которую необходимо применить, например, рассчитать среднее `mean()`, медиану `median()`, сумму `sum()`, минимум `min()`, максимум `max()` и др. Также можно применить пользовательские функции.\n\nПростой пример применения данной функции - суммировать данные по столбцам (запустите код ниже и посмотрите на результат в последней строке):\n\n```{r eval=FALSE}\nm1 <- matrix(1:10,nrow=5, ncol=6)\nm1\na_m1 <- apply(m1, 2, sum)\n\na_m1\n```\n\n{{< iconify arcticons writer size=42px >}} **Самостоятельное задание**: попробуйте изменить код так, чтобы сумма считалась не по столбцу, а по строке.\n\n### lapply()\n\nФункция `lapply()` полезна для осуществления операций над списками и возвращает список объектов такой же длины. При этом каждый объект является результатом применения функции к элементу исходного списка. Эта функция может применяться к спискам, векторам или датафрейму, но на выходе - всегда список.\n\nОбщая формула:\n\n`lapply(data, FUN)`\n\nАргументы:\n\n-   `data`: вектор или другой объект\n-   `FUN`: функцию, которую мы собираемся применять к каждому объекту x.\n\n`l` в функции `lapply()` обозначает `list` (список). Различия между `lapply()` и `apply()` заключаются именно в формате вывода.\n\nфункции `lapply()` не требуется аргумент MARGIN.\n\nПриведем примеры. Допустим, у нас есть список, в котором содержатся два элемента - вектор A и датафрейм B. Предположим, что нам нужно посчитать сумму по каждому элементу списка (отдельно у вектора и у датафрейма).\n\n```{r }\na <- list(A = c(8, 9, 7, 5),\n          B = data.frame(x = 1:5, y = c(5, 1, 0, 2, 3)))\na\nlapply(a, sum)\n```\n\nЕще один пример - со строковыми данными. Поменяем названия фильмов с большой буквы на маленькую.\n\n```{r }\nmovies <- c(\"SPYDERMAN\",\"BATMAN\",\"VERTIGO\",\"CHINATOWN\")\nmovies_lower <-lapply(movies, tolower)\nmovies\nmovies_lower\n```\n\nЧтобы значения из списка опять стали вектором, нужно применить функцию `unlist()`.\n\n```{r}\nunlist(movies_lower)\n```\n\n{{< iconify arcticons writer size=42px >}}**Самостоятельное задание**: создайте список из двух датафреймов, в каждом из которых содержалось бы по две переменных с 5 значениями. Затем примените функцию `lapply()` для того, чтобы поcчитать максимальные значения в каждом датафрейме (функция `max()`).\n\n### sapply()\n\nФункция `sapply()` используются со списками, векторами или датафреймами и на выходе дают вектор или матрицу. Функция полезна для операций над списками, она работает почти так же, как и `lapply()`, только возвращает вектор.\n\nПриведем пример с известным набором `cars`, в котором содержится информация о скорости и тормозном пути машин 1920-х гг.\n\nПрименим функцию `sapply()`, чтобы посчитать минимальные значения:\n\n```{r}\nsapply(cars, min)\n```\n\nСравним с `lapply()`:\n\n```{r}\nlapply(cars, min)\n```\n\n### tapply()\n\nФункции `tapply()` рассчитывает какой-либо показатель (среднее, моду, медиану, минимум, максимум и т.д.) или применяет пользовательскую функцию к каждому элементу вектора в зависимости от уровней факторной переменной. Очень полезная функция, позволяющая отобрать значения и применить функцию именно к ним (провести анализ по группам).\n\nОбщая формула:\n\n`tapply(data, INDEX, FUN = NULL, ...)`\n\nАргументы:\n\n-   `data`: данные, которые мы хотим агрегировать с помощью `tapply`\n-   `INDEX`: список факторов (группирующих переменных)\n-   `FUN`: функция, которую нужно применить к каждому элементу x\n-   `...`: другие аргументы, которые мы можем передать функции.\n\nВ процессе анализа данных очень часто возникает необходимость подсчета каких-либо показателей, например, посчитать средние значения в группах наблюдений, образованных на основе каких-либо характеристик. Примеры: проанализировать средний уровень доходов в зависимости от региона, страны, социального статуса и т.д.\n\nЧтобы понять, как это работает, давайте воспользумся датасетом `iris`, встроенным в базовый R, содержащий измерения 4 параметров (ширина и длина лепестков и чашелистников) у 150 цветков ирисов, принадлежащих к трем различным видам (по 50 каждого вида) - iris setosa (ирис щетинистый, iris versicolor (ирис разноцветный) и iris virginica (ирис виргинский):\n\n![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRScUmZqCyTspdxKSXGiS_BJKZdp9M059v-7eLoA2fs&s)\n\nЭто хорошо известный в сфере машинного обучения набор данных, который в используется, например, для иллюстрации того, как можно разработать модели, позволяющие предсказать принадлежность к одному из классов.\n\nМы можем использовать функцию `tapply()`, чтобы посчитать медианные значения ширины чашелистника для каждого вида:\n\n```{r}\ntapply(iris$Sepal.Width, iris$Species, median)# знак $ позволяет обратиться к отдельной переменной в наборе данных, Sepal.Width - переменная, хранящая значения ширины чашелистника, Species - переменная принадлежности к виду.\n```\n\n{{< iconify arcticons writer size=42px >}} **Самостоятельное задание**: попробуйте применить функцию `tapply()` к другим переменным набора - `Sepal.Length`, `Petal.Width`, `Petal.Length`, заменив медиану на максимальное значение (функция `max()`).\n\n## Пользовательские функции\n\nКроме встроенных или находящихся в загруженных библиотеках мы легко можем создавать свои собственные функции. Они могут быть достаточно специфическими и использоваться для решения различных задач. Если какое-то однотипное действие выполняется множетсво раз, стоит подумать о создании функции, которая может автоматизировать этот процесс. Однажды созданная функция может потом использоваться наравне со встроенными.\n\nРассмотрим некоторые особенности создания и использования пользовательских функций.\n\n### Пример простой функции\n\nПредположим, нам нужна функция, которая бы возводила в квадрат какое-то число:\n\n```{r}\nsquare<- function(a) {\n   return(a^2)\n}\t\n# Пробуем вызвать эту функцию, задав в качестве аргумента цифру 6.\nsquare(6)\n```\n\nДавайте посмотрим на то, как устроена эта функция.\n\n-   Первая строка:\n\n`square<- function(a) {`\n\nМы даем функции имя - **square** - оно должно нам подсказывать, что функция имеет дело с квадратами))) Впрочем, имя может быть любым, например, **my_function**.\n\nДалее следует оператор присваивания `<-` и ключевое слово `function`, за которым в скобках указывается какой-то аргумент, с которым будут далее происходить какие-то трансформации.\n\nМы видим, что в нашей функции аргумент один - `a`.\n\nЗаканчивается строка открывающейся фигурной скобкой.\n\nДалее следует **тело функции**.\n\n-   Вторая строка:\n\n`return(a^2)`\n\nПоскольку функция простая, мы сразу получаем **return value** - возвращаемое значение.\n\nОбратите внимание, что в конце функции обязательно ставится закрывающая фигурная скобка.\n\n### Вызов функции без аргумента\n\nРассмотрим еще один пример:\n\n```{r}\n# Создаем функцию без аргумента\nseq_squared5 <- function() {\n  seq<-1:5\n  return(seq^2)\n\n}\t\n\n# Запускаем функцию\nseq_squared5()\n```\n\nЧто изменилось? Изменилось то, в первой функции мы указывали аргумент, а во второй все вычисления сразу \"зашиты\" в нашу функцию и она может выполнять только одно дело - формировать последовательность от 1 до 5 и возводить каждое число в квадрат.\n\n### Создание функции с аргументами, различающимися по позиции и именам\n\nАргументы функции могут предоставляться в той же последовательности, в которой они написаны в функции, без указания имен, или в другой последовательности, но с обязательным указанием имени.\n\nРассмотрим пример функции, в которой есть три аргумента и которая выполняет следующие действия: первые два аргумента перемножаются, а затем к произведению прибавляется третий аргумент.\n\n```{r}\n# Создаем функцию с аргументами.\nfunction3 <- function(a,b,c) {\n   result <- a * b + c\n   print(result)\n}\n\n# Вызываем функцию, перечисляя аргументы по порядку.\nfunction3(5,3,11)\n\n# Вызываем фунцию, называя аргументы поименно.\nfunction3(a = 11, b = 5, c = 3)\n```\n\nПопробуйте поменять аргументы местами и посмотреть, как будет вести себя функция.\n\n### Создание функции с аргументами по умолчанию\n\nМы можем определить значение аргумента функции в ходе ее определения и запустить функцию без дополнительного назначения аргументов. В этом случае мы получим некоторый результат по умолчанию. Но мы можем изменить эти исходные значения, и получить новый результат.\n\nПростой пример такой функции:\n\n```{r}\n# Создаем новую функцию с аргументами.\nfunction4 <- function(a = 3, b = 6) {\n   result <- a * b\n   print(result)\n}\n\n# Запускаем функцию без аргументов в скобках.\nfunction4()\n\n# Вызываем функцию с новыми значениями аргументов.\nfunction4(9,5)\n```\n\n### \"Ленивая\" (Lazy) обработка аргументов функции\n\nАргументы в функции обрабатываются \"лениво\" (да-да, в жаргоне программистов есть именно такие выражения - \"ленивая функция\", \"ленивая загрузка\", \"ленивая обработка\"), что означает, что эти аргументы вызываются и обрабатываются только в определенный момент времени, когда это требует функция.\n\n```{r eval=FALSE}\n# Создаем функцию с двумя аргументами.\nnew.function <- function(a, b) {\n   print(a^2)\n   print(a)\n   print(b)\n}\n\n# Пробуем применить функцию только с одним аргументом.\nnew.function(6)\n```\n\nФункция требует два аргумента, но мы предоставили только один, и поскольку имен мы не указывали, по умлочанию наша функция определила этот аргумент как первый, то есть аргумент a. До определенного момента все было \"ок\", поскольку аргумент b не был нужен, но как только дело дошло до строчки print(b) - обнаружилось, что аргумент b отсутствует, и появилась ошибка.\n\n## Самостоятельная работа\n\n**Упражнение 1** Создайте функцию, которая будет возвращать сумму двух чисел. Назовите функцию `mysum`.\n\n**Упражнение 2** Создайте функцию, проверяющую принадлежность числа некоторому вектору. Если число в векторе содержится, функция должна вернуть `TRUE`.\n\n**Упражнение 3** Создайте функцию, на входе которой будет даваться датафрейм, а на выходе - наименование каждой переменной и тип (класс) данных, которые в них содержатся. Например, переменная1 числовая.\n\n**Упражнение 4** Создать функцию, аргументами которой являются вектор и число. На выходе функция должна показывать, сколько раз число встречается в данном векторе.\n","srcMarkdownNoYaml":"\n\nКроме того, что R является интерпретируемым языком, это еще и язык функционального программирования (ФП). Это означает, что R содержит множество инструментов для создания и манипулирования функциями. Более того, функции могут быть рассмотрены как [*объекты первого класса*](https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8_%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%B3%D0%BE_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0), то есть мы можем делать с функциями то же самое, что и с векторами: присваивать их переменным, сохранять их как списки, передавать в качестве аргументов другим функциям, создавать функции внутри функций и даже возвращать их в качестве результата.\n\nЗачем нам, социологам, уметь разбираться и писать собственные функции? Это важно по нескольким причинам. Во-первых, знание о том, как функции устроены, поможет нам использовать R более осознанно, с четким пониманием того, что происходит, когда мы запускаем ту или иную команду. Поначалу может казаться, что писать свои функции это нечто запредельное, что-то доступное только программистам или специалистам с техническим образованием. Но по мере того, как вы будете овладевать языком, писать больше кода и проводить анализ на R, вы поймете, что собственные, пусть и не очень сложные функции, могут помочь автоматизировать некоторые рутинные задачи (например, по перекодировке или чистке данных, создани. однотипных объектов, таких как таблицы или графики) и, в конечном итоге, сделают вашу работу в R быстрой и эффективной.\n\nТак, что же такое функция? Давайте разбираться.\n\n## Понятие функции и ее основные элементы\n\nФункция представляет собой набор утверждений, организованных вместе для выполнения определенной задачи.\n\nЭто часть программного кода, имеющий определенное имя, который может быть вызван сам по себе или в других частях программы.\n\n::: {.callout-note appearance=\"minimal\"}\nВ R имеется множество встроенных функций, и огромное количество дополнительных функций можно найти в различных библиотеках. Каждый пользователь может создавать свои собственные функции.\n:::\n\n::: {.callout-important appearance=\"minimal\"}\nФункция является объектом, и значит интерпретатор R может проверить, насколько хорошо функция выполняется, нужны ли функции какие-то аргументы для выполнения и есть ли у программы достаточно информации, чтобы все сделать так, как описано в функции.\n:::\n\n::: {.callout-note appearance=\"minimal\"}\nВ свою очередь функция выполняет задачу и выдает (возвращает, return) какие-то результаты, которые могут быть сохранены в дальнейшем как отдельные объекты.\n:::\n\n**Формула функции**\n\nВ R функция создается очень просто - с помощью ключевого слова `function`. Базовый синтаксис у функции следующий:\n\n```{r eval=F}\n\nfunction_name <- function(arg_1, arg_2, ...) {\n   Function body \n}\n```\n\n**Компоненты функции**\n\nУ функции есть несколько частей\n\n::: {.alert .alert-info role=\"alert\"}\n**Function Name (имя функции)** − тут все просто - это имя функции, которое хранится в окружении и обозначает конкретный объект (то есть саму функцию). Зная имя функции, ее можно вызвать в любое время и вставить в любую часть программного кода.\n:::\n\n::: {.alert .alert-danger role=\"alert\"}\n**Arguments (аргументы)** − это те элементы, параметры, значения, которые вводятся в функцию, чтобы она работала. Аргументы не являются обзательными, функция может иногда работать и без них, либо они могут быть указаны по умолчанию.\n:::\n\n::: {.alert .alert-success role=\"alert\"}\n**Function Body (тело функции)** − пожалуй, самая главная часть функции, содержащая утверждения, определяющие то, что именно делает данная функция.\n:::\n\n::: {.alert .alert-warning role=\"alert\"}\n**Return Value (возвращаемое значение)** − возвращаемое значение - это результат обработки последнего выражения в теле функции, то есть ее конечный результат. Если в функции заложено множество действий - то это последнее действие.\n:::\n\n## Встроенные функции\n\nМожно привести огромное количество базовых функций, таких как `seq()`, `mean()`, `max()`, `sum(x)`, `paste(...)` и т. д. Они вызываются напрямую при написании программы.\n\n```{r eval=F}\n# Создать последовательность чисел от 32 до 44\nseq(32,44)\n\n# Найти среднее чисел от 25 до 82.\nmean(25:82)\n\n# Найти сумму чисел от 41 до 68.\nsum(41:68)\n```\n\n## Функции apply(), lapply(), sapply(), tapply()\n\nСемейство функций `apply()` позволяет производить различные преобразования с отдельными элементами векторов, матриц и датафреймов. Такие действия в процессе анализа данных приходится проводить довольно часто. Например, нам может потребоваться сдвинуть значения переменных на какую либо константу, или провести трансформации, необходимые для нормализации данных.\n\n### apply()\n\nОбщая формула для функции `apply()`:\n\n`apply(data, MARGIN, FUN)`,\n\nГде:\n\n-   `data`: массив или матрица\n-   `MARGIN`: данный аргумент принимает значения 1 или 2\n-   `MARGIN=1`: манипуляции проводятся со строками\n-   `MARGIN=2`: манипуляции проводятся со столбцами\n-   `MARGIN=c(1,2)`: манипуляции проводятся со строками и столбцами одновременно\n-   `FUN`: функция, которую необходимо применить, например, рассчитать среднее `mean()`, медиану `median()`, сумму `sum()`, минимум `min()`, максимум `max()` и др. Также можно применить пользовательские функции.\n\nПростой пример применения данной функции - суммировать данные по столбцам (запустите код ниже и посмотрите на результат в последней строке):\n\n```{r eval=FALSE}\nm1 <- matrix(1:10,nrow=5, ncol=6)\nm1\na_m1 <- apply(m1, 2, sum)\n\na_m1\n```\n\n{{< iconify arcticons writer size=42px >}} **Самостоятельное задание**: попробуйте изменить код так, чтобы сумма считалась не по столбцу, а по строке.\n\n### lapply()\n\nФункция `lapply()` полезна для осуществления операций над списками и возвращает список объектов такой же длины. При этом каждый объект является результатом применения функции к элементу исходного списка. Эта функция может применяться к спискам, векторам или датафрейму, но на выходе - всегда список.\n\nОбщая формула:\n\n`lapply(data, FUN)`\n\nАргументы:\n\n-   `data`: вектор или другой объект\n-   `FUN`: функцию, которую мы собираемся применять к каждому объекту x.\n\n`l` в функции `lapply()` обозначает `list` (список). Различия между `lapply()` и `apply()` заключаются именно в формате вывода.\n\nфункции `lapply()` не требуется аргумент MARGIN.\n\nПриведем примеры. Допустим, у нас есть список, в котором содержатся два элемента - вектор A и датафрейм B. Предположим, что нам нужно посчитать сумму по каждому элементу списка (отдельно у вектора и у датафрейма).\n\n```{r }\na <- list(A = c(8, 9, 7, 5),\n          B = data.frame(x = 1:5, y = c(5, 1, 0, 2, 3)))\na\nlapply(a, sum)\n```\n\nЕще один пример - со строковыми данными. Поменяем названия фильмов с большой буквы на маленькую.\n\n```{r }\nmovies <- c(\"SPYDERMAN\",\"BATMAN\",\"VERTIGO\",\"CHINATOWN\")\nmovies_lower <-lapply(movies, tolower)\nmovies\nmovies_lower\n```\n\nЧтобы значения из списка опять стали вектором, нужно применить функцию `unlist()`.\n\n```{r}\nunlist(movies_lower)\n```\n\n{{< iconify arcticons writer size=42px >}}**Самостоятельное задание**: создайте список из двух датафреймов, в каждом из которых содержалось бы по две переменных с 5 значениями. Затем примените функцию `lapply()` для того, чтобы поcчитать максимальные значения в каждом датафрейме (функция `max()`).\n\n### sapply()\n\nФункция `sapply()` используются со списками, векторами или датафреймами и на выходе дают вектор или матрицу. Функция полезна для операций над списками, она работает почти так же, как и `lapply()`, только возвращает вектор.\n\nПриведем пример с известным набором `cars`, в котором содержится информация о скорости и тормозном пути машин 1920-х гг.\n\nПрименим функцию `sapply()`, чтобы посчитать минимальные значения:\n\n```{r}\nsapply(cars, min)\n```\n\nСравним с `lapply()`:\n\n```{r}\nlapply(cars, min)\n```\n\n### tapply()\n\nФункции `tapply()` рассчитывает какой-либо показатель (среднее, моду, медиану, минимум, максимум и т.д.) или применяет пользовательскую функцию к каждому элементу вектора в зависимости от уровней факторной переменной. Очень полезная функция, позволяющая отобрать значения и применить функцию именно к ним (провести анализ по группам).\n\nОбщая формула:\n\n`tapply(data, INDEX, FUN = NULL, ...)`\n\nАргументы:\n\n-   `data`: данные, которые мы хотим агрегировать с помощью `tapply`\n-   `INDEX`: список факторов (группирующих переменных)\n-   `FUN`: функция, которую нужно применить к каждому элементу x\n-   `...`: другие аргументы, которые мы можем передать функции.\n\nВ процессе анализа данных очень часто возникает необходимость подсчета каких-либо показателей, например, посчитать средние значения в группах наблюдений, образованных на основе каких-либо характеристик. Примеры: проанализировать средний уровень доходов в зависимости от региона, страны, социального статуса и т.д.\n\nЧтобы понять, как это работает, давайте воспользумся датасетом `iris`, встроенным в базовый R, содержащий измерения 4 параметров (ширина и длина лепестков и чашелистников) у 150 цветков ирисов, принадлежащих к трем различным видам (по 50 каждого вида) - iris setosa (ирис щетинистый, iris versicolor (ирис разноцветный) и iris virginica (ирис виргинский):\n\n![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRScUmZqCyTspdxKSXGiS_BJKZdp9M059v-7eLoA2fs&s)\n\nЭто хорошо известный в сфере машинного обучения набор данных, который в используется, например, для иллюстрации того, как можно разработать модели, позволяющие предсказать принадлежность к одному из классов.\n\nМы можем использовать функцию `tapply()`, чтобы посчитать медианные значения ширины чашелистника для каждого вида:\n\n```{r}\ntapply(iris$Sepal.Width, iris$Species, median)# знак $ позволяет обратиться к отдельной переменной в наборе данных, Sepal.Width - переменная, хранящая значения ширины чашелистника, Species - переменная принадлежности к виду.\n```\n\n{{< iconify arcticons writer size=42px >}} **Самостоятельное задание**: попробуйте применить функцию `tapply()` к другим переменным набора - `Sepal.Length`, `Petal.Width`, `Petal.Length`, заменив медиану на максимальное значение (функция `max()`).\n\n## Пользовательские функции\n\nКроме встроенных или находящихся в загруженных библиотеках мы легко можем создавать свои собственные функции. Они могут быть достаточно специфическими и использоваться для решения различных задач. Если какое-то однотипное действие выполняется множетсво раз, стоит подумать о создании функции, которая может автоматизировать этот процесс. Однажды созданная функция может потом использоваться наравне со встроенными.\n\nРассмотрим некоторые особенности создания и использования пользовательских функций.\n\n### Пример простой функции\n\nПредположим, нам нужна функция, которая бы возводила в квадрат какое-то число:\n\n```{r}\nsquare<- function(a) {\n   return(a^2)\n}\t\n# Пробуем вызвать эту функцию, задав в качестве аргумента цифру 6.\nsquare(6)\n```\n\nДавайте посмотрим на то, как устроена эта функция.\n\n-   Первая строка:\n\n`square<- function(a) {`\n\nМы даем функции имя - **square** - оно должно нам подсказывать, что функция имеет дело с квадратами))) Впрочем, имя может быть любым, например, **my_function**.\n\nДалее следует оператор присваивания `<-` и ключевое слово `function`, за которым в скобках указывается какой-то аргумент, с которым будут далее происходить какие-то трансформации.\n\nМы видим, что в нашей функции аргумент один - `a`.\n\nЗаканчивается строка открывающейся фигурной скобкой.\n\nДалее следует **тело функции**.\n\n-   Вторая строка:\n\n`return(a^2)`\n\nПоскольку функция простая, мы сразу получаем **return value** - возвращаемое значение.\n\nОбратите внимание, что в конце функции обязательно ставится закрывающая фигурная скобка.\n\n### Вызов функции без аргумента\n\nРассмотрим еще один пример:\n\n```{r}\n# Создаем функцию без аргумента\nseq_squared5 <- function() {\n  seq<-1:5\n  return(seq^2)\n\n}\t\n\n# Запускаем функцию\nseq_squared5()\n```\n\nЧто изменилось? Изменилось то, в первой функции мы указывали аргумент, а во второй все вычисления сразу \"зашиты\" в нашу функцию и она может выполнять только одно дело - формировать последовательность от 1 до 5 и возводить каждое число в квадрат.\n\n### Создание функции с аргументами, различающимися по позиции и именам\n\nАргументы функции могут предоставляться в той же последовательности, в которой они написаны в функции, без указания имен, или в другой последовательности, но с обязательным указанием имени.\n\nРассмотрим пример функции, в которой есть три аргумента и которая выполняет следующие действия: первые два аргумента перемножаются, а затем к произведению прибавляется третий аргумент.\n\n```{r}\n# Создаем функцию с аргументами.\nfunction3 <- function(a,b,c) {\n   result <- a * b + c\n   print(result)\n}\n\n# Вызываем функцию, перечисляя аргументы по порядку.\nfunction3(5,3,11)\n\n# Вызываем фунцию, называя аргументы поименно.\nfunction3(a = 11, b = 5, c = 3)\n```\n\nПопробуйте поменять аргументы местами и посмотреть, как будет вести себя функция.\n\n### Создание функции с аргументами по умолчанию\n\nМы можем определить значение аргумента функции в ходе ее определения и запустить функцию без дополнительного назначения аргументов. В этом случае мы получим некоторый результат по умолчанию. Но мы можем изменить эти исходные значения, и получить новый результат.\n\nПростой пример такой функции:\n\n```{r}\n# Создаем новую функцию с аргументами.\nfunction4 <- function(a = 3, b = 6) {\n   result <- a * b\n   print(result)\n}\n\n# Запускаем функцию без аргументов в скобках.\nfunction4()\n\n# Вызываем функцию с новыми значениями аргументов.\nfunction4(9,5)\n```\n\n### \"Ленивая\" (Lazy) обработка аргументов функции\n\nАргументы в функции обрабатываются \"лениво\" (да-да, в жаргоне программистов есть именно такие выражения - \"ленивая функция\", \"ленивая загрузка\", \"ленивая обработка\"), что означает, что эти аргументы вызываются и обрабатываются только в определенный момент времени, когда это требует функция.\n\n```{r eval=FALSE}\n# Создаем функцию с двумя аргументами.\nnew.function <- function(a, b) {\n   print(a^2)\n   print(a)\n   print(b)\n}\n\n# Пробуем применить функцию только с одним аргументом.\nnew.function(6)\n```\n\nФункция требует два аргумента, но мы предоставили только один, и поскольку имен мы не указывали, по умлочанию наша функция определила этот аргумент как первый, то есть аргумент a. До определенного момента все было \"ок\", поскольку аргумент b не был нужен, но как только дело дошло до строчки print(b) - обнаружилось, что аргумент b отсутствует, и появилась ошибка.\n\n## Самостоятельная работа\n\n**Упражнение 1** Создайте функцию, которая будет возвращать сумму двух чисел. Назовите функцию `mysum`.\n\n**Упражнение 2** Создайте функцию, проверяющую принадлежность числа некоторому вектору. Если число в векторе содержится, функция должна вернуть `TRUE`.\n\n**Упражнение 3** Создайте функцию, на входе которой будет даваться датафрейм, а на выходе - наименование каждой переменной и тип (класс) данных, которые в них содержатся. Например, переменная1 числовая.\n\n**Упражнение 4** Создать функцию, аргументами которой являются вектор и число. На выходе функция должна показывать, сколько раз число встречается в данном векторе.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["include/webex.css"],"include-after-body":["include/webex.js"],"embed-resources":false,"output-file":"Functions.html"},"language":{"toc-title-document":"Содержание","toc-title-website":"Содержание","related-formats-title":"Другие форматы","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Источник","other-links-title":"Другие ссылки","code-links-title":"Ссылки на код","launch-dev-container-title":"Запустить Dev Container","launch-binder-title":"Запустить Binder","article-notebook-label":"Блокнот статьи","notebook-preview-download":"Скачать блокнот","notebook-preview-download-src":"Скачать исходный код","notebook-preview-back":"Вернуться к статье","manuscript-meca-bundle":"Архив MECA","section-title-abstract":"Аннотация","section-title-appendices":"Приложения","section-title-footnotes":"Сноски","section-title-references":"использованная литература","section-title-reuse":"Повторное использование","section-title-copyright":"Авторские права","section-title-citation":"Цитата","appendix-attribution-cite-as":"Пожалуйста, цитируйте эту работу как:","appendix-attribution-bibtex":"BibTeX","appendix-view-license":"Просмотреть Лицензию","title-block-author-single":"Автор","title-block-author-plural":"Авторы","title-block-affiliation-single":"принадлежность","title-block-affiliation-plural":"Принадлежности","title-block-published":"Дата публикации","title-block-modified":"Файл изменен","title-block-keywords":"Ключевые слова","callout-tip-title":"Совет","callout-note-title":"Уведомление","callout-warning-title":"Предупреждение","callout-important-title":"Важное уведомление","callout-caution-title":"Осторожность","code-summary":"Код","code-tools-menu-caption":"Код","code-tools-show-all-code":"Развернуть код","code-tools-hide-all-code":"Скрыть код","code-tools-view-source":"Показать код","code-tools-source-code":"Исходный код","tools-share":"Share","tools-download":"Download","code-line":"Линия","code-lines":"Линии","copy-button-tooltip":"Скопировать текст","copy-button-tooltip-success":"Скопировано","repo-action-links-edit":"Редактировать страницу","repo-action-links-source":"Показать код","repo-action-links-issue":"Сообщить о проблеме","back-to-top":"Наверх","search-no-results-text":"Поиск не дал результатов","search-matching-documents-text":"Результаты поиска","search-copy-link-title":"Скопировать ссылку","search-hide-matches-text":"Скрыть дополнительные результаты","search-more-match-text":"дополнительный результат в этом документе","search-more-matches-text":"дополнительных результата(-ов) в этом документе","search-clear-button-title":"Очистить","search-text-placeholder":"","search-detached-cancel-button-title":"Отменить","search-submit-button-title":"Найти","search-label":"Поиск","toggle-section":"Переключить раздел","toggle-sidebar":"Переключить боковую панель навигации","toggle-dark-mode":"Переключить темный режим","toggle-reader-mode":"Переключить режим чтения","toggle-navigation":"Переключить навигацию","crossref-fig-title":"Рисунок","crossref-tbl-title":"Таблица","crossref-lst-title":"Список","crossref-thm-title":"Теорема","crossref-lem-title":"Лемма","crossref-cor-title":"Следствие","crossref-prp-title":"Утверждение","crossref-cnj-title":"Гипотеза","crossref-def-title":"Определение","crossref-exm-title":"Пример","crossref-exr-title":"Упражнение","crossref-ch-prefix":"Глава","crossref-apx-prefix":"Приложение","crossref-sec-prefix":"Глава","crossref-eq-prefix":"Уравнение","crossref-lof-title":"Список Иллюстраций","crossref-lot-title":"Список Таблиц","crossref-lol-title":"Список Каталогов","environment-proof-title":"Доказательство","environment-remark-title":"Примечание","environment-solution-title":"Решение","listing-page-order-by":"Сортировать по","listing-page-order-by-default":"предварительно выбранный","listing-page-order-by-date-asc":"Самый старый","listing-page-order-by-date-desc":"Новейшие","listing-page-order-by-number-desc":"нисходящий","listing-page-order-by-number-asc":"по возрастанию","listing-page-field-date":"Дата","listing-page-field-title":"Заголовок","listing-page-field-description":"Описание","listing-page-field-author":"Автор","listing-page-field-filename":"Имя файла","listing-page-field-filemodified":"Файл изменен","listing-page-field-subtitle":"Подзаголовок","listing-page-field-readingtime":"Время чтения","listing-page-field-wordcount":"Подсчет слов","listing-page-field-categories":"Категории","listing-page-minutes-compact":"{0} минут","listing-page-category-all":"Все","listing-page-no-matches":"Нет подходящих элементов","listing-page-words":"{0} слов","listing-page-filter":"Фильтр","draft":"Черновик"},"metadata":{"lang":"ru","fig-responsive":true,"quarto-version":"1.5.57","comments":{"hypothesis":true},"bibliography":["references.bib"],"editor":"visual","theme":"Pulse","title":"Основы функционального программирования"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}
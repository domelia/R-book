[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R в социологических исследованиях",
    "section": "",
    "text": "В качестве предисловия…\nЭто электронное пособие создано для магистрантов, обучающихся по направлению 39.04.01 «Социология», программа «Цифровые методы анализа и визуализации данных», и содержит обучающие материалы по дисциплине «Анализ данных в R», однако, возможно, оно будет интересно всем, кто хотел бы начать использовать R в качестве аналитического инструмента и выйти за рамки классических пакетов анализа и обработки данных, таких, например, как SPSS.\nЦель курса, равно как и настоящего издания, состоит в том, чтобы познакомить слушателей с основами языка, ключевыми командами, функциями и библиотеками, которые могут быть полезными в процессе организации, сбора данных и анализа результатов социологических исследований, и особенно - представления и распространения результатов.\nХотя R это язык программирования, мы в ходе освоения курса мы практически не будем использовать его в этом качестве, наша основная задача - стать уверенными пользователями R и использовать его для решения профессиональных социологических и учебных задач.\nЧему мы научимся:\n\nРаботать с различными структурами данных, испортировать и экспортировать данные в различных форматах;\nСоздавать несложные функции и понимать документацию к библиотекам;\nМодифицировать данные для исследовательских задач - создавать новые переменные, разъединять и соединять массивы;\nАнализировать результаты количественных социологических исследований и проверять статистические гипотезы, как простые, так и сложные, применять многомерные методы анализа;\nСоздавать визуализации на основе результатов исследования, создавать интерактивные отчеты и простые приложения, демонстрирующие возможности R в распространении научных публикаций.\n\nЧто осталось за кадром?\n\nМы не будем учиться создавать библиотеки и писать сложные функции;\nМы не сможем в полной мере охватить все методы анализа;\nВряд ли получится разобрать все инструменты для визуализации;\nЗа пределами нашего внимания останутся и возможности R по созданию сайтов, блогов и книг.\n\nОднако, и того, что запланировано, представляется хватит, для того, чтобы полюбить R и стать частью сообщества исследователей, использующих R в своей повседневной жизни для решения рутинных задач и поиска инновационных решений.\nМы начинаем!"
  },
  {
    "objectID": "About-R.html",
    "href": "About-R.html",
    "title": "1  Основные сведения об R",
    "section": "",
    "text": "2 Кое-что еще о разработчиках R\nКроме основной команды, в сообществе R выделяются талантливые программисты, которые разрабатывают библиотеки, без преувеличения производящие революцию в обработке и анализе данных. Это настоящие гуру, которых очень уважают в исследовательском сообществе, их имена знают все, кто работает в R. Ну, или почти все…\nТОП-3 по личному и очень субъективному мнению автора, которое основывается на его собственном опыте и может не совпадать с другими оценками, включает следующих разработчиков:\n1. Каким языком является R?\n2. Может ли R быть интегрирована с Hadoop для обработки больших данных? TRUEFALSE\n3. На основе какого языка создан R?"
  },
  {
    "objectID": "About-R.html#что-такое-r",
    "href": "About-R.html#что-такое-r",
    "title": "1  Основные сведения об R",
    "section": "1.1 Что такое R?",
    "text": "1.1 Что такое R?\nR – это язык программирования и свободная программная среда для статистической обработки и визуализации данных.\nНесмотря на наличие огромного количества языков и различных программ для статистической обработки данных, R в течение двух десятилетий остается популярным языком и средой обработки и анализа данных для специалистов из разных областей знания.\nПозиции языка R как средства разработки среди других языков программирования довольно высоки. Так, по данным индекса Tiobe за 2022 год, R занимал12-е место в мире, и хотя в 2024 году его авторитет заметно упал (23-е место), его используют миллионы аналитиков и разработчиков по всему миру:\n\nПрежде всего, это язык, который используют ученые, специалисты, работающие в различных отраслях экономики, менеджеры для анализа реальных данных и разработки научно обоснованных систем принятия решений, поэтому место в общем рейтинге не так высоко. Если посмотреть сферы использования, то на первом месте - академическая среда, на втором - сфера здравоохранения, на третьем - правительственные учреждения.\n\nR используют банки и маркетинговые агентства, технические компании и информационные корпорации для разных целей - от обработки данных до прогнозирования и представления интерактивной инфографики.\nВот только небольшой список тех компаний, которые используют R в своей деятельности."
  },
  {
    "objectID": "About-R.html#немного-истории",
    "href": "About-R.html#немного-истории",
    "title": "1  Основные сведения об R",
    "section": "1.2 Немного истории",
    "text": "1.2 Немного истории\nR был создан профессорами Россом Айхэка и Робертом Джентельменом (Ross Ihaka и Robert Gentleman) в 1992 году, сначала как язык программирования для обучения студентов статистике в университете Окленда (Новая Зеландия). Авторы вдохновлялись при создании языком S, используемым в лаборатории Bell, и ради шутки назвали язык R - по первым буквам собственных имен.\nВ июне 1995 года статистик Мартин Махлер убедил Айхэку и Джентельмена опубликовать R как язык со свободным исходным кодом под публичной лицензией GNU. Первая официальная версия была выпущена 29 февраля 2000 года.\nЧуть ранее, в 1997 году Куртом Хорником и Фрицем Лейшем была основана Сеть для архивирования кода R (CRAN, The Comprehensive R Archive Network), цель которой заключалась в хранении исходного кода, выполняемых файлов, документации и библиотек, создаваемых пользователями. На момент декабря 2022 года CRAN имел 103 зеркальных сервера и 18 976 библиотек.\nКоманда разработчиков (R Core Team) также была основана в 1997 году для дальнейшего развития языка. Сейчас в ней состоят ведующие разработчики, статистики, специалисты по компьютерным наукам, всего более 20 человек. В апреле 2003 года для развития проекта была создана некоммерческая организация R Foundation. Цель фонда заключается в предоставлении технической поддержки и коммуникации с создателями R, хранении и управлении технической документацией и интеллектуальной собственностью.\nПодробнее об истории создания R можно узнать из таймлайна: \nСоздатели R (Питер Далгаард - датский ученый, один из членов R Core Team):"
  },
  {
    "objectID": "About-R.html#каковы-преимущества-r",
    "href": "About-R.html#каковы-преимущества-r",
    "title": "1  Основные сведения об R",
    "section": "1.3 Каковы преимущества R?",
    "text": "1.3 Каковы преимущества R?\nИх довольно много:\n\nВозможности для статистической обработки, от простых функций до сложных моделей.\n\nПочти все новое, что появляется в области статистики, можно найти в одной из библиотек R. Например, ANZ банк использует R для моделирования невыплат по ипотечному кредитованию, а The Bank Of America применяет R для формирования финансовой отчетности.\n\nЭто язык программирования с открытым исходным кодом (Open-source)\n\nЧто это значит? Это значит, что, во-первых, все написанное на R открыто для изучения и критики, а, во-вторых, каждый может внести вклад в его развитие и улучшение путем создания новых библиотек и новых функций для решения различных задач.\n\nПоддержка сообщества (Community)\n\nУ R - более 2 миллионов пользователей по всему миру, сообщество пользователей R не только внушительное по размеру, но и очень активное. Каким бы ни был ваш проект - учебным или крупномасштабным, всегда найдется тот, кто поможет разобраться в коде и принять правильное решение. Вы тоже можете найти себе единомышленников и подключаться к другим проектам.\nНекоторые полезные ссылки:\n\nhttps://community.rstudio.com/\nhttps://www.r-bloggers.com/\nhttps://stackoverflow.com/questions/tagged/r\nhttps://rweekly.org/ https://www.reddit.com/r/Rlanguage/\nhttps://r.awesome-programming.com/en/awesome/r-language-02/community\n\nКоммьюнити пользователей R это совсем не Man’s World: весьма активно женское сообщество RLadies, устраивающее митапы по всему миру и продвигающее свой особый, женский, взгляд на использование R для разработки и анализа данных.\n\nОгромная коллекция библиотек и полезных функций, позволяющих расширить возможности базового языка\n\nСамые авторитетные хранятся в CRAN (Comprehensive R Archive Network), их более 10 тысяч, однако, чтобы попасть туда, необходимо, чтобы документация и код соответствовали определенным требованиям, что требует времени. До того момента, когда библиотека загружена на CRAN, она, как правило, хранится в открытом доступе, например, на github, где каждый желающий может принять участие в ее тестировании и доработке.\nПример сетевого анализа библиотек и их взаимозависимостей представлен на рисунке ниже:\n\nПримеры полезных библиотек:\n\nобработка и всевозможные манипуляции с данными (tidytverse)\nработа с большими данными (sparklyr)\nглубокое обучение (keras, TensorFlow)\nмашинное обучение (H2O)\nвизуализация данных (ggplot2)\nсоздание отчетов, итерактивная графика и обучение (Rmarkdown, shiny).\n\n\nСовместимость с другими языками программирования\n\nБольшинство функций и библиотек написаны на самом языке R. Однако, для сложных вычислительных задач, могут использоваться и другие языки, такие как C, C++, FORTRAN. Для манипуляций с объектами, возможно использование других языков - .NET, Java, Python. Иными словами, возможности программирования становятся практически безграничными.\n\nСоздание привлекательных визуализаций\n\nВ современном мире анализ данных невозможен без качественной визуализации, особенно если его результаты планируется использовать в сфере политики и бизнеса. R является одним из лучших инструментов для создания качественной графики, и такие библиотеки как ggplot2, plotly, ggvis помогут создать очень детализированные и эстетически привлекательные визуализации.\nДля пользователей R, которые только начинают изучение языка, на сайте https://r-graph-gallery.com создана галерея визуализаций, разбитых по отдельным тематикам. На основе простых и более сложных примеров можно изучить код и адаптировать его под собственные задачи.\n\n\nИнтеграция с Hadoop и анализ больших данных\n\nЕсли перед вами стоит задача анализа больших данных, то с такими библиотеками как rmr, rhdfs, rhbase, RHIVE, RHIPE и Rhadoop возможно интегрировать R и Hadoop (проект фонда Apache Software Foundation для разработки и выполнения распределённых вычислений для работы с большими данными).\nВозможности по хранению данных Hadoop и вычислительные достоинства R используют многие в качестве оптимального решения для анализа больших данных. Например, компания Форд использует R и Hadoop для обработки данных обратной связи с потребителями, что позволяет им улучшить дизайн и обосновывать бизнес решения.\n\n\nСоздание интерактивных веб-приложений\n\nС помощью R и библиотеки shiny можно создавать интерактивные приложения, с помощью которых пользователи (ученики, заказчики, журналисты и пр.) могут познакомиться с вашими данными, провести какие-то виды анализа, сделать визуализацию, возможно изучить какие-то закономерности (часто используются как обучающий инструмент). Эти приложения можно хранить на сервере Shiny или в другом доступном месте.\n\nПримеры можно посмотреть в галерее на сайте shiny: (https://shiny.posit.co/r/gallery/):\n\n\nСовместимость с другими платформами\n\nR может работать с любой конфигурацией оборудования и поддерживает различные операционные системы, независимо от окружения выдает предсказуемые и однозначные результаты.\n\nВозможность запуска кода без компилирования (возможно этот пункт стоило бы поставить на одно из первых мест)\n\nR относится к интерпретируемым языкам, что означает, что ему не требуется компилятор для того, чтобы программа заработала. Иными словами, все команды, которые мы вводим, сразу же выполняются, без дополнительного компилирования (сборки), как это происходит в других языках, например в C, COBOL, Delphi или Fortran. Другими возможностями, которыми обладают интерпретируемые языки, являются кросс-платформенность (способность работать в разных операционных системах и аппаратных средах), простота тестирования и отладки программ.\n\nНапример, Если мы создадим несколько строк кода и запустим их, они выполнятся немедленно и мы увидим результат:\n\nКроме этих преимуществ есть и много других, о которых мы узнаем в процессе изучения курса.\nК слову сказать, данное пособие также создано с помощью R. При его создании использовались возможности open-source системы публикации научной и технической информациии Quarto."
  },
  {
    "objectID": "Install-R.html#установка-r",
    "href": "Install-R.html#установка-r",
    "title": "2  Установка и начало работы с R",
    "section": "2.1 Установка R",
    "text": "2.1 Установка R\nПрежде, чем начать работать с R, нам нужно установить его себе на компьютер. Для этого необходимо перейти по ссылке и выбрать версию, подходящую для вашей операционной системы (ссылка ниже ведет на версию для Windows): https://cran.r-project.org/bin/windows/base/\nВместе с R устанавливается небольшая консоль, в которой можно набирать команды на R, но работать в ней не очень удобно, поэтому большинство пользователей предпочитает работать со специальным интерфейсом, или интегрированной средой разработки (Integrated Development Environement, IDE). Наиболее популярной IDE является RStudio (с другими средами, в которых можно работать в R, такими как Visual Studio, Emacs, Eclipse и другими, Вы можете познакомиться самостоятельно).\nЭто бесплатная программа, скачать которую можно по ссылке.\nhttps://posit.co/products/open-source/rstudio/\nШаги по установке не очень трудны и не потребуют каких-то особых навыков, но на всякий случай, можно обратиться к однму из обучающих видео:\nКак установить R:\n\nКак установить RStudio:\n\n\n\n\n\n\n\nУведомление\n\n\n\nВ комьютерных классах устанавливать ничего не нужно, эти инструкции пригодятся для домашнего использования.\n\n\n\n\n\n\n\n\nRStudio online\n\n\n\nКроме “стационарного” использования RStudio, компания Posit предоставляет возможность использования облачных технологий для работы с RStudio онлайн. Бесплатный план позволяет создать до 25 проектов и предоставляет 25 часов в месяц вычислительного времени. Этого будет достаточно для наших учебных проектов. Для получения доступа к Posit Cloud необходимо зарегистрироваться на сайте https://posit.cloud/ или войти с помощью социальных сетей и создать новый проект."
  },
  {
    "objectID": "Install-R.html#начало-работы-с-r-и-rstudio",
    "href": "Install-R.html#начало-работы-с-r-и-rstudio",
    "title": "2  Установка и начало работы с R",
    "section": "2.2 Начало работы с R и RStudio",
    "text": "2.2 Начало работы с R и RStudio\nПосле первого запуска RStudio вы, скорее всего, увидите вот такую картину:\n\nОсновное окно RStudio будет состоять из трех частей (экранов).\nСлева находится консоль (Console) - здесь можно писать код, и здесь же будут появляться результаты его выполнения, а также различные сообщения, с помощью которых R “общается” с пользователями.\nСправа сверху - рабочее окружение (Environment) - здесь хранятся создаваемые и загружаемые объекты - данные (вектора, датафреймы и пр.), пользовательские функции и некоторые другие объекты.\nОкружение является структурой данных, предназначенной для обеспечения области видимости. Это коллекция каких-то объектов (переменных, функций, массивов данных), которые мы используем. Хэдли Уикхэм предлагает относиться к окружению как к “мешку с именами”, :\n\nЕсть четыре типа окружений:\n\nГлобальное окружение - интерактивное пространство, где мы обычно работаем.\nБазовое окружение, создаваемое базовым пакетом R.\nПустое окружение, не имеющее никаких имен. Является в большей степени абстракцией, хотя и может быть создано с помощью специальной функции.\nТекущее окружение, то есть то, в котором мы работаем в какой-то момент времени.\nОбычно мы не задумываемся над тем, в каком окружении работаем. Это становится важным тогда, когда возникают конфликты функций и ошибки выполняемого кода. Окружение создается автоматически при запуске программы RStudio.\n\nВ этом же окне можно посмотреть историю (History) выполнения кода, и если вы случайно или специально что-то удалили, часто именно в истории можно найти строки, которые были выполнены, и их можно восстановить. Здесь есть некоторые другие вкладки, они нам понадобятся на более поздних этапах работы с R и RStudio.\nСправа снизу - окно просмотра. В отдельных вкладках можно посмотреть, какие файлы и папки есть в рабочей директории, какие библиотеки установлены, можно запросить помощь или посмотреть графики (в процессе анализа).\nЭто только в первый раз окна всего три.\nВыберите в меню File - New File - R Script:\n\nОткроется новый файл, и окон станет четыре:\n\nВ этом новом окне можно писать код и комментарии, сохранять его как отдельный файл с расширением .R, который можно запускать повторно, что очень удобно и позволяет значительно сохранить время при рутинной обработке данных. Очень часто в ходе обработки и анализа данных приходится осуществлять повторяющиеся действия, и скрипт поможет ускорить процесс обработки. В этом состоит основное отличие от консоли, где код можно запустить только однажды."
  },
  {
    "objectID": "Install-R.html#первые-простые-действия-в-r",
    "href": "Install-R.html#первые-простые-действия-в-r",
    "title": "2  Установка и начало работы с R",
    "section": "2.3 Первые простые действия в R",
    "text": "2.3 Первые простые действия в R\nВсе естественные языки содержат некоторые правила, описывающие то, как язык должен быть использован, и позволяющие носителям языка понимать друг друга без проблем.\nВ языках программирования, и в R, в частности, тоже есть такие правила, которые нужно соблюдать для того, чтобы компьютер понял, что от него требуется. В обычном языке правила иногда меняются или не соблюдаются, что не мешает людям понимать друг друга. С R, однако такой номер не пройдет, правила являются фиксированными, и требуется их неукоснительное соблюдение, чтобы не возникало ошибок.\nРассмотрим некоторые, самые базовые правила.\n\n2.3.1 Команды R\nКак большинство других языков программирования, R состоит из совокупности команд, формирующих последовательность инструкций, которые выполняет компьютер. Можно условно рассматривать такие команды в качестве глаголов, которые обозначают какие-то действия, которые выполняет R для получения определенного результата.\nНапример:\n\nprint(\"Привет, мир!\")\n\n[1] \"Привет, мир!\"\n\n\nЭта команда выполняет вывод на экран сообщения. Код на R обычно содержит множество команд, и обычно, каждая команда распологается на своей строке. Примеры:\n\nprint(\"Сегодня хорошая погода\")\n\n[1] \"Сегодня хорошая погода\"\n\nprint(1+1)\n\n[1] 2\n\nprint(4 &gt; 5)\n\n[1] FALSE\n\n\nПервая команда выводит сообщение, вторая - производит математические действия третья - оценивает истинность или ложность утверждения и выводит результат.\nОбычно каждая команда находится в своей строке, но можно их писать и в одну строку, разделяя точкой с запятой:\n\nx &lt;- 1+1; print(x); print(x^2)\n\n[1] 2\n\n\n[1] 4\n\n\nВ этом примере три команды приведены в одной строке. Первая команда создает переменную x, вторая выводит на экран значения этой переменной, третья - вычисляет квадрат значений переменной x и выводит результат на экран. Точка с запятой используется в качестве знака окончания команды и подсказывает R, где заканчивается одна команда и начинается другая. Если строка содержит только одну команду, точку с запятой можно не ставить, но если поставить, это не будет ошибкой:\n\nprint(\"Здесь нет точки с запятой\")\n\n[1] \"Здесь нет точки с запятой\"\n\nprint(\"А здесь есть точка с запятой\");\n\n[1] \"А здесь есть точка с запятой\"\n\n\n\n\n\n\n\n\nВажное уведомление\n\n\n\nЕсли включить несколько знаков точки с запятой, например, print(“hello”);;, ничего работать не будет!\n\n\nИтак, мы сейчас попробовали написать код по-разному - каждая команда в одной строке несколько команд в одной строке. А можно ли написать одну команду в несколько строк? Да, если в это сложная команда, в которой необходимо устанавливать несколько аргументов и такая разбивка часто используется для улучшения читаемости кода. Чуть ниже мы увидим, как это может быть.\nМожно также заключить часть кода в фигурные скобки, и тогда он будет восприниматься R как единое целое:\n\n{\n  print(\"Тут написан код, который воспринимается как единое целое\")\n  print(2^3 - 7)\n  w &lt;- \"hello\"\n  print(w)\n}\n\n[1] \"Тут написан код, который воспринимается как единое целое\"\n[1] 1\n[1] \"hello\"\n\n\nКод в примере выше оформлен с помощью отступов и так выглядит лучше, но это не обязательно. Можно обойтись и без этих отступов, все будет работать. Отступы (идентирование) никак не влияют на результат, а являются частью форматирования кода для улучшения его читабельности.\n\n{\nprint(\"Тут написан код, который воспринимается как единое целое\")\nprint(2^3 - 7)\nw &lt;- \"hello\"\nprint(w)\n}\n\n[1] \"Тут написан код, который воспринимается как единое целое\"\n[1] 1\n[1] \"hello\"\n\n\nЧто это ознчает - сгруппировать код? С практической точки зрения различий мало, но программа воспринимает эти несколько линий вместе и обрабатывает как бы как одну команду. Это в большей степени важно при написании программ на R.\n\n\n2.3.2 Полезные подсказки (shortcuts)\nВ R создано много удобных вещей, для того, чтобы написание кода было более приятным. Например, если выделить слово и нажать на знак кавычек, они поставятся сразу с двух сторон, то же происходит и со скобками.\nЕще одной удобной подсказкой является клавиша tab, которая работает с функциями и переменными. Начав набирать какую-то команду или переменную, можно нажать клавишу tab и выбрать из списка подходящий вариант, что экономит большое количество времени и позволяет избежать ошибок.\n\n\n2.3.3 Пустые строки\nПустые линии R игнорирует, но они позволяют организовать код и сделать его более читаемым:\n\nprint(\"Какое небо голубое!\")\n\n[1] \"Какое небо голубое!\"\n\n# Пустая строка есть, но она ничего не меняет\n\nprint(\"А трава зеленая!\")\n\n[1] \"А трава зеленая!\"\n\n\n\n\n2.3.4 ?\nВ R имеется очень много сопроводительной документации, доступной по каждой функции и библиотеке, где объясняются особенности работы с ними, приводятся примеры и дается теоретическое обоснование. Чтобы обратиться к этой вспомогательной документации достаточно набрать имя функции, перед которой нужно поставить знак вопроса:\n\n\nзапускаю httpd сервер помощи... готово\n\n\nЛучше всего эту команду попробовать в RStudio. Давайте сделаем это!\n\n\n2.3.5 ??\nЕсли вдруг вы забыли как точно называется та или иная функция или хотите посмотреть общие материалы по теме, то можно использовать ??.\n\n??print\n\n\n\n\n\n\n\nУведомление\n\n\n\nХотите узнать больше о синтаксисе R? Попробуйте набрать ?Syntax в консоли R и нажать на Enter.\n\n\n\n\n2.3.6 Самостоятельная работа\nДавайте создадим наш первый скрипт и сохраним его для истории 😄:\n\nВыберите в меню File - New File - R Script (если Вы этого еще не сделали) или нажать Ctrl + Shift + N.\nНапишите код, выполняющий простые арифметические действия. Наберите на клавиатуре любое математическое выражение, например, 1+1. Чтобы выполнить данную команду, нажмите сочетание клавиш Ctrl + Enter или кнопку Run, которая находится в правом углу меню. Команда выполняется автоматически, сразу же.\n\n\n1+1\n\n[1] 2\n\n\nПоэспериментируйте с R как с калькулятором, используя информацию об операторах, используемых для математических вычислений:\n\n\n\n\n\n\nКакие операторы используются для математических действий?\n\n\n\n\n\n\nОператор\nОписание\n\n\n+\nсложение\n\n\n-\nвычитание\n\n\n*\nумножение\n\n\n/\nделение\n\n\n^ или **\nвозведение в степень\n\n\nx %% y\nостаток от деления (x mod y) 5%%2 = 1\n\n\nx %/% y\nцелая часть при делени 5%/%2 =2\n\n\n\n\n\nЕсли мы что-то делаем неправильно, в консоли появится сообщение об ошибке:\n\n-1+a\n\n\n\n\n\n\n\nО пользе ошибок\n\n\n\nОшибок и предупреждающих сообщений бояться не надо, напротив, в таких сообщениях практически всегда находится ответ на вопрос, почему такая ошибка возникла, а часто - и возможное решение проблемы.\n\n\n\nНапишите код, отображающий текстовое сообщение:\n\n\n\"Привет, Алтайский государственный университет!\"\n\n[1] \"Привет, Алтайский государственный университет!\"\n\n\n\nСохраните файл. Файлы скрипта сохраняются с раширением .R, однако есть и другие форматы. Например, объекты, которые создаются в окружении, можно сохранить в формате .Rdata, а в файле .Rhistory может храниться информация о выполненном коде (что вы делали и в какой последовательности)."
  },
  {
    "objectID": "Install-R.html#работа-с-библиотеками",
    "href": "Install-R.html#работа-с-библиотеками",
    "title": "2  Установка и начало работы с R",
    "section": "2.4 Работа с библиотеками",
    "text": "2.4 Работа с библиотеками\nМы уже выяснили, что базовый язык R в настоящее время используется наряду с многочисленными функциями и библиотеками, разрабатываемыми коллективами ученых и разработчиками из разных стран мира, включая Россию.\nУстанавливать новые библиотеки нам придется практически на каждом занятии, поэтому лучше научиться делать это сразу.\nЭти библиотеки хранятся в основном в двух местах:\n\nCRAN\nGithub - нечто вроде социальной сети для программистов, где все друг друга знают, создают совместные проекты и делятся кодом.\n\n\n\n\n\n\n\nКое-что о библиотеке/пакетах\n\n\n\nМы называем “библиотеку” “библиотекой” и подразумеваем под ней набор каких-то полезных утилит, наборов данных и сопутствующей документации, потому что так принято в русскоязычном сегменте Интернета, посвященном программированию.\nОднако, по-английски библиотека называется package, то есть “пакет”, в котором “упакованы” функции, сопровождающие документы и иногда готовые данные, а вот функция, которая этот пакет подключает - `library()` – что собственно и переводится как библиотека, такой вот языковый казус. Об этом стоит помнить и слова эти не путать.\n\n\n\n2.4.1 Как установить библиотеку с помощью CRAN\nЧтобы скачать и установить нужную библиотеку с помощью CRAN, проще всего воспользоваться меню RStudio. Нужно выбрать пункт меню Tools - Install Packages:\n\nЗатем в окне Packages необходимо ввести имя нужной библиотеки, например, dplyr и нажать на кнопку Install. По умолчанию будет стоять “галочка” - Install Dependencies (установить зависимости) - убирать ее не надо, так как это позволить установить не только саму библиотеку, но и другие библиотеки, от которых она зависит и к которым обращается в ходе выполнения функций. В противном случае, могут возникать ошибки, а оно нам надо?\n\n\n\n2.4.2 Как установить библиотеку из Github\nНе все библиотеки доступны на CRAN, так как эта процедура достаточно сложная и строгая, предполагает несколько проверок (кода, сопроводительной документации). Достаточно частая практика, когда библиотека еще не подана для регистрации на CRAN, разработчики помещают ее на GitHub, откуда ее можно скачать и использовать по назначению. Это позволяет разработчикам получить обратную связь, устранять возможные ошибки, улучшать код.\nЧтобы установить нужную библиотеку из GitHub, нам понадобится функция install_github(), в которой мы должны указать имя разработчика и название библиотеки. Однако, чтобы выполнить эту функцию, нужна дополнительная библиотека devtools. Установить ее можно через CRAN с помощью описанного выше способа. А уже затем, загрузив ее, установить нужную нам библиотеку (получается сложновато, зато мы сразу научимся нужным действиям, потом мы доведем их до автоматизма):\n\nlibrary (devtools)\ninstall_github(\"DeveloperName/PackageName\")\n\n\n\n2.4.3 Вопросы для самопроверки\n1. Какой код нужно написать, чтобы подключить для использования уже установленную библиотеку tidyverse?\n\n library(tidyverse) install(tidyverse) package(tidyverse)\n\n2. Библиотека, используемая для установки пакетов с github:\n\n devtools dplyr tidyverse"
  },
  {
    "objectID": "Data-types-and-structures.html#типы-данных-в-r",
    "href": "Data-types-and-structures.html#типы-данных-в-r",
    "title": "3  Типы и структуры данных",
    "section": "3.1 Типы данных в R",
    "text": "3.1 Типы данных в R\nТип данных (встречается также термин «вид данных») — фундаментальное понятие теории программирования.\nТип данных определяет множество значений, набор операций, которые можно применять к таким значениям и способ реализации хранения значений и выполнения операций. Любые данные, которыми оперируют программы, относятся к определённым типам.\nR может хранить и обрабатывать различные виды информации и типы данных:\n\n\nЛогический (logical) – TRUE, FALSE – ИСТИНА, ЛОЖЬ.\n\n\n2&gt;3\n\n[1] FALSE\n\n\nМы можем присваивать логические значения в качестве значений переменных, используя полный или краткий вариант:\n\na&lt;-TRUE\nb&lt;-FALSE\n#Или\na&lt;-T\nb&lt;-F\n\nС логическим типом могут происходить интересные вещи, в частности, этот тип может рассматриваться как число. В таком случае TRUE принимается за 1, а FALSE как 0.\nИ если мы будем производить манипуляции над логическими значениями, в результате у нас будут числа!\nНапример:\n\nTRUE + TRUE  # TRUE считается как 1\n\n[1] 2\n\n\n\nFALSE * 7 # FALSE принимается за 0\n\n[1] 0\n\n\nИли, вот еще интересный пример:\n\n(2 &lt; 3) + (1 == 2)  # Что тут вообще происходит?\n\n[1] 1\n\n\nПочему получился именно такой результат?\n2 &lt; 3 - TRUE, то есть 1\n1 == 2 - FALSE, то есть 0\nTRUE+FALSE=1+0=1\n\nЧисловой (numeric) – целые и дробные, положительные и отрицательные.\n\n\nis.numeric(-5.6)\n\n[1] TRUE\n\na &lt;- -11\nb &lt;- 13.37\nc &lt;- 1/137\nclass(a)\n\n[1] \"numeric\"\n\nclass(b)\n\n[1] \"numeric\"\n\nclass(c)\n\n[1] \"numeric\"\n\n\nС числовыми переменными мы можем совершать различные математические операции:\n\na &lt;- -11\nb &lt;- 13.37\nc &lt;- 1/137\nprint(a+b*c)\n\n[1] -10.90241\n\nprint(a^2+sqrt(b)-c/5)\n\n[1] 124.655\n\n\n\nЦелое, целочисленное (integer) – целые числа, положительные и отрицательные\n\n\nx &lt;- pi * 23.5\nclass(x)\n\n[1] \"numeric\"\n\n#Проверим, является ли x целым числом\nis.integer(x)\n\n[1] FALSE\n\n#Создадим переменную y\ny&lt;-25L #при вводе, для того, чтобы R понял, что число именно целое, добавляется буква L\n#Проверим, является ли y целым числом\nis.integer(y)\n\n[1] TRUE\n\n#Проверим, является ли y числовой переменной\nis.numeric(y)\n\n[1] TRUE\n\n\n\nКомплексные (complex) – это уже абстрактная математика (числа состоящие из действительной (реальной) и мнимой части), например, 3+2i. Нам они вряд ли пригодятся, но на всякий случай запомним.\n\n\nz &lt;- 1:2 + 1i*(8:9)\nstr(z)\n\n cplx [1:2] 1+8i 2+9i\n\n\n\nТекстовые, строковые (character) – «Привет, мир!», «а», «4В»\n\n\ncolor&lt;-\"Red\"\nclass(color)\n\n[1] \"character\"\n\nis.character(color)\n\n[1] TRUE\n\n\nВозможные варианты написания:\n\nd &lt;- \"Hello\"         # С помощью двойных кавычек \ne &lt;- 'how are you?'  # С помощью одинарных кавычек\nd\n\n[1] \"Hello\"\n\ne\n\n[1] \"how are you?\"\n\n\nОднако, нельзя использовать и те, и другие сразу, будет ошибка:\n\nf &lt;- \"Так работать не будет' \n\nИногда вместо текста нет ничего, но это все равно будет строковая переменная (пустая строка):\n\nh &lt;- \"\"              # Это пустая строка!\n\nС числовыми переменными мы можем совершать различные операции, что же делать со строковыми переменными? К ним тоже можно применять разные функции, и их довольно много. Вот некоторые:\nПосчитаем количество символов в строке:\n\ng&lt;-\"Как упоительны в России вечера!\"\nnchar(g)\n\n[1] 31\n\n\nЕсли нам нужен какой-то определенный фрагмент текста, мы можем его “вытащить” оттуда:\n\ng&lt;-\"Как упоительны в России вечера!\"\nsubstr(g, 4, 25) \n\n[1] \" упоительны в России в\"\n\n\nДовольно часто при анализе текстовых данных их нужно разделить на отдельные кусочки:\n\ng&lt;-\"Как упоительны в России вечера!\"\nstrsplit(g, \" \")   \n\n[[1]]\n[1] \"Как\"        \"упоительны\" \"в\"          \"России\"     \"вечера!\"   \n\n\nВ данном случае мы использовали пробел в качестве разделителя.\n\nФакторные переменные (factor) – могут быть строковыми и числовыми, задают уровни или как правило являются номинальными переменными: пол, семейный статус, цвет волос и т. д., служат категоризации\n\n\nx &lt;- c(\"single\",\"married\",\"married\",\"single\")\nclass(x)\n\n[1] \"character\"\n\n\nfactor () - функция, которая создает факторные переменные. Аргумент levels используется для обозначения уровней (порядка, если он нужен).\n\nx &lt;- factor(c(\"single\", \"married\", \"married\", \"single\"), levels = c(\"single\", \"married\", \"divorced\"))\nclass(x)\n\n[1] \"factor\"\n\nstr(x)# функция str() дает больше информации о переменной, не только какого она типа, но сколько элементов содержит, какие в ней значения, уровни и т. д.\n\n Factor w/ 3 levels \"single\",\"married\",..: 1 2 2 1\n\n\nas.factor() - данная функция превращает в факторный тип переменные другого типа, даже если они числовые.\n\ncolors&lt;-c(\"red\", \"yellow\", \"green\")\ncolors&lt;-as.factor(colors)\nstr(colors)\n\n Factor w/ 3 levels \"green\",\"red\",..: 2 3 1\n\n\nПример порядковой переменной с уровнями:\n\nstatus &lt;- c(\"Poor\", \"Middle-class\", \"Rich\")\nstatus &lt;- factor(status, ordered=TRUE) # ordered=TRUE - делает переменную не просто категориальной, но и порядковой\nstr(status)\n\n Ord.factor w/ 3 levels \"Middle-class\"&lt;..: 2 1 3\n\n\nПолучилось не совсем то, что нам нужно, так как программа автоматически отсортировывает по алфавиту. Чтобы поменять порядок, нужно задать уровни “принудительно”:\n\nstatus &lt;- c(\"Poor\", \"Middle-class\", \"Rich\")\nstatus &lt;- factor(status, order=TRUE,levels=c(\"Poor\", \"Middle-class\", \"Rich\"))\nstr(status)\n\n Ord.factor w/ 3 levels \"Poor\"&lt;\"Middle-class\"&lt;..: 1 2 3\n\n\n\n3.1.1 Вопросы для самопроверки\n1. К какому типу переменных относится число -3,5?\n\n numeric character complex integer\n\n2. Какой результат получится, если попытаться превратить в число строковую переменную?\n\n NA TRUE NAs introduced by coercion\n\n3. Какая функция используется для проверки принадлежности переменной к факторному типу?\n\n is.factor() as.factor() factor()\n\n4. Могут ли логические переменные быть представлены в числовом виде?\n\n Да() Нет Затрудняюсь ответить\n\n\n\n3.1.2 Самостоятельная работа\nСамостоятельная работа № 1"
  },
  {
    "objectID": "Data-types-and-structures.html#структуры-данных",
    "href": "Data-types-and-structures.html#структуры-данных",
    "title": "3  Типы и структуры данных",
    "section": "3.2 Структуры данных",
    "text": "3.2 Структуры данных\nСтруктура данных — это способ организации информации для более эффективного использования. В программировании структурой обычно называют набор данных, связанных определённым образом.\nОсновные структуры данных в R это векторы, матрицы, массивы, списки и таблицы данных.\nРассмотрим их подробнее.\n\n\n3.2.1 Векторы\n\nВектор – одномерный массив проиндексированных (пронумерованных) элементов, набор однотипных элементов (либо числа, либо буквы) без их сочетания. Векторы могут быть такими же, как и типы данных - числовыми, строковыми, логическими и пр.\n\nВот пример того, как можно создать числовой вектор, содержащий числа от 1 до 10:\n\nx&lt;-1:10\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nА вот так - вектор с текстовыми элементами:\n\ny&lt;-c(\"Красный\", \"Синий\", \"Желтый\")\ny\n\n[1] \"Красный\" \"Синий\"   \"Желтый\" \n\n\nЗаметьте, чтобы создать вектор с наименованиями цветов, мы использовали функцию c(), в которой c является производной отcombine. В этом есть смысл, поскольку мы соединяем, как бы “комбинируем”, несколько числовых или текстовых объектов в один ряд.\n\n\n\n\n\n\nПро имена (важно!)\n\n\n\nКак назвать вектор (да и другие структуры данных) правильно? Есть несколько простых правил. Имя может содержать:\n\nбуквы\nчисла\nточку или символ «подчеркивания” (_)\n\nи обязательно должно начинаться с буквы или точки, но за точкой нельзя поставить цифру.\nТак, например, имя “.2b” не является валидным, а “.b2” - вполне годится для именования.\nНельзя также использовать в именах зарезервированные слова,такие как if,else, repeat, while, function, for, in, next, break, TRUE, FALSE, NULL, Inf, NaN, NA, NA_integer_, NA_real_, NA_complex_, NA_character_ некоторых других, которые являются базовыми конструкциями языка и используются в качестве аргументов при вызове функций.\n\n\nНапример, если мы попробуем создать вот такой вектор, то программа выдаст ошибку:\n\nbreak&lt;-1:5\n\nError in break &lt;- 1:5: неправильная (NULL) левая сторона присваивания\n\n\nДлину числового вектора можно определить с помощью функции length():\n\nx&lt;-1:3\nlength(x)\n\n[1] 3\n\n\nФункция class() помогает определить, какой тип данных хранится в векторе. Напомним, что вектор содержит данные одного типа.\n\nx&lt;-c(1:3)\nclass(x)\n\n[1] \"integer\"\n\n\nЕще примеры создания логических и текстовых векторов:\n\ny &lt;- c(TRUE, TRUE, FALSE, TRUE)\nz &lt;- c(\"to\", \"be\", \"or\", \"not\", \"to\", \"be\") \nclass(y)\n\n[1] \"logical\"\n\nlength(y)\n\n[1] 4\n\nclass(z)\n\n[1] \"character\"\n\nlength(z)\n\n[1] 6\n\n\n\n\n\n\n\n\nВажное уведомление\n\n\n\nЕсли мы попытаемся соединить два вектора - числовой и строковый - то цифры “превратятся” в буквы, поскольку R автоматически переведет все элементы к наиболее подходящему общему типу данных. Поскольку слова в цифры превратить нельзя, то таким общим типом будет строковый.\n\n\n\nx&lt;-c(1:10)\ny&lt;-c(\"Красный\", \"Синий\", \"Желтый\")\nz&lt;-c(x,y)\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\ny\n\n[1] \"Красный\" \"Синий\"   \"Желтый\" \n\nz\n\n [1] \"1\"       \"2\"       \"3\"       \"4\"       \"5\"       \"6\"       \"7\"      \n [8] \"8\"       \"9\"       \"10\"      \"Красный\" \"Синий\"   \"Желтый\" \n\n\nТо, что произошло в коде выше, называется конверсией типов. Такая конверсия случается тогда, когда элементы вектора разные. Запомниим, что вектор всегда хранит данные только одного типа!\nЗадание. Попробуйте создать вектор, сочетающий числовые, строковые и логические значения:\nА что будет, если мы соединим вместе логические и числовые?\n\nx&lt;-c(TRUE, 5, FALSE, 6)\nx\n\n[1] 1 5 0 6\n\n\nМы можем также создавать “пустые” вектора, обозначая только тип данных, и сколько элементов в них содержится.\nНапример:\n\nempty &lt;- numeric(10)   # Создаем пустой числовой вектор с 10 элементами\nprint(empty)\n\n [1] 0 0 0 0 0 0 0 0 0 0\n\n\nЗаметьте, что даже если мы не просили R внести какие-то значения, в числовом векторе всем элементам автоматически были присвоены нули - значение по умолчанию.\nВот таким образом можно создать пустые вектора других типов:\n\nempty_int &lt;- integer(45)   # числовой вектор с 45 элементами\nempty_cha &lt;- character(2)  # строковый вектор с 2 элементами\nempty_log &lt;- logical(1000)    # логический вектор с 1000 элементами\n\nPfПопробуйте в RStudio создать эти вектора и посмотреть их. Обратите внимание, какие значения по умолчанию присваиваются в логическом и строковом векторах!\n\n3.2.1.1 Адресация и изменение элементов вектора\nПосле того, как вектор создан, как мы можем посмотреть или изменить его элементы. Это сделать достаточно просто:\nПоменять элемент в векторе:\n\na &lt;- c(1, 2, 3)  # Создадим числовой вектор с 3 элементами\na[2] &lt;- 4        # Изменим значение второго элемента на 4\na                # Посмотрим, что получилось\n\n[1] 1 4 3\n\n\nКак вы уже догадались, чтобы обратиться к какому-то элементу вектора, нужно набрать его порядковый номер в квадратных скобках [ порядковыйномер ]:\n\na &lt;- c(1, 2, 3)  # Создадим числовой вектор с 3 элементами\na[3]             # Попросим R вывести третий элемент\n\n[1] 3\n\n\nКак вы думаете, что будет если запустить следующий код? Каким будет результат?\n\nvec &lt;- c(4, 5, 6)\nvec[3] == 6\n\nДогадались? Попробуйте теперь запустить этот код и проверить, правы вы или нет:\n\n\n3.2.1.2 Операции над векторами\nС векторами можно производить большое количество действий, которые позволяют те типы данных, которые в них содержатся.\nПроще всего совершать арифметические действия:\n\na &lt;- 3   # Создаем единичный числовой объект\na + 4  # Прибавляем к нему константу\n\n[1] 7\n\n\nМы можем прибавить число не только к другому числу, но и ко всему вектору:\n\na &lt;- c(1, 2, 3)   # Создаем числовой вектор\na + 4   # Прибавляем к нему константу\n\n[1] 5 6 7\n\n\nТакой тип “поведения” программы называется поэлементным. То есть операция производится над каждым элементом по отдельности.\nЕще примеры:\n\na &lt;- c(1, 2, 3)\na - 3 \n\n[1] -2 -1  0\n\na * 1.5\n\n[1] 1.5 3.0 4.5\n\na ^ 2\n\n[1] 1 4 9\n\na == 2\n\n[1] FALSE  TRUE FALSE\n\n\nВ последнем случае мы сравнивали каждый элемент со значением два и в результате получили новый вектор, состоящий из логических значений.\nВ R имеется много различных функций для трансформации, мы с ними будем активно работать на следующих занятиях. Но самая простая функциюя - sum(), которая просто складывает все элементы вектора вместе:\n\na &lt;- c(1, 2, 3)\nsum(a)\n\n[1] 6\n\n\nНекоторые операции можно производить над векторами, если у них одинаковая длина:\n\na &lt;- c(1, 2, 3)\nb &lt;- c(1, 0, 1)\na + b\n\n[1] 2 2 4\n\nb * a\n\n[1] 1 0 3\n\na ^ b\n\n[1] 1 1 3\n\n\nМы можем даже сравнить два вектора и сохранить результат в отдельном логическом векторе\n\na &lt;- c(1, 2, 3)\nb &lt;- c(1, 0, 1)\nz &lt;- a &gt; b   # сравниваем a и b, поэлементно, результат сохраняем в векторе z\nz\n\n[1] FALSE  TRUE  TRUE\n\nz == TRUE\n\n[1] FALSE  TRUE  TRUE\n\nz == FALSE\n\n[1]  TRUE FALSE FALSE\n\n!z #выдает противоположное значение\n\n[1]  TRUE FALSE FALSE\n\n\nА что можно делать со строковыми векторами?\nДавайте создадим пару векторов и попробуем с ними совершить какие-нибудь действия, например, сравним их попарно:\n\na &lt;- c(\"собака\", \"молоко\", \"квартира\", \"чай\", \"морозы\", \"душа\")\nb &lt;- c(\"собака\", \"мыло\", \"сахар\", \"чай\", \"малина\", \"душа\")\na==b\n\n[1]  TRUE FALSE FALSE  TRUE FALSE  TRUE\n\n\nЧтобы найти какой-то текстовый элемент и его место в векторе, можно использовать функцию grep():\n\na &lt;- c(\"собака\", \"молоко\", \"квартира\", \"чай\", \"морозы\", \"квартира\", \"душа\")\ngrep(\"квартира\", a)\n\n[1] 3 6\n\n\nРезультат показывает, что слово “квартира” встречается два раза, это третий и шестой элементы. Что будет, если поищем то, чего нет?\n\na &lt;- c(\"собака\", \"молоко\", \"квартира\", \"чай\", \"морозы\", \"квартира\", \"душа\")\ngrep(\"редиска\", a)\n\ninteger(0)\n\n\nЕсли вектора разного типа, то иногда с ними можно что-то сделать, иногда нет, зависит от типа данных:\n\na &lt;- c(1, 2, 3)\nb &lt;- c(\"one\", \"two\", \"three\")\nc &lt;- c(TRUE, TRUE, FALSE)\na+b\n\nНичего не получилось, потому что нельзя к словам прибавлять числа. А вот если сложить вектора a и c, все получится:\n\na &lt;- c(1, 2, 3)\nb &lt;- c(\"one\", \"two\", \"three\")\nc &lt;- c(TRUE, TRUE, FALSE)\na+c\n\n[1] 2 3 3\n\n\n\n\n3.2.1.3 Некторые полезные функции для работы с векторами\n\nСоздать вектор случайных чисел в определенном диапазоне:\n\n\nx &lt;- runif(10, min = -5, max = 5)\nx\n\n [1] -4.096611  1.397574 -2.495688 -3.121695 -3.888329 -2.078532  3.579407\n [8] -3.029510  2.813190 -2.335206\n\n\n\nСоздать вектор с повторяющимися значениями с помощью функции rep() – повторить (что, сколько раз):\n\n\nb&lt;- rep(c(1,2,3),4)\nb\n\n [1] 1 2 3 1 2 3 1 2 3 1 2 3\n\n\n\nСоздать вектор из повторяющихся значений определенной длины с помощью функции rep() – повторить (что, до каких пор, какой длины):\n\n\nc&lt;- rep(c(4,5,6), length.out=10)\nc\n\n [1] 4 5 6 4 5 6 4 5 6 4\n\n\n\nСоздать вектор через последовательность определенных значений с помощью функции seq() – задать последовательность (от, до, с каким шагом)\n\n\nseq &lt;- seq(from=2,to=15,by=0.5)\nseq\n\n [1]  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5  7.0  7.5  8.0  8.5  9.0\n[16]  9.5 10.0 10.5 11.0 11.5 12.0 12.5 13.0 13.5 14.0 14.5 15.0\n\n\n\nПроверить, является ли какой-то объект вектором с помощью функции is.vector() :\n\n\nseq &lt;- seq(from=2,to=15,by=0.5)\nis.vector(seq)\n\n[1] TRUE\n\n\n\nПроверить, удовлетворяет ли хотя бы один элемент вектора какому-либо условию с помощью функции any():\n\n\nvec &lt;- as.integer(c(34,23,53,42,16,42,64,32,76))\nany(vec,vec&gt;50)\n\n[1] TRUE\n\n\n\nПроверить, удовлетворяют ли все элементы вектора какому-либо условию с помощью функции all():\n\n\nvec &lt;- as.integer(c(34,23,53,42,16,42,64,32,76))\nall(vec,vec&gt;10)\n\n[1] TRUE\n\n\n\nПрименить какую-либо функцию преобразования ко всем элементам вектора с помощью функции sapply():\n\n\nvec &lt;- as.integer(c(34,23,53,42,16,42,64,32,76))\nvec3&lt;-sapply(vec, sqrt)\nvec3\n\n[1] 5.830952 4.795832 7.280110 6.480741 4.000000 6.480741 8.000000 5.656854\n[9] 8.717798\n\n\nВ принципе, можно это сделать и проще:\n\nvec &lt;- as.integer(c(34,23,53,42,16,42,64,32,76))\nsqrt(vec)\n\n[1] 5.830952 4.795832 7.280110 6.480741 4.000000 6.480741 8.000000 5.656854\n[9] 8.717798\n\n\nНо иногда, когда у нас не вектор, а более сложный объект, функция sapply() и ее родные сестры apply() и lapply()часто очень выручают. Подробнее эти функции будут рассмотрены на следующих занятиях.\n\n\n\n3.2.2 Матрицы\n\nМатрица – двумерная совокупность числовых, логических или текстовых величин. Чтобы создать матрицу, нужно воспользоваться функцией matrix(). Можно думать о матрице как о решетке каких-то числовых величин.\n\nПростой пример:\n\ndata &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA &lt;- matrix(data, ncol=3, nrow=3)\nA\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n\nМы создали матрицу с тремя строками и тремя колонками на основе данных, изначально хранящихся в виде числового вектора.\n\n\n\n\n\n\nВажное уведомление\n\n\n\nR заполняет матрицу сверху вниз, колонку за колонкой, двигаясь справа налево.\n\n\nЕсли мы хотим это изменить, нужно поменять параметр byrow:\n\ndata &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA &lt;- matrix(data, ncol=3, nrow=3, byrow = T)\nA\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n\n\n\n3.2.2.1 Полезные функции и операции над матрицами\n\nКак обратиться к одному из элементов матрицы? В случае с вектором мы задавали один элемент в квадратных скобках, а что теперь? Матрица - двумерный объект, поэтому мы должны теперь в квадратных скобках задать две координаты - номер строки (первое число) и номер колонки (второе число) - через запятую:\n\n\ndata &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA &lt;- matrix(data, ncol=3, nrow=3, byrow = T)\nA\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n\nA[1,1] # Первый элемент первой строки\n\n[1] 1\n\nA[2,3] # Третий элемент второй строки\n\n[1] 6\n\nA[1,]  # Первая строка полностью\n\n[1] 1 2 3\n\nA[,3]  # Третий столбец полностью\n\n[1] 3 6 9\n\n\nЧтобы получить диагональные элементы, есть специальная функция - diag()\n\ndata &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA &lt;- matrix(data, ncol=3, nrow=3, byrow = T)\ndiag(A)\n\n[1] 1 5 9\n\n\nЧтобы узнать размерность матрицы (количество строк и столбцов) - можно использовать функцию dim():\n\ndata &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA &lt;- matrix(data, ncol=3, nrow=3, byrow = T)\ndim(A)\n\n[1] 3 3\n\n\nВ результате применения функции мы получаем числовой вектор, первое значение в котором обозначает количество строк, второе - столбцов.\nЗадание: воспроизведите еще раз матрицу A и напишите код, позволяющий получить произведение первого элемента второй строки и третьего элемента третьей строки.\nС матрицами, как и с векторами, можно совершать разные математические операции - сложение, умножение, вычитание и т.д.:\n\nНапример, прибавить единицу к каждому элементу матрицы:\n\n\ndata &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA &lt;- matrix(data, ncol=3, nrow=3, byrow = T)\nA\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n\nA+1   \n\n     [,1] [,2] [,3]\n[1,]    2    3    4\n[2,]    5    6    7\n[3,]    8    9   10\n\n\n\nУмножить каждый элемент на 2:\n\n\ndata &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA &lt;- matrix(data, ncol=3, nrow=3, byrow = T)\nA\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n\nA*2\n\n     [,1] [,2] [,3]\n[1,]    2    4    6\n[2,]    8   10   12\n[3,]   14   16   18\n\n\n\nВозвести в квадрат:\n\n\ndata &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA &lt;- matrix(data, ncol=3, nrow=3, byrow = T)\nA\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n\nA^2\n\n     [,1] [,2] [,3]\n[1,]    1    4    9\n[2,]   16   25   36\n[3,]   49   64   81\n\n\n\nДовольно часто возникает необходимость транспонирования, когда строки становятся столбцами и наоборот:\n\n\ndata &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA &lt;- matrix(data, ncol=3, nrow=3, byrow = T)\nA\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n\nt(A)\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n\n\nНайдти след матрицы\n\nСлед матрицы - это сумма диагональных элементов:\n\ndata &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA &lt;- matrix(data, ncol=3, nrow=3, byrow = T)\nsum(diag(A))\n\n[1] 15\n\n\n\nСложить две матрицы\n\n\ndata &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA &lt;- matrix(data, ncol=3, nrow=3, byrow = T)\nB &lt;- matrix(1, 3, 3)\nA + B\n\n     [,1] [,2] [,3]\n[1,]    2    3    4\n[2,]    5    6    7\n[3,]    8    9   10\n\n\nЗаметьте, как мы это сделали: мы создали матрицу В одной строкой (матрица 3*3, состоящая из одних единиц).\n\nПеремножить элементы двух матриц:\n\n\ndata &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA &lt;- matrix(data, ncol=3, nrow=3, byrow = T)\nB &lt;- matrix(2, 3, 3)\nA * B\n\n     [,1] [,2] [,3]\n[1,]    2    4    6\n[2,]    8   10   12\n[3,]   14   16   18\n\n\n\nОсуществить матричное умножение:\n\n\ndata &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA &lt;- matrix(data, ncol=3, nrow=3, byrow = T)\nB &lt;- matrix(2, 3, 3)\nA %*%  B\n\n     [,1] [,2] [,3]\n[1,]   12   12   12\n[2,]   30   30   30\n[3,]   48   48   48\n\n\nВ чем разница между двумя умножениями? В первом случае элементы поэлементно умножаются друг на друга, во втором - происходит умножение матриц по законам линейной алгебры.\nЗадание. Воспроизведите матрицу А из примера выше и осуществите матричное умножение между матрицей А и транспонированной матрицей А.\n\n\n\n3.2.3 Массивы\n\nМассив (array) – объект в R, в котором хранится данные, содержащие более двух измерений. Например, если мы создадим массив с параметрами (2, 3, 4), у нас получится 4 прямоугольные матрицы размером 2 на 3. В массивах хранятся данные только одного типа.\n\nДля того, чтобы создать массив, есть специальная функция array(). Она принимает на входе вектора и использует значения параметра dim, чтобы создать массив.\nПример:\n\nvector1 &lt;- c(5,9,3)\nvector2 &lt;- c(10,11,12,13,14,15)\narr1 &lt;- array(c(vector1,vector2),dim = c(3,3,2))\narr1\n\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    5   10   13\n[2,]    9   11   14\n[3,]    3   12   15\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    5   10   13\n[2,]    9   11   14\n[3,]    3   12   15\n\n\nМы можем присвоить имена строкам, колонкам и матрицам массива с помощью параметра dimnames:\n\nvector1 &lt;- c(5,9,3)\nvector2 &lt;- c(10,11,12,13,14,15)\ncolumn.names &lt;- c(\"COL1\",\"COL2\",\"COL3\")\nrow.names &lt;- c(\"ROW1\",\"ROW2\",\"ROW3\")\nmatrix.names &lt;- c(\"Matrix1\",\"Matrix2\")\nresult &lt;- array(c(vector1,vector2),dim = c(3,3,2),dimnames = list(row.names,column.names,\n   matrix.names))\nresult\n\n, , Matrix1\n\n     COL1 COL2 COL3\nROW1    5   10   13\nROW2    9   11   14\nROW3    3   12   15\n\n, , Matrix2\n\n     COL1 COL2 COL3\nROW1    5   10   13\nROW2    9   11   14\nROW3    3   12   15\n\n\n\n3.2.3.1 Манипуляции с элементами массива\nТак как массив - это по сути совокупность нескольких матриц, то и операции мы с массивами мы можем производить практически такие же.\n\nОбращение к элементам\n\nОбращение к элементам массива практически такое же, как и в случае с матрицами, чуть сложнее, поскольку добавляются новые измерения, но общая логика остается та же - мы в квадратных скобках указываем координаты элемента, которые нам нужны:\n\nvector1 &lt;- c(5,9,3)\nvector2 &lt;- c(10,11,12,13,14,15)\ncolumn.names &lt;- c(\"COL1\",\"COL2\",\"COL3\")\nrow.names &lt;- c(\"ROW1\",\"ROW2\",\"ROW3\")\nmatrix.names &lt;- c(\"Matrix1\",\"Matrix2\")\nresult &lt;- array(c(vector1,vector2),dim = c(3,3,2),dimnames = list(row.names,column.names,\n   matrix.names))\nresult[3,,2] # Третья строка второй матрицы\n\nCOL1 COL2 COL3 \n   3   12   15 \n\nresult[1,3,1] # Третий элемент первой строки первой матрицы\n\n[1] 13\n\nresult[,,2] #Вся вторая матрица\n\n     COL1 COL2 COL3\nROW1    5   10   13\nROW2    9   11   14\nROW3    3   12   15\n\n\n\nСоздание матрицы на основе массива:\n\n\nvector1 &lt;- c(5,9,3)\nvector2 &lt;- c(10,11,12,13,14,15)\ncolumn.names &lt;- c(\"COL1\",\"COL2\",\"COL3\")\nrow.names &lt;- c(\"ROW1\",\"ROW2\",\"ROW3\")\nmatrix.names &lt;- c(\"Matrix1\",\"Matrix2\")\narray1 &lt;- array(c(vector1,vector2),dim = c(3,3,2),dimnames = list(row.names,column.names,\n   matrix.names))\nmatrix1 &lt;- array1[,,1]\nmatrix2 &lt;- array1[,,2]\nmatrix1\n\n     COL1 COL2 COL3\nROW1    5   10   13\nROW2    9   11   14\nROW3    3   12   15\n\nmatrix2\n\n     COL1 COL2 COL3\nROW1    5   10   13\nROW2    9   11   14\nROW3    3   12   15\n\n\n\nАрифметические действия с элементами:\n\n\nvector1 &lt;- c(5,9,3)\nvector2 &lt;- c(10,11,12,13,14,15)\ncolumn.names &lt;- c(\"COL1\",\"COL2\",\"COL3\")\nrow.names &lt;- c(\"ROW1\",\"ROW2\",\"ROW3\")\nmatrix.names &lt;- c(\"Matrix1\",\"Matrix2\")\narray1 &lt;- array(c(vector1,vector2),dim = c(3,3,2),dimnames = list(row.names,column.names,\n   matrix.names))\narray1[1,2,1]+array1[3,2,2]\n\n[1] 22\n\n\n\n\n\n3.2.4 Списки (lists)\nСписок(list) - сложный объект, в котором могут храниться данные разных типов и структуры, включая вектора, матрицы и т.д.\nПример:\n\nA &lt;- list(\"Red\", \"Green\", c(21,32,11), matrix(c(1:9), nrow=3, ncol=3), TRUE, 51.23, 119.1)\nA\n\n[[1]]\n[1] \"Red\"\n\n[[2]]\n[1] \"Green\"\n\n[[3]]\n[1] 21 32 11\n\n[[4]]\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n[[5]]\n[1] TRUE\n\n[[6]]\n[1] 51.23\n\n[[7]]\n[1] 119.1\n\n\nСписки могут даже содержать внутри другие списки!\n\nA &lt;- list(\"Red\", \"Green\", c(21,32,11), matrix(c(1:9), nrow=3, ncol=3), TRUE, 51.23, 119.1)\nA[[8]]&lt;-list(\"One\", 256, TRUE)\nA\n\n[[1]]\n[1] \"Red\"\n\n[[2]]\n[1] \"Green\"\n\n[[3]]\n[1] 21 32 11\n\n[[4]]\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n[[5]]\n[1] TRUE\n\n[[6]]\n[1] 51.23\n\n[[7]]\n[1] 119.1\n\n[[8]]\n[[8]][[1]]\n[1] \"One\"\n\n[[8]][[2]]\n[1] 256\n\n[[8]][[3]]\n[1] TRUE\n\n\nКомпоненты списка также могут иметь имена:\n\nA &lt;- list(\"Red\", \"Green\", c(21,32,11), matrix(c(1:9), nrow=3, ncol=3), TRUE, 51.23, 119.1)\nA[[\"color\"]] &lt;- \"yellow\"\nA\n\n[[1]]\n[1] \"Red\"\n\n[[2]]\n[1] \"Green\"\n\n[[3]]\n[1] 21 32 11\n\n[[4]]\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n[[5]]\n[1] TRUE\n\n[[6]]\n[1] 51.23\n\n[[7]]\n[1] 119.1\n\n$color\n[1] \"yellow\"\n\n\nТаким образом, обратиться к компоненту списка можно по имени или по порядковому номеру элемента:\n\nA &lt;- list(\"Red\", \"Green\", c(21,32,11), matrix(c(1:9), nrow=3, ncol=3), TRUE, 51.23, 119.1)\nA[[\"color\"]] &lt;- \"yellow\"\nA[[\"color\"]]\n\n[1] \"yellow\"\n\nA$color #Альтернативный вариант обращения по имени\n\n[1] \"yellow\"\n\nA[[8]]\n\n[1] \"yellow\""
  },
  {
    "objectID": "Data-types-and-structures.html#таблицы-данных-data-frame",
    "href": "Data-types-and-structures.html#таблицы-данных-data-frame",
    "title": "3  Типы и структуры данных",
    "section": "3.3 Таблицы данных (data frame)",
    "text": "3.3 Таблицы данных (data frame)\nДля аналитиков данных это самый важный объект, с которым приходится работать чаще всего. Большинство из тех данных, с которыми нам приходится иметь дело, хранятся именно в формате датафрейма.\nТаблица данных (data frame) - может включать данные разного типа, но только по столбцам. Иными словами, в таблице может быть несколько типов данных, но в каждом столбце может быть только один тип.\n\ndf&lt;- data.frame(id = c(1:4), city = c(\"Москва\",\"Лондон\",\"Париж\",\"Нью-Йорк\"), population = c(16555000, 10840000,10960000,21045000))\ndf\n\n  id     city population\n1  1   Москва   16555000\n2  2   Лондон   10840000\n3  3    Париж   10960000\n4  4 Нью-Йорк   21045000\n\n\nОбращаться к элементам таблицы данных можно точно так же, как и к элементам матрицы:\n\ndf&lt;- data.frame(id = c(1:4), city = c(\"Москва\",\"Лондон\",\"Париж\",\"Нью-Йорк\"), population = c(16555000, 10840000,10960000,21045000))\ndf[1,2]\n\n[1] \"Москва\"\n\n\nЧтобы добавить новую переменную, нужно использовать знак $:\n\ndf&lt;- data.frame(id = c(1:4), city = c(\"Москва\",\"Лондон\",\"Париж\",\"Нью-Йорк\"), population = c(16555000, 10840000,10960000,21045000))\ndf$country&lt;-c(\"Россия\", \"Великобритания\", \"Франция\", \"США\")\ndf$pop2&lt;-df$population/1000\ndf\n\n  id     city population        country  pop2\n1  1   Москва   16555000         Россия 16555\n2  2   Лондон   10840000 Великобритания 10840\n3  3    Париж   10960000        Франция 10960\n4  4 Нью-Йорк   21045000            США 21045\n\n\nС помощью этого же знака, можно вывести все значения той или иной переменной:\nЧтобы добавить новую переменную, нужно использовать знак $:\n\ndf&lt;- data.frame(id = c(1:4), city = c(\"Москва\",\"Лондон\",\"Париж\",\"Нью-Йорк\"), population = c(16555000, 10840000,10960000,21045000))\ndf$country&lt;-c(\"Россия\", \"Великобритания\", \"Франция\", \"США\")\ndf$pop2&lt;-df$population/1000\ndf$city\n\n[1] \"Москва\"   \"Лондон\"   \"Париж\"    \"Нью-Йорк\"\n\n\nЧтобы узнать размерность таблицы, можно воспользоваться уже известной нам функции dim():\n\ndf&lt;- data.frame(id = c(1:4), city = c(\"Москва\",\"Лондон\",\"Париж\",\"Нью-Йорк\"), population = c(16555000, 10840000,10960000,21045000))\ndf$country&lt;-c(\"Россия\", \"Великобритания\", \"Франция\", \"США\")\ndf$pop2&lt;-df$population/1000\ndim(df)\n\n[1] 4 5\n\n\nЕсли у нас есть список векторов, мы можем их легко трансформировать в датафрейм:\n\npeople &lt;- list(name=c(\"Alice\", \"Bob\", \"Charlie\"), \n               grade=c(99.4, 87.6, 22.1), \n               sex=c(\"F\", \"M\", \"M\"))\nas.data.frame(people)\n\n     name grade sex\n1   Alice  99.4   F\n2     Bob  87.6   M\n3 Charlie  22.1   M\n\n\nВ R содержатся много загруженных наборов данных, таких например, как mtcars, в котором содержатся данные по 32 маркам автомобилей:\n\nmtcars\n\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nFiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nFiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\n\nСамые простые операции с таблицами данных заключаются в выводе данных, наименований строк и столбцов.\nКак вывести первые несколько наблюдений?\n\nhead(mtcars)\n\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\n\nКак вывести последние несколько наблюдений?\n\ntail(mtcars)\n\n                mpg cyl  disp  hp drat    wt qsec vs am gear carb\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.7  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.9  1  1    5    2\nFord Pantera L 15.8   8 351.0 264 4.22 3.170 14.5  0  1    5    4\nFerrari Dino   19.7   6 145.0 175 3.62 2.770 15.5  0  1    5    6\nMaserati Bora  15.0   8 301.0 335 3.54 3.570 14.6  0  1    5    8\nVolvo 142E     21.4   4 121.0 109 4.11 2.780 18.6  1  1    4    2\n\n\nКакие переменные содержатся в наборе mtcars?\n\nnames(mtcars)\n\n [1] \"mpg\"  \"cyl\"  \"disp\" \"hp\"   \"drat\" \"wt\"   \"qsec\" \"vs\"   \"am\"   \"gear\"\n[11] \"carb\"\n\n\nНу, и напоследок, представим сводку о данных, содержащихся в этом наборе:\n\nsummary(mtcars)\n\n      mpg             cyl             disp             hp       \n Min.   :10.40   Min.   :4.000   Min.   : 71.1   Min.   : 52.0  \n 1st Qu.:15.43   1st Qu.:4.000   1st Qu.:120.8   1st Qu.: 96.5  \n Median :19.20   Median :6.000   Median :196.3   Median :123.0  \n Mean   :20.09   Mean   :6.188   Mean   :230.7   Mean   :146.7  \n 3rd Qu.:22.80   3rd Qu.:8.000   3rd Qu.:326.0   3rd Qu.:180.0  \n Max.   :33.90   Max.   :8.000   Max.   :472.0   Max.   :335.0  \n      drat             wt             qsec             vs        \n Min.   :2.760   Min.   :1.513   Min.   :14.50   Min.   :0.0000  \n 1st Qu.:3.080   1st Qu.:2.581   1st Qu.:16.89   1st Qu.:0.0000  \n Median :3.695   Median :3.325   Median :17.71   Median :0.0000  \n Mean   :3.597   Mean   :3.217   Mean   :17.85   Mean   :0.4375  \n 3rd Qu.:3.920   3rd Qu.:3.610   3rd Qu.:18.90   3rd Qu.:1.0000  \n Max.   :4.930   Max.   :5.424   Max.   :22.90   Max.   :1.0000  \n       am              gear            carb      \n Min.   :0.0000   Min.   :3.000   Min.   :1.000  \n 1st Qu.:0.0000   1st Qu.:3.000   1st Qu.:2.000  \n Median :0.0000   Median :4.000   Median :2.000  \n Mean   :0.4062   Mean   :3.688   Mean   :2.812  \n 3rd Qu.:1.0000   3rd Qu.:4.000   3rd Qu.:4.000  \n Max.   :1.0000   Max.   :5.000   Max.   :8.000"
  },
  {
    "objectID": "Data-types-and-structures.html#самостоятельная-работа-1",
    "href": "Data-types-and-structures.html#самостоятельная-работа-1",
    "title": "3  Типы и структуры данных",
    "section": "3.4 Самостоятельная работа",
    "text": "3.4 Самостоятельная работа\nСамостоятельная работа №22"
  },
  {
    "objectID": "Intro-to-RMarkdown.html#что-такое-r-markdown-и-зачем-он-нужен",
    "href": "Intro-to-RMarkdown.html#что-такое-r-markdown-и-зачем-он-нужен",
    "title": "4  Основы работы с R Markdown",
    "section": "4.1 Что такое R Markdown и зачем он нужен",
    "text": "4.1 Что такое R Markdown и зачем он нужен\nMarkdown (Маркдаун) - это облегченный язык разметки с синтаксисом форматирования обычного текста, на основе которой могут быть созданы документы разного формата - HTML (веб страницы), PDF, документы в формате MS Word, интерактивные приложения. Больше информации о R Markdown можно посмотреть на официальной странице проекта http://rmarkdown.rstudio.com.\nВ R Markdown создается огромное количество документов - научных статей и книг, диссертаций, data science блогов и так далее. Лекция, которую вы сейчас читаете, тоже была создана в R Markdown, и ваш итоговый проект по курсу тоже будет реализован именно в нем.\nВот только несколько примеров того, что можно создать в маркдауне:\n  \nСсылка на галерею работ: https://rmarkdown.rstudio.com/gallery.html\nMarkdown был создан дизайнером и блогером в области информационных технологий Джоном Грубером в 2004 году (https://twitter.com/gruber) и сегодня является одним из самых популярных языков разметки. Файлы, создаваемые с помощью маркдауна, имеют расширение .md или .markdown, а если они создаются в R - .Rmd.\n\n4.1.1 В чем заключаются преимущества работы в R Markdown?\nR Markdown - это программная среда, используемая для оформления результатов научных исследований и сочетающая возможности текстового редактора и редактора программного кода.\n\n\n4.1.2 Как это происходит?\nВы создаете документ в R Markdown на основе определенной структуры, состоящей из разделов, параграфов, глав и т.д.\nЧасти текста оформляются с помощью специального синтаксиса, а текст внутри них снабжается кодом, с помощью которого Вы обрабатыаете данные, создаете модели, визуализируете результаты исследования, ссылаетесь на научные и документационные источники, приводите цитаты, дополняете свой текст иллюстрациями, полученными из внешних ресурсов (например, фото из Интернета или репродукциями всемирно известных картин из музеев, а может быть и собственными фото- и дизайнерскими работами).\nКогда все готово, Вы просто нажимаете кнопку knit (knit по-английски “вязать”), и маркдаун “связывает” отдельные элементы, преврашая их в целостный документ, отформатированный определенным образом:\n\nсоблюдены размеры страницы\nтекст оформлен с помощью нужных шрифтов\nимеет отступы, цвет, заголовки, подписи к рисункам и таблицам и т.д.\n\nОсновными достоинствами и стимулами к использованию R Markdown являются следующие:\n\nэто легкий доступный язык форматирования для не-программистов, позволяющий создавать Интернет-страницы и другие документы;\nмаркдаун позволяет конвертировать код сразу во множество форматов – PDF, HTML, docs и т.д.;\nмаркдаун позволяет писать код не только на R, но и других языках – Python, Bash, D3, SQL, Stan, Rcpp;\nэто возможность создания полностью воспроизводимых документов, сочетающих код (расчеты, методы анализа) и текст. Для научных исследований это чрезвычайно важно, ведь как правило в научных текстах содержатся уже готовые результаты, а как они были получены – не известно. Имея доступ к исходным данным и файлу в R Markdown, другие исследователи могут повторить эксперимент или создать свои собсвенные;\nблагодаря R Markdown у исследователей появляется возможность не отвлекаться и сразу делать все “в одном месте”;\nмаркдаун позволяет использовать средства форматирования для автоматического создания красивых таблиц и графиков в соответствии с публикационными требованиями (думать о содержании, а не о форме);\nнемаловажно и то, что в маркдауне можно быстро и легко создавать динамические и интерактивные документы и приложения (дашборды, shiny-приложения), что может быть очень востребовано при работе с бизнес-партнерами."
  },
  {
    "objectID": "Intro-to-RMarkdown.html#установка-r-markdown",
    "href": "Intro-to-RMarkdown.html#установка-r-markdown",
    "title": "4  Основы работы с R Markdown",
    "section": "4.2 Установка R Markdown",
    "text": "4.2 Установка R Markdown\nБудем исходить из того, что на ваших компьютерах уже установлены последние версии языка R и интерфейса для работы с ним - RStudio IDE. Если это еще не сделано, рекомендуем обратиться на официальные сайты (https://www.r-project.org) (R Core Team 2021) и RStudio IDE (https://www.rstudio.com).\nПосле того, как R и RStudio установлены, нужно открыть программу RStudio и установить библиотеку rmarkdown:\n\ninstall.packages('rmarkdown')\n\nДля того, чтобы корректно создавать и работать с документами в формате PDF, рекомендуется также установить LaTeX - набор расширений для компьютерной верстки и разметки текста, облегчающий набор сложных документов. Авторы R Markdown предлагают установить для этого библиотеку TinyTeX (https://yihui.name/tinytex/):\n\ninstall.packages(\"tinytex\")\n\nС этими двумя библиотеками в R Markdown можно скомпилировать практически любые документы, но иногда, в зависимости от конкретных задач, потребуется обращение и к другим программным пакетам.\nЭто и следующие практические задания мы будем выполнять в RMarkdown."
  },
  {
    "objectID": "Intro-to-RMarkdown.html#создание-нового-документа-в-r-markdown",
    "href": "Intro-to-RMarkdown.html#создание-нового-документа-в-r-markdown",
    "title": "4  Основы работы с R Markdown",
    "section": "4.3 Создание нового документа в R Markdown",
    "text": "4.3 Создание нового документа в R Markdown\nЧтобы создать новый документ в R Markdown необходимо открыть программу RStudio, выбрать пукты меню File - New File - R Markdown:\n\nДалее, в открывшимся окне нужно написать название документа, фамилию и инициалы автора и выбрать нужный формат - HTML, PDF или Word. Если с помощью R Markdown планируется создание презентаций, интерактивных веб-приложений Shiny и документов на основе шаблонов (документов в формате PDF, адаптированных под определенные требования, например ведущих реферируемых журналов), то нужно в списке слева выбрать не документ, а соответствующий пункт. Нажать OK.\n\nПосле нажатия кнопки OK, программа откроет образец файла .Rmd на английском языке с примерами оформления текста и примерами кода для обработки и визуализации на основе включенных в базовый R наборов данных. Код и текст легко различить: у текста белый фон, тогда как у кода - серый, и такие серые вставки, где пишется код, называют чанками, от английского слова chunk - “кусок”.\nВсе просто: мы пишем текст, а в нужных местах вставляем куски кода - чанки, chunks. Код обрабатывается автоматически, и результаты отображаются в документе. Таким образом, нет необходимости сохранять наши результаты в виде отдельных таблиц или рисунков, все происходит в одном месте - мы обрабатываем результаты исследования и описываем их в одном месте, в одной программе. И это, согласитесь, очень здорово. Безусловно, работа с маркдауном потребует некоторых усилий, поскольку потребуется изменить свой “исследовательский образ жизни”. Так, если вы привыкли работать с SPSS, а потом описывать в Word, то необходимо будет слегка перестроить рабочие процессы, как бы заново научиться анализировать в другом формате. Но зато потом вы будете вознаграждены, во-первых, уникальными результатам анализа и прекрасными визуализациями, научитесь оптимизировать свой код и проводить анализ, а, главное, получать нужные рассчеты гораздо быстрее и сразу в приемлемом для публикации виде, сможете сэкономить свое время.\nНачало и конец чанка обозначается тремя машинописными обратными апострофами {```}, а между ними располагаются обычные строки кода, которые мы уже видели, когда работали в файле скрипта R на прошлых занятиях.\nЧтобы создать новый чанк, нужно нажать на клавиатуре: Ctrl + Alt + I или выбрать в меню специальную кнопку (см. рисунок ниже):\n\nДокумент, который был создан автоматически, будет выглядеть примерно так:\n\nКогда Вы создадите свой первый документ в маркдауне самостоятельно, обратите внимание на код в начале чанка echo = FALSE - он означает, что код будет воспроизведен, но не будет отображаться после того, как документ будет собран, в противном случае читатель увидит и код, и результаты его работы.\nПосле того, как пробный документ откроется, предлагаем пока ничего в нем не менять, а сразу нажать на кнопку knit . Программа предложит сохранить документ, необходимо это сделать. После сохранения автоматически начнется процесс “сшивки”, и после его окончания, поскольку мы выбрали формат HTML, откроется новое окно браузера, в котором будет отображаться примерно следующее:\n\nЕсли при нажатии кнопки knit выбрать Knit to Word, то будет создан новый документ в программе Word, который будет содержать аналогичный текст и графики, что и html-документ. Вот как это может выглядеть: \nИтак, в рамках данного занятия мы узнали:\n\nЧто такое R Markdown и что можно делать с его помощью\nРазобрались с установкой необходимых библиотек, которые нам пригодятся для создания документов с помощью маркдауна\nСоздали тестовый документ и научились применять функцию knit для того, чтобы отобразить разметку в форматах HTML и docx."
  },
  {
    "objectID": "Intro-to-RMarkdown.html#задание-для-самостоятельной-работы",
    "href": "Intro-to-RMarkdown.html#задание-для-самостоятельной-работы",
    "title": "4  Основы работы с R Markdown",
    "section": "4.4 Задание для самостоятельной работы",
    "text": "4.4 Задание для самостоятельной работы\n\nСоздать новый документ RMarkdown.\nИзменить текст и код, используя материалы предыдущих уроков.\nСделать небольшие описания.\nСшить получившийся документ в формате html. Внимание: в начале каждого чанка должно быть указано {r echo=TRUE}, чтобы я могла видеть ваш код.\nПриложить файл html в качестве ответа на задание.\n\nПолезные ссылки:\n\nhttps://r4ds.had.co.nz/r-markdown.html\nhttps://docs.microsoft.com/ru-ru/contribute/markdown-reference\nhttps://www.markdownguide.org/\nhttps://rmarkdown.rstudio.com/authoring_quick_tour.html\nhttps://www.rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf"
  },
  {
    "objectID": "lesson5.html",
    "href": "lesson5.html",
    "title": "5  Трансформации данных",
    "section": "",
    "text": "Раздел находится в разработке…"
  },
  {
    "objectID": "lesson6.html",
    "href": "lesson6.html",
    "title": "6  Основы визуализации",
    "section": "",
    "text": "Раздел находится в разработке…"
  },
  {
    "objectID": "lesson7.html",
    "href": "lesson7.html",
    "title": "7  Импорт из экспорт данных из разных источников",
    "section": "",
    "text": "Раздел находится в разработке…"
  },
  {
    "objectID": "lesson8.html",
    "href": "lesson8.html",
    "title": "8  Анализ одномерных распределений разного типа",
    "section": "",
    "text": "Раздел находится в разработке…"
  },
  {
    "objectID": "lesson9.html",
    "href": "lesson9.html",
    "title": "9  Статистические гипотезы и критерии",
    "section": "",
    "text": "Раздел находится в разработке…"
  },
  {
    "objectID": "lesson10.html",
    "href": "lesson10.html",
    "title": "10  Регрессионный анализ",
    "section": "",
    "text": "Раздел находится в разработке…"
  },
  {
    "objectID": "lesson12.html",
    "href": "lesson12.html",
    "title": "11  Моделировние структурными уравнениями в R",
    "section": "",
    "text": "Раздел находится в разработке…"
  },
  {
    "objectID": "lesson13.html",
    "href": "lesson13.html",
    "title": "12  Количественный анализ текстовых данных в Quanteda",
    "section": "",
    "text": "Раздел находится в разработке…"
  }
]
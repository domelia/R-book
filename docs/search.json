[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R в социологических исследованиях",
    "section": "",
    "text": "В качестве предисловия…\nЭто электронное пособие создано для магистрантов, обучающихся по направлению 39.04.01 «Социология», программа «Цифровые методы анализа и визуализации данных», и содержит обучающие материалы по дисциплине «Анализ данных в R», однако, возможно, оно будет интересно всем, кто хотел бы начать использовать R в качестве аналитического инструмента и выйти за рамки классических пакетов анализа и обработки данных, таких, например, как SPSS.\nЦель курса, равно как и настоящего издания, состоит в том, чтобы познакомить слушателей с основами языка, ключевыми командами, функциями и библиотеками, которые могут быть полезными в процессе организации, сбора данных и анализа результатов социологических исследований, и особенно - представления и распространения результатов.\nХотя R это язык программирования, мы в ходе освоения курса мы практически не будем использовать его в этом качестве, наша основная задача - стать уверенными пользователями R и использовать его для решения профессиональных социологических и учебных задач.\nЧему мы научимся:\n\nРаботать с различными структурами данных, испортировать и экспортировать данные в различных форматах;\nСоздавать несложные функции и понимать документацию к библиотекам;\nМодифицировать данные для исследовательских задач - создавать новые переменные, разъединять и соединять массивы;\nАнализировать результаты количественных социологических исследований и проверять статистические гипотезы, как простые, так и сложные, применять многомерные методы анализа;\nСоздавать визуализации на основе результатов исследования, создавать интерактивные отчеты и простые приложения, демонстрирующие возможности R в распространении научных публикаций.\n\nЧто осталось за кадром?\n\nМы не будем учиться создавать библиотеки и писать сложные функции;\nМы не сможем в полной мере охватить все методы анализа;\nВряд ли получится разобрать все инструменты для визуализации;\nЗа пределами нашего внимания останутся и возможности R по созданию сайтов, блогов и книг.\n\nОднако, и того, что запланировано, представляется хватит, для того, чтобы полюбить R и стать частью сообщества исследователей, использующих R в своей повседневной жизни для решения рутинных задач и поиска инновационных решений.\nМы начинаем!\nДанное пособие находится на этапе разработки и все тексты можно рассматривать только как предварительный «драфт».",
    "crumbs": [
      "В качестве предисловия..."
    ]
  },
  {
    "objectID": "About-R.html",
    "href": "About-R.html",
    "title": "1  Основные сведения об R",
    "section": "",
    "text": "1.1 Что такое R?\nR – это язык программирования и свободная программная среда для статистической обработки и визуализации данных.\nНесмотря на наличие огромного количества языков и различных программ для статистической обработки данных, R в течение двух десятилетий остается популярным языком и средой обработки и анализа данных для специалистов из разных областей знания.\nПозиции языка R как средства разработки среди других языков программирования довольно высоки. Так, по данным индекса Tiobe за 2022 год, R занимал12-е место в мире, и хотя в 2024 году его авторитет заметно упал (23-е место), его используют миллионы аналитиков и разработчиков по всему миру:\nПрежде всего, это язык, который используют ученые, специалисты, работающие в различных отраслях экономики, менеджеры для анализа реальных данных и разработки научно обоснованных систем принятия решений, поэтому место в общем рейтинге не так высоко. Если посмотреть сферы использования, то на первом месте - академическая среда, на втором - сфера здравоохранения, на третьем - правительственные учреждения.\nR используют банки и маркетинговые агентства, технические компании и информационные корпорации для разных целей - от обработки данных до прогнозирования и представления интерактивной инфографики.\nВот только небольшой список тех компаний, которые используют R в своей деятельности.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Основные сведения об R</span>"
    ]
  },
  {
    "objectID": "About-R.html#немного-истории",
    "href": "About-R.html#немного-истории",
    "title": "1  Основные сведения об R",
    "section": "1.2 Немного истории",
    "text": "1.2 Немного истории\nR был создан профессорами Россом Айхэка и Робертом Джентельменом (Ross Ihaka и Robert Gentleman) в 1992 году, сначала как язык программирования для обучения студентов статистике в университете Окленда (Новая Зеландия). Авторы вдохновлялись при создании языком S, используемым в лаборатории Bell, и ради шутки назвали язык R - по первым буквам собственных имен.\nВ июне 1995 года статистик Мартин Махлер убедил Айхэку и Джентельмена опубликовать R как язык со свободным исходным кодом под публичной лицензией GNU. Первая официальная версия была выпущена 29 февраля 2000 года.\nЧуть ранее, в 1997 году Куртом Хорником и Фрицем Лейшем была основана Сеть для архивирования кода R (CRAN, The Comprehensive R Archive Network), цель которой заключалась в хранении исходного кода, выполняемых файлов, документации и библиотек, создаваемых пользователями. На момент декабря 2022 года CRAN имел 103 зеркальных сервера и 18 976 библиотек.\nКоманда разработчиков (R Core Team) также была основана в 1997 году для дальнейшего развития языка. Сейчас в ней состоят ведующие разработчики, статистики, специалисты по компьютерным наукам, всего более 20 человек. В апреле 2003 года для развития проекта была создана некоммерческая организация R Foundation. Цель фонда заключается в предоставлении технической поддержки и коммуникации с создателями R, хранении и управлении технической документацией и интеллектуальной собственностью.\nПодробнее об истории создания R можно узнать из таймлайна: \nСоздатели R (Питер Далгаард - датский ученый, один из членов R Core Team):",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Основные сведения об R</span>"
    ]
  },
  {
    "objectID": "About-R.html#каковы-преимущества-r",
    "href": "About-R.html#каковы-преимущества-r",
    "title": "1  Основные сведения об R",
    "section": "1.3 Каковы преимущества R?",
    "text": "1.3 Каковы преимущества R?\nИх довольно много:\n\nВозможности для статистической обработки, от простых функций до сложных моделей.\n\nПочти все новое, что появляется в области статистики, можно найти в одной из библиотек R. Например, ANZ банк использует R для моделирования невыплат по ипотечному кредитованию, а The Bank Of America применяет R для формирования финансовой отчетности.\n\nЭто язык программирования с открытым исходным кодом (Open-source)\n\nЧто это значит? Это значит, что, во-первых, все написанное на R открыто для изучения и критики, а, во-вторых, каждый может внести вклад в его развитие и улучшение путем создания новых библиотек и новых функций для решения различных задач.\n\nПоддержка сообщества (Community)\n\nУ R - более 2 миллионов пользователей по всему миру, сообщество пользователей R не только внушительное по размеру, но и очень активное. Каким бы ни был ваш проект - учебным или крупномасштабным, всегда найдется тот, кто поможет разобраться в коде и принять правильное решение. Вы тоже можете найти себе единомышленников и подключаться к другим проектам.\nНекоторые полезные ссылки:\n\nhttps://community.rstudio.com/\nhttps://www.r-bloggers.com/\nhttps://stackoverflow.com/questions/tagged/r\nhttps://rweekly.org/ https://www.reddit.com/r/Rlanguage/\nhttps://r.awesome-programming.com/en/awesome/r-language-02/community\n\nКоммьюнити пользователей R это совсем не Man’s World: весьма активно женское сообщество RLadies, устраивающее митапы по всему миру и продвигающее свой особый, женский, взгляд на использование R для разработки и анализа данных.\n\nОгромная коллекция библиотек и полезных функций, позволяющих расширить возможности базового языка\n\nСамые авторитетные хранятся в CRAN (Comprehensive R Archive Network), их более 10 тысяч, однако, чтобы попасть туда, необходимо, чтобы документация и код соответствовали определенным требованиям, что требует времени. До того момента, когда библиотека загружена на CRAN, она, как правило, хранится в открытом доступе, например, на github, где каждый желающий может принять участие в ее тестировании и доработке.\nПример сетевого анализа библиотек и их взаимозависимостей представлен на рисунке ниже:\n\nПримеры полезных библиотек:\n\nобработка и всевозможные манипуляции с данными (tidytverse)\nработа с большими данными (sparklyr)\nглубокое обучение (keras, TensorFlow)\nмашинное обучение (H2O)\nвизуализация данных (ggplot2)\nсоздание отчетов, итерактивная графика и обучение (Rmarkdown, shiny).\n\n\nСовместимость с другими языками программирования\n\nБольшинство функций и библиотек написаны на самом языке R. Однако, для сложных вычислительных задач, могут использоваться и другие языки, такие как C, C++, FORTRAN. Для манипуляций с объектами, возможно использование других языков - .NET, Java, Python. Иными словами, возможности программирования становятся практически безграничными.\n\nСоздание привлекательных визуализаций\n\nВ современном мире анализ данных невозможен без качественной визуализации, особенно если его результаты планируется использовать в сфере политики и бизнеса. R является одним из лучших инструментов для создания качественной графики, и такие библиотеки как ggplot2, plotly, ggvis помогут создать очень детализированные и эстетически привлекательные визуализации.\nДля пользователей R, которые только начинают изучение языка, на сайте https://r-graph-gallery.com создана галерея визуализаций, разбитых по отдельным тематикам. На основе простых и более сложных примеров можно изучить код и адаптировать его под собственные задачи.\n\n\nИнтеграция с Hadoop и анализ больших данных\n\nЕсли перед вами стоит задача анализа больших данных, то с такими библиотеками как rmr, rhdfs, rhbase, RHIVE, RHIPE и Rhadoop возможно интегрировать R и Hadoop (проект фонда Apache Software Foundation для разработки и выполнения распределённых вычислений для работы с большими данными).\nВозможности по хранению данных Hadoop и вычислительные достоинства R используют многие в качестве оптимального решения для анализа больших данных. Например, компания Форд использует R и Hadoop для обработки данных обратной связи с потребителями, что позволяет им улучшить дизайн и обосновывать бизнес решения.\n\n\nСоздание интерактивных веб-приложений\n\nС помощью R и библиотеки shiny можно создавать интерактивные приложения, с помощью которых пользователи (ученики, заказчики, журналисты и пр.) могут познакомиться с вашими данными, провести какие-то виды анализа, сделать визуализацию, возможно изучить какие-то закономерности (часто используются как обучающий инструмент). Эти приложения можно хранить на сервере Shiny или в другом доступном месте.\n\nПримеры можно посмотреть в галерее на сайте shiny: (https://shiny.posit.co/r/gallery/):\n\n\nСовместимость с другими платформами\n\nR может работать с любой конфигурацией оборудования и поддерживает различные операционные системы, независимо от окружения выдает предсказуемые и однозначные результаты.\n\nВозможность запуска кода без компилирования (возможно этот пункт стоило бы поставить на одно из первых мест)\n\nR относится к интерпретируемым языкам, что означает, что ему не требуется компилятор для того, чтобы программа заработала. Иными словами, все команды, которые мы вводим, сразу же выполняются, без дополнительного компилирования (сборки), как это происходит в других языках, например в C, COBOL, Delphi или Fortran. Другими возможностями, которыми обладают интерпретируемые языки, являются кросс-платформенность (способность работать в разных операционных системах и аппаратных средах), простота тестирования и отладки программ.\n\nНапример, Если мы создадим несколько строк кода и запустим их, они выполнятся немедленно и мы увидим результат:\n\nКроме этих преимуществ есть и много других, о которых мы узнаем в процессе изучения курса.\nК слову сказать, данное пособие также создано с помощью R. При его создании использовались возможности open-source системы публикации научной и технической информациии Quarto.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Основные сведения об R</span>"
    ]
  },
  {
    "objectID": "Install-R.html",
    "href": "Install-R.html",
    "title": "2  Установка и начало работы с R",
    "section": "",
    "text": "2.1 Установка R\nПрежде, чем начать работать с R, нам нужно установить его себе на компьютер. Для этого необходимо перейти по ссылке и выбрать версию, подходящую для вашей операционной системы (ссылка ниже ведет на версию для Windows): https://cran.r-project.org/bin/windows/base/\nВместе с R устанавливается небольшая консоль, в которой можно набирать команды на R, но работать в ней не очень удобно, поэтому большинство пользователей предпочитает работать со специальным интерфейсом, или интегрированной средой разработки (Integrated Development Environement, IDE). Наиболее популярной IDE является RStudio (с другими средами, в которых можно работать в R, такими как Visual Studio, Emacs, Eclipse и другими, Вы можете познакомиться самостоятельно).\nЭто бесплатная программа, скачать которую можно по ссылке.\nhttps://posit.co/products/open-source/rstudio/\nШаги по установке не очень трудны и не потребуют каких-то особых навыков, но на всякий случай, можно обратиться к однму из обучающих видео:\nКак установить R:\nКак установить RStudio:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Установка и начало работы с R</span>"
    ]
  },
  {
    "objectID": "Install-R.html#установка-r",
    "href": "Install-R.html#установка-r",
    "title": "2  Установка и начало работы с R",
    "section": "",
    "text": "Уведомление\n\n\n\nВ комьютерных классах устанавливать ничего не нужно, эти инструкции пригодятся для домашнего использования.\n\n\n\n\n\n\n\n\nRStudio online\n\n\n\nКроме “стационарного” использования RStudio, компания Posit предоставляет возможность использования облачных технологий для работы с RStudio онлайн. Бесплатный план позволяет создать до 25 проектов и предоставляет 25 часов в месяц вычислительного времени. Этого будет достаточно для наших учебных проектов. Для получения доступа к Posit Cloud необходимо зарегистрироваться на сайте https://posit.cloud/ или войти с помощью социальных сетей и создать новый проект.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Установка и начало работы с R</span>"
    ]
  },
  {
    "objectID": "Install-R.html#начало-работы-с-r-и-rstudio",
    "href": "Install-R.html#начало-работы-с-r-и-rstudio",
    "title": "2  Установка и начало работы с R",
    "section": "2.2 Начало работы с R и RStudio",
    "text": "2.2 Начало работы с R и RStudio\nПосле первого запуска RStudio вы, скорее всего, увидите вот такую картину:\n\nОсновное окно RStudio будет состоять из трех частей (экранов).\nСлева находится консоль (Console) - здесь можно писать код, и здесь же будут появляться результаты его выполнения, а также различные сообщения, с помощью которых R “общается” с пользователями.\nСправа сверху - рабочее окружение (Environment) - здесь хранятся создаваемые и загружаемые объекты - данные (вектора, датафреймы и пр.), пользовательские функции и некоторые другие объекты.\nОкружение является структурой данных, предназначенной для обеспечения области видимости. Это коллекция каких-то объектов (переменных, функций, массивов данных), которые мы используем. Хэдли Уикхэм предлагает относиться к окружению как к “мешку с именами”, :\n\nЕсть четыре типа окружений:\n\nГлобальное окружение - интерактивное пространство, где мы обычно работаем.\nБазовое окружение, создаваемое базовым пакетом R.\nПустое окружение, не имеющее никаких имен. Является в большей степени абстракцией, хотя и может быть создано с помощью специальной функции.\nТекущее окружение, то есть то, в котором мы работаем в какой-то момент времени.\nОбычно мы не задумываемся над тем, в каком окружении работаем. Это становится важным тогда, когда возникают конфликты функций и ошибки выполняемого кода. Окружение создается автоматически при запуске программы RStudio.\n\nВ этом же окне можно посмотреть историю (History) выполнения кода, и если вы случайно или специально что-то удалили, часто именно в истории можно найти строки, которые были выполнены, и их можно восстановить. Здесь есть некоторые другие вкладки, они нам понадобятся на более поздних этапах работы с R и RStudio.\nСправа снизу - окно просмотра. В отдельных вкладках можно посмотреть, какие файлы и папки есть в рабочей директории, какие библиотеки установлены, можно запросить помощь или посмотреть графики (в процессе анализа).\nЭто только в первый раз окна всего три.\nВыберите в меню File - New File - R Script:\n\nОткроется новый файл, и окон станет четыре:\n\nВ этом новом окне можно писать код и комментарии, сохранять его как отдельный файл с расширением .R, который можно запускать повторно, что очень удобно и позволяет значительно сохранить время при рутинной обработке данных. Очень часто в ходе обработки и анализа данных приходится осуществлять повторяющиеся действия, и скрипт поможет ускорить процесс обработки. В этом состоит основное отличие от консоли, где код можно запустить только однажды.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Установка и начало работы с R</span>"
    ]
  },
  {
    "objectID": "Install-R.html#первые-простые-действия-в-r",
    "href": "Install-R.html#первые-простые-действия-в-r",
    "title": "2  Установка и начало работы с R",
    "section": "2.3 Первые простые действия в R",
    "text": "2.3 Первые простые действия в R\nВсе естественные языки содержат некоторые правила, описывающие то, как язык должен быть использован, и позволяющие носителям языка понимать друг друга без проблем.\nВ языках программирования, и в R, в частности, тоже есть такие правила, которые нужно соблюдать для того, чтобы компьютер понял, что от него требуется. В обычном языке правила иногда меняются или не соблюдаются, что не мешает людям понимать друг друга. С R, однако такой номер не пройдет, правила являются фиксированными, и требуется их неукоснительное соблюдение, чтобы не возникало ошибок.\nРассмотрим некоторые, самые базовые правила.\n\n2.3.1 Команды R\nКак большинство других языков программирования, R состоит из совокупности команд, формирующих последовательность инструкций, которые выполняет компьютер. Можно условно рассматривать такие команды в качестве глаголов, которые обозначают какие-то действия, которые выполняет R для получения определенного результата.\nНапример:\n\nprint(\"Привет, мир!\")\n\n[1] \"Привет, мир!\"\n\n\nЭта команда выполняет вывод на экран сообщения. Код на R обычно содержит множество команд, и обычно, каждая команда распологается на своей строке. Примеры:\n\nprint(\"Сегодня хорошая погода\")\n\n[1] \"Сегодня хорошая погода\"\n\nprint(1+1)\n\n[1] 2\n\nprint(4 &gt; 5)\n\n[1] FALSE\n\n\nПервая команда выводит сообщение, вторая - производит математические действия третья - оценивает истинность или ложность утверждения и выводит результат.\nОбычно каждая команда находится в своей строке, но можно их писать и в одну строку, разделяя точкой с запятой:\n\nx &lt;- 1+1; print(x); print(x^2)\n\n[1] 2\n\n\n[1] 4\n\n\nВ этом примере три команды приведены в одной строке. Первая команда создает переменную x, вторая выводит на экран значения этой переменной, третья - вычисляет квадрат значений переменной x и выводит результат на экран. Точка с запятой используется в качестве знака окончания команды и подсказывает R, где заканчивается одна команда и начинается другая. Если строка содержит только одну команду, точку с запятой можно не ставить, но если поставить, это не будет ошибкой:\n\nprint(\"Здесь нет точки с запятой\")\n\n[1] \"Здесь нет точки с запятой\"\n\nprint(\"А здесь есть точка с запятой\");\n\n[1] \"А здесь есть точка с запятой\"\n\n\n\n\n\n\n\n\nВажное уведомление\n\n\n\nЕсли включить несколько знаков точки с запятой, например, print(“hello”);;, ничего работать не будет!\n\n\nИтак, мы сейчас попробовали написать код по-разному - каждая команда в одной строке несколько команд в одной строке. А можно ли написать одну команду в несколько строк? Да, если в это сложная команда, в которой необходимо устанавливать несколько аргументов и такая разбивка часто используется для улучшения читаемости кода. Чуть ниже мы увидим, как это может быть.\nМожно также заключить часть кода в фигурные скобки, и тогда он будет восприниматься R как единое целое:\n\n{\n  print(\"Тут написан код, который воспринимается как единое целое\")\n  print(2^3 - 7)\n  w &lt;- \"hello\"\n  print(w)\n}\n\n[1] \"Тут написан код, который воспринимается как единое целое\"\n[1] 1\n[1] \"hello\"\n\n\nКод в примере выше оформлен с помощью отступов и так выглядит лучше, но это не обязательно. Можно обойтись и без этих отступов, все будет работать. Отступы (идентирование) никак не влияют на результат, а являются частью форматирования кода для улучшения его читабельности.\n\n{\nprint(\"Тут написан код, который воспринимается как единое целое\")\nprint(2^3 - 7)\nw &lt;- \"hello\"\nprint(w)\n}\n\n[1] \"Тут написан код, который воспринимается как единое целое\"\n[1] 1\n[1] \"hello\"\n\n\nЧто это ознчает - сгруппировать код? С практической точки зрения различий мало, но программа воспринимает эти несколько линий вместе и обрабатывает как бы как одну команду. Это в большей степени важно при написании программ на R.\n\n\n2.3.2 Полезные подсказки (shortcuts)\nВ R создано много удобных вещей, для того, чтобы написание кода было более приятным. Например, если выделить слово и нажать на знак кавычек, они поставятся сразу с двух сторон, то же происходит и со скобками.\nЕще одной удобной подсказкой является клавиша tab, которая работает с функциями и переменными. Начав набирать какую-то команду или переменную, можно нажать клавишу tab и выбрать из списка подходящий вариант, что экономит большое количество времени и позволяет избежать ошибок.\n\n\n2.3.3 Пустые строки\nПустые линии R игнорирует, но они позволяют организовать код и сделать его более читаемым:\n\nprint(\"Какое небо голубое!\")\n\n[1] \"Какое небо голубое!\"\n\n# Пустая строка есть, но она ничего не меняет\n\nprint(\"А трава зеленая!\")\n\n[1] \"А трава зеленая!\"\n\n\n\n\n2.3.4 ?\nВ R имеется очень много сопроводительной документации, доступной по каждой функции и библиотеке, где объясняются особенности работы с ними, приводятся примеры и дается теоретическое обоснование. Чтобы обратиться к этой вспомогательной документации достаточно набрать имя функции, перед которой нужно поставить знак вопроса:\nЛучше всего эту команду попробовать в RStudio. Давайте сделаем это!\n\n\n2.3.5 ??\nЕсли вдруг вы забыли как точно называется та или иная функция или хотите посмотреть общие материалы по теме, то можно использовать ??.\n\n??print\n\n\n\n\n\n\n\nУведомление\n\n\n\nХотите узнать больше о синтаксисе R? Попробуйте набрать ?Syntax в консоли R и нажать на Enter.\n\n\n\n\n2.3.6 Самостоятельная работа\nДавайте создадим наш первый скрипт и сохраним его для истории 😄:\n\nВыберите в меню File - New File - R Script (если Вы этого еще не сделали) или нажать Ctrl + Shift + N.\nНапишите код, выполняющий простые арифметические действия. Наберите на клавиатуре любое математическое выражение, например, 1+1. Чтобы выполнить данную команду, нажмите сочетание клавиш Ctrl + Enter или кнопку Run, которая находится в правом углу меню. Команда выполняется автоматически, сразу же.\n\n\n1+1\n\n[1] 2\n\n\nПоэспериментируйте с R как с калькулятором, используя информацию об операторах, используемых для математических вычислений:\n\n\n\n\n\n\nКакие операторы используются для математических действий?\n\n\n\n\n\n\nОператор\nОписание\n\n\n+\nсложение\n\n\n-\nвычитание\n\n\n*\nумножение\n\n\n/\nделение\n\n\n^ или **\nвозведение в степень\n\n\nx %% y\nостаток от деления (x mod y) 5%%2 = 1\n\n\nx %/% y\nцелая часть при делени 5%/%2 =2\n\n\n\n\n\nЕсли мы что-то делаем неправильно, в консоли появится сообщение об ошибке:\n\n-1+a\n\n\n\n\n\n\n\nО пользе ошибок\n\n\n\nОшибок и предупреждающих сообщений бояться не надо, напротив, в таких сообщениях практически всегда находится ответ на вопрос, почему такая ошибка возникла, а часто - и возможное решение проблемы.\n\n\n\nНапишите код, отображающий текстовое сообщение:\n\n\n\"Привет, Алтайский государственный университет!\"\n\n[1] \"Привет, Алтайский государственный университет!\"\n\n\n\nСохраните файл. Файлы скрипта сохраняются с раширением .R, однако есть и другие форматы. Например, объекты, которые создаются в окружении, можно сохранить в формате .Rdata, а в файле .Rhistory может храниться информация о выполненном коде (что вы делали и в какой последовательности).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Установка и начало работы с R</span>"
    ]
  },
  {
    "objectID": "Install-R.html#работа-с-библиотеками",
    "href": "Install-R.html#работа-с-библиотеками",
    "title": "2  Установка и начало работы с R",
    "section": "2.4 Работа с библиотеками",
    "text": "2.4 Работа с библиотеками\nМы уже выяснили, что базовый язык R в настоящее время используется наряду с многочисленными функциями и библиотеками, разрабатываемыми коллективами ученых и разработчиками из разных стран мира, включая Россию.\nУстанавливать новые библиотеки нам придется практически на каждом занятии, поэтому лучше научиться делать это сразу.\nЭти библиотеки хранятся в основном в двух местах:\n\nCRAN\nGithub - нечто вроде социальной сети для программистов, где все друг друга знают, создают совместные проекты и делятся кодом.\n\n\n\n\n\n\n\nКое-что о библиотеке/пакетах\n\n\n\nМы называем “библиотеку” “библиотекой” и подразумеваем под ней набор каких-то полезных утилит, наборов данных и сопутствующей документации, потому что так принято в русскоязычном сегменте Интернета, посвященном программированию.\nОднако, по-английски библиотека называется package, то есть “пакет”, в котором “упакованы” функции, сопровождающие документы и иногда готовые данные, а вот функция, которая этот пакет подключает - `library()` – что собственно и переводится как библиотека, такой вот языковый казус. Об этом стоит помнить и слова эти не путать.\n\n\n\n2.4.1 Как установить библиотеку с помощью CRAN\nЧтобы скачать и установить нужную библиотеку с помощью CRAN, проще всего воспользоваться меню RStudio. Нужно выбрать пункт меню Tools - Install Packages:\n\nЗатем в окне Packages необходимо ввести имя нужной библиотеки, например, dplyr и нажать на кнопку Install. По умолчанию будет стоять “галочка” - Install Dependencies (установить зависимости) - убирать ее не надо, так как это позволить установить не только саму библиотеку, но и другие библиотеки, от которых она зависит и к которым обращается в ходе выполнения функций. В противном случае, могут возникать ошибки, а оно нам надо?\n\n\n\n2.4.2 Как установить библиотеку из Github\nНе все библиотеки доступны на CRAN, так как эта процедура достаточно сложная и строгая, предполагает несколько проверок (кода, сопроводительной документации). Достаточно частая практика, когда библиотека еще не подана для регистрации на CRAN, разработчики помещают ее на GitHub, откуда ее можно скачать и использовать по назначению. Это позволяет разработчикам получить обратную связь, устранять возможные ошибки, улучшать код.\nЧтобы установить нужную библиотеку из GitHub, нам понадобится функция install_github(), в которой мы должны указать имя разработчика и название библиотеки. Однако, чтобы выполнить эту функцию, нужна дополнительная библиотека devtools. Установить ее можно через CRAN с помощью описанного выше способа. А уже затем, загрузив ее, установить нужную нам библиотеку (получается сложновато, зато мы сразу научимся нужным действиям, потом мы доведем их до автоматизма):\n\nlibrary (devtools)\ninstall_github(\"DeveloperName/PackageName\")\n\n\n\n2.4.3 Вопросы для самопроверки\n1. Какой код нужно написать, чтобы подключить для использования уже установленную библиотеку tidyverse?\n\n library(tidyverse) install(tidyverse) package(tidyverse)\n\n2. Библиотека, используемая для установки пакетов с github:\n\n devtools dplyr tidyverse",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Установка и начало работы с R</span>"
    ]
  },
  {
    "objectID": "Data-types-and-structures.html",
    "href": "Data-types-and-structures.html",
    "title": "3  Типы и структуры данных",
    "section": "",
    "text": "3.1 Типы данных в R\nТип данных (встречается также термин «вид данных») — фундаментальное понятие теории программирования.\nТип данных определяет множество значений, набор операций, которые можно применять к таким значениям и способ реализации хранения значений и выполнения операций. Любые данные, которыми оперируют программы, относятся к определённым типам.\nR может хранить и обрабатывать различные виды информации и типы данных:\n2&gt;3\n\n[1] FALSE\nМы можем присваивать логические значения в качестве значений переменных, используя полный или краткий вариант:\na&lt;-TRUE\nb&lt;-FALSE\n#Или\na&lt;-T\nb&lt;-F\nС логическим типом могут происходить интересные вещи, в частности, этот тип может рассматриваться как число. В таком случае TRUE принимается за 1, а FALSE как 0.\nИ если мы будем производить манипуляции над логическими значениями, в результате у нас будут числа!\nНапример:\nTRUE + TRUE  # TRUE считается как 1\n\n[1] 2\nFALSE * 7 # FALSE принимается за 0\n\n[1] 0\nИли, вот еще интересный пример:\n(2 &lt; 3) + (1 == 2)  # Что тут вообще происходит?\n\n[1] 1\nПочему получился именно такой результат?\n2 &lt; 3 - TRUE, то есть 1\n1 == 2 - FALSE, то есть 0\nTRUE+FALSE=1+0=1\nis.numeric(-5.6)\n\n[1] TRUE\n\na &lt;- -11\nb &lt;- 13.37\nc &lt;- 1/137\nclass(a)\n\n[1] \"numeric\"\n\nclass(b)\n\n[1] \"numeric\"\n\nclass(c)\n\n[1] \"numeric\"\nС числовыми переменными мы можем совершать различные математические операции:\na &lt;- -11\nb &lt;- 13.37\nc &lt;- 1/137\nprint(a+b*c)\n\n[1] -10.90241\n\nprint(a^2+sqrt(b)-c/5)\n\n[1] 124.655\nx &lt;- pi * 23.5\nclass(x)\n\n[1] \"numeric\"\n\n#Проверим, является ли x целым числом\nis.integer(x)\n\n[1] FALSE\n\n#Создадим переменную y\ny&lt;-25L #при вводе, для того, чтобы R понял, что число именно целое, добавляется буква L\n#Проверим, является ли y целым числом\nis.integer(y)\n\n[1] TRUE\n\n#Проверим, является ли y числовой переменной\nis.numeric(y)\n\n[1] TRUE\nz &lt;- 1:2 + 1i*(8:9)\nstr(z)\n\n cplx [1:2] 1+8i 2+9i\ncolor&lt;-\"Red\"\nclass(color)\n\n[1] \"character\"\n\nis.character(color)\n\n[1] TRUE\nВозможные варианты написания:\nd &lt;- \"Hello\"         # С помощью двойных кавычек \ne &lt;- 'how are you?'  # С помощью одинарных кавычек\nd\n\n[1] \"Hello\"\n\ne\n\n[1] \"how are you?\"\nОднако, нельзя использовать и те, и другие сразу, будет ошибка:\nf &lt;- \"Так работать не будет'\nИногда вместо текста нет ничего, но это все равно будет строковая переменная (пустая строка):\nh &lt;- \"\"              # Это пустая строка!\nС числовыми переменными мы можем совершать различные операции, что же делать со строковыми переменными? К ним тоже можно применять разные функции, и их довольно много. Вот некоторые:\nПосчитаем количество символов в строке:\ng&lt;-\"Как упоительны в России вечера!\"\nnchar(g)\n\n[1] 31\nЕсли нам нужен какой-то определенный фрагмент текста, мы можем его “вытащить” оттуда:\ng&lt;-\"Как упоительны в России вечера!\"\nsubstr(g, 4, 25) \n\n[1] \" упоительны в России в\"\nДовольно часто при анализе текстовых данных их нужно разделить на отдельные кусочки:\ng&lt;-\"Как упоительны в России вечера!\"\nstrsplit(g, \" \")   \n\n[[1]]\n[1] \"Как\"        \"упоительны\" \"в\"          \"России\"     \"вечера!\"\nВ данном случае мы использовали пробел в качестве разделителя.\nx &lt;- c(\"single\",\"married\",\"married\",\"single\")\nclass(x)\n\n[1] \"character\"\nfactor () - функция, которая создает факторные переменные. Аргумент levels используется для обозначения уровней (порядка, если он нужен).\nx &lt;- factor(c(\"single\", \"married\", \"married\", \"single\"), levels = c(\"single\", \"married\", \"divorced\"))\nclass(x)\n\n[1] \"factor\"\n\nstr(x)# функция str() дает больше информации о переменной, не только какого она типа, но сколько элементов содержит, какие в ней значения, уровни и т. д.\n\n Factor w/ 3 levels \"single\",\"married\",..: 1 2 2 1\nas.factor() - данная функция превращает в факторный тип переменные другого типа, даже если они числовые.\ncolors&lt;-c(\"red\", \"yellow\", \"green\")\ncolors&lt;-as.factor(colors)\nstr(colors)\n\n Factor w/ 3 levels \"green\",\"red\",..: 2 3 1\nПример порядковой переменной с уровнями:\nstatus &lt;- c(\"Poor\", \"Middle-class\", \"Rich\")\nstatus &lt;- factor(status, ordered=TRUE) # ordered=TRUE - делает переменную не просто категориальной, но и порядковой\nstr(status)\n\n Ord.factor w/ 3 levels \"Middle-class\"&lt;..: 2 1 3\nПолучилось не совсем то, что нам нужно, так как программа автоматически отсортировывает по алфавиту. Чтобы поменять порядок, нужно задать уровни “принудительно”:\nstatus &lt;- c(\"Poor\", \"Middle-class\", \"Rich\")\nstatus &lt;- factor(status, order=TRUE,levels=c(\"Poor\", \"Middle-class\", \"Rich\"))\nstr(status)\n\n Ord.factor w/ 3 levels \"Poor\"&lt;\"Middle-class\"&lt;..: 1 2 3",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Типы и структуры данных</span>"
    ]
  },
  {
    "objectID": "Data-types-and-structures.html#типы-данных-в-r",
    "href": "Data-types-and-structures.html#типы-данных-в-r",
    "title": "3  Типы и структуры данных",
    "section": "",
    "text": "Логический (logical) – TRUE, FALSE – ИСТИНА, ЛОЖЬ.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЧисловой (numeric) – целые и дробные, положительные и отрицательные.\n\n\n\n\n\nЦелое, целочисленное (integer) – целые числа, положительные и отрицательные\n\n\n\nКомплексные (complex) – это уже абстрактная математика (числа состоящие из действительной (реальной) и мнимой части), например, 3+2i. Нам они вряд ли пригодятся, но на всякий случай запомним.\n\n\n\nТекстовые, строковые (character) – «Привет, мир!», «а», «4В»\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nФакторные переменные (factor) – могут быть строковыми и числовыми, задают уровни или как правило являются номинальными переменными: пол, семейный статус, цвет волос и т. д., служат категоризации\n\n\n\n\n\n\n\n\n\n\n\n3.1.1 Вопросы для самопроверки\n1. К какому типу переменных относится число -3,5?\n\n numeric character complex integer\n\n2. Какой результат получится, если попытаться превратить в число строковую переменную?\n\n NA TRUE NAs introduced by coercion\n\n3. Какая функция используется для проверки принадлежности переменной к факторному типу?\n\n is.factor() as.factor() factor()\n\n4. Могут ли логические переменные быть представлены в числовом виде?\n\n Да() Нет Затрудняюсь ответить\n\n\n\n3.1.2 Самостоятельная работа\nСамостоятельная работа № 1",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Типы и структуры данных</span>"
    ]
  },
  {
    "objectID": "Data-types-and-structures.html#структуры-данных",
    "href": "Data-types-and-structures.html#структуры-данных",
    "title": "3  Типы и структуры данных",
    "section": "3.2 Структуры данных",
    "text": "3.2 Структуры данных\nСтруктура данных — это способ организации информации для более эффективного использования. В программировании структурой обычно называют набор данных, связанных определённым образом.\nОсновные структуры данных в R это векторы, матрицы, массивы, списки и таблицы данных.\nРассмотрим их подробнее.\n\n\n3.2.1 Векторы\n\nВектор – одномерный массив проиндексированных (пронумерованных) элементов, набор однотипных элементов (либо числа, либо буквы) без их сочетания. Векторы могут быть такими же, как и типы данных - числовыми, строковыми, логическими и пр.\n\nВот пример того, как можно создать числовой вектор, содержащий числа от 1 до 10:\n\nx&lt;-1:10\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nА вот так - вектор с текстовыми элементами:\n\ny&lt;-c(\"Красный\", \"Синий\", \"Желтый\")\ny\n\n[1] \"Красный\" \"Синий\"   \"Желтый\" \n\n\nЗаметьте, чтобы создать вектор с наименованиями цветов, мы использовали функцию c(), в которой c является производной отcombine. В этом есть смысл, поскольку мы соединяем, как бы “комбинируем”, несколько числовых или текстовых объектов в один ряд.\n\n\n\n\n\n\nПро имена (важно!)\n\n\n\nКак назвать вектор (да и другие структуры данных) правильно? Есть несколько простых правил. Имя может содержать:\n\nбуквы\nчисла\nточку или символ «подчеркивания” (_)\n\nи обязательно должно начинаться с буквы или точки, но за точкой нельзя поставить цифру.\nТак, например, имя “.2b” не является валидным, а “.b2” - вполне годится для именования.\nНельзя также использовать в именах зарезервированные слова,такие как if,else, repeat, while, function, for, in, next, break, TRUE, FALSE, NULL, Inf, NaN, NA, NA_integer_, NA_real_, NA_complex_, NA_character_ некоторых других, которые являются базовыми конструкциями языка и используются в качестве аргументов при вызове функций.\n\n\nНапример, если мы попробуем создать вот такой вектор, то программа выдаст ошибку:\n\nbreak&lt;-1:5\n\nError in break &lt;- 1:5: неправильная (NULL) левая сторона присваивания\n\n\nДлину числового вектора можно определить с помощью функции length():\n\nx&lt;-1:3\nlength(x)\n\n[1] 3\n\n\nФункция class() помогает определить, какой тип данных хранится в векторе. Напомним, что вектор содержит данные одного типа.\n\nx&lt;-c(1:3)\nclass(x)\n\n[1] \"integer\"\n\n\nЕще примеры создания логических и текстовых векторов:\n\ny &lt;- c(TRUE, TRUE, FALSE, TRUE)\nz &lt;- c(\"to\", \"be\", \"or\", \"not\", \"to\", \"be\") \nclass(y)\n\n[1] \"logical\"\n\nlength(y)\n\n[1] 4\n\nclass(z)\n\n[1] \"character\"\n\nlength(z)\n\n[1] 6\n\n\n\n\n\n\n\n\nВажное уведомление\n\n\n\nЕсли мы попытаемся соединить два вектора - числовой и строковый - то цифры “превратятся” в буквы, поскольку R автоматически переведет все элементы к наиболее подходящему общему типу данных. Поскольку слова в цифры превратить нельзя, то таким общим типом будет строковый.\n\n\n\nx&lt;-c(1:10)\ny&lt;-c(\"Красный\", \"Синий\", \"Желтый\")\nz&lt;-c(x,y)\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\ny\n\n[1] \"Красный\" \"Синий\"   \"Желтый\" \n\nz\n\n [1] \"1\"       \"2\"       \"3\"       \"4\"       \"5\"       \"6\"       \"7\"      \n [8] \"8\"       \"9\"       \"10\"      \"Красный\" \"Синий\"   \"Желтый\" \n\n\nТо, что произошло в коде выше, называется конверсией типов. Такая конверсия случается тогда, когда элементы вектора разные. Запомниим, что вектор всегда хранит данные только одного типа!\nЗадание. Попробуйте создать вектор, сочетающий числовые, строковые и логические значения:\nА что будет, если мы соединим вместе логические и числовые?\n\nx&lt;-c(TRUE, 5, FALSE, 6)\nx\n\n[1] 1 5 0 6\n\n\nМы можем также создавать “пустые” вектора, обозначая только тип данных, и сколько элементов в них содержится.\nНапример:\n\nempty &lt;- numeric(10)   # Создаем пустой числовой вектор с 10 элементами\nprint(empty)\n\n [1] 0 0 0 0 0 0 0 0 0 0\n\n\nЗаметьте, что даже если мы не просили R внести какие-то значения, в числовом векторе всем элементам автоматически были присвоены нули - значение по умолчанию.\nВот таким образом можно создать пустые вектора других типов:\n\nempty_int &lt;- integer(45)   # числовой вектор с 45 элементами\nempty_cha &lt;- character(2)  # строковый вектор с 2 элементами\nempty_log &lt;- logical(1000)    # логический вектор с 1000 элементами\n\nPfПопробуйте в RStudio создать эти вектора и посмотреть их. Обратите внимание, какие значения по умолчанию присваиваются в логическом и строковом векторах!\n\n3.2.1.1 Адресация и изменение элементов вектора\nПосле того, как вектор создан, как мы можем посмотреть или изменить его элементы. Это сделать достаточно просто:\nПоменять элемент в векторе:\n\na &lt;- c(1, 2, 3)  # Создадим числовой вектор с 3 элементами\na[2] &lt;- 4        # Изменим значение второго элемента на 4\na                # Посмотрим, что получилось\n\n[1] 1 4 3\n\n\nКак вы уже догадались, чтобы обратиться к какому-то элементу вектора, нужно набрать его порядковый номер в квадратных скобках [ порядковыйномер ]:\n\na &lt;- c(1, 2, 3)  # Создадим числовой вектор с 3 элементами\na[3]             # Попросим R вывести третий элемент\n\n[1] 3\n\n\nКак вы думаете, что будет если запустить следующий код? Каким будет результат?\n\nvec &lt;- c(4, 5, 6)\nvec[3] == 6\n\nДогадались? Попробуйте теперь запустить этот код и проверить, правы вы или нет:\n\n\n3.2.1.2 Операции над векторами\nС векторами можно производить большое количество действий, которые позволяют те типы данных, которые в них содержатся.\nПроще всего совершать арифметические действия:\n\na &lt;- 3   # Создаем единичный числовой объект\na + 4  # Прибавляем к нему константу\n\n[1] 7\n\n\nМы можем прибавить число не только к другому числу, но и ко всему вектору:\n\na &lt;- c(1, 2, 3)   # Создаем числовой вектор\na + 4   # Прибавляем к нему константу\n\n[1] 5 6 7\n\n\nТакой тип “поведения” программы называется поэлементным. То есть операция производится над каждым элементом по отдельности.\nЕще примеры:\n\na &lt;- c(1, 2, 3)\na - 3 \n\n[1] -2 -1  0\n\na * 1.5\n\n[1] 1.5 3.0 4.5\n\na ^ 2\n\n[1] 1 4 9\n\na == 2\n\n[1] FALSE  TRUE FALSE\n\n\nВ последнем случае мы сравнивали каждый элемент со значением два и в результате получили новый вектор, состоящий из логических значений.\nВ R имеется много различных функций для трансформации, мы с ними будем активно работать на следующих занятиях. Но самая простая функциюя - sum(), которая просто складывает все элементы вектора вместе:\n\na &lt;- c(1, 2, 3)\nsum(a)\n\n[1] 6\n\n\nНекоторые операции можно производить над векторами, если у них одинаковая длина:\n\na &lt;- c(1, 2, 3)\nb &lt;- c(1, 0, 1)\na + b\n\n[1] 2 2 4\n\nb * a\n\n[1] 1 0 3\n\na ^ b\n\n[1] 1 1 3\n\n\nМы можем даже сравнить два вектора и сохранить результат в отдельном логическом векторе\n\na &lt;- c(1, 2, 3)\nb &lt;- c(1, 0, 1)\nz &lt;- a &gt; b   # сравниваем a и b, поэлементно, результат сохраняем в векторе z\nz\n\n[1] FALSE  TRUE  TRUE\n\nz == TRUE\n\n[1] FALSE  TRUE  TRUE\n\nz == FALSE\n\n[1]  TRUE FALSE FALSE\n\n!z #выдает противоположное значение\n\n[1]  TRUE FALSE FALSE\n\n\nА что можно делать со строковыми векторами?\nДавайте создадим пару векторов и попробуем с ними совершить какие-нибудь действия, например, сравним их попарно:\n\na &lt;- c(\"собака\", \"молоко\", \"квартира\", \"чай\", \"морозы\", \"душа\")\nb &lt;- c(\"собака\", \"мыло\", \"сахар\", \"чай\", \"малина\", \"душа\")\na==b\n\n[1]  TRUE FALSE FALSE  TRUE FALSE  TRUE\n\n\nЧтобы найти какой-то текстовый элемент и его место в векторе, можно использовать функцию grep():\n\na &lt;- c(\"собака\", \"молоко\", \"квартира\", \"чай\", \"морозы\", \"квартира\", \"душа\")\ngrep(\"квартира\", a)\n\n[1] 3 6\n\n\nРезультат показывает, что слово “квартира” встречается два раза, это третий и шестой элементы. Что будет, если поищем то, чего нет?\n\na &lt;- c(\"собака\", \"молоко\", \"квартира\", \"чай\", \"морозы\", \"квартира\", \"душа\")\ngrep(\"редиска\", a)\n\ninteger(0)\n\n\nЕсли вектора разного типа, то иногда с ними можно что-то сделать, иногда нет, зависит от типа данных:\n\na &lt;- c(1, 2, 3)\nb &lt;- c(\"one\", \"two\", \"three\")\nc &lt;- c(TRUE, TRUE, FALSE)\na+b\n\nНичего не получилось, потому что нельзя к словам прибавлять числа. А вот если сложить вектора a и c, все получится:\n\na &lt;- c(1, 2, 3)\nb &lt;- c(\"one\", \"two\", \"three\")\nc &lt;- c(TRUE, TRUE, FALSE)\na+c\n\n[1] 2 3 3\n\n\n\n\n3.2.1.3 Некторые полезные функции для работы с векторами\n\nСоздать вектор случайных чисел в определенном диапазоне:\n\n\nx &lt;- runif(10, min = -5, max = 5)\nx\n\n [1] -3.7691016  4.4885133 -2.3471501 -3.1366398 -0.5817319 -2.2855940\n [7]  3.6793397  1.4466606 -4.0884712 -0.9552966\n\n\n\nСоздать вектор с повторяющимися значениями с помощью функции rep() – повторить (что, сколько раз):\n\n\nb&lt;- rep(c(1,2,3),4)\nb\n\n [1] 1 2 3 1 2 3 1 2 3 1 2 3\n\n\n\nСоздать вектор из повторяющихся значений определенной длины с помощью функции rep() – повторить (что, до каких пор, какой длины):\n\n\nc&lt;- rep(c(4,5,6), length.out=10)\nc\n\n [1] 4 5 6 4 5 6 4 5 6 4\n\n\n\nСоздать вектор через последовательность определенных значений с помощью функции seq() – задать последовательность (от, до, с каким шагом)\n\n\nseq &lt;- seq(from=2,to=15,by=0.5)\nseq\n\n [1]  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5  7.0  7.5  8.0  8.5  9.0\n[16]  9.5 10.0 10.5 11.0 11.5 12.0 12.5 13.0 13.5 14.0 14.5 15.0\n\n\n\nПроверить, является ли какой-то объект вектором с помощью функции is.vector() :\n\n\nseq &lt;- seq(from=2,to=15,by=0.5)\nis.vector(seq)\n\n[1] TRUE\n\n\n\nПроверить, удовлетворяет ли хотя бы один элемент вектора какому-либо условию с помощью функции any():\n\n\nvec &lt;- as.integer(c(34,23,53,42,16,42,64,32,76))\nany(vec,vec&gt;50)\n\n[1] TRUE\n\n\n\nПроверить, удовлетворяют ли все элементы вектора какому-либо условию с помощью функции all():\n\n\nvec &lt;- as.integer(c(34,23,53,42,16,42,64,32,76))\nall(vec,vec&gt;10)\n\n[1] TRUE\n\n\n\nПрименить какую-либо функцию преобразования ко всем элементам вектора с помощью функции sapply():\n\n\nvec &lt;- as.integer(c(34,23,53,42,16,42,64,32,76))\nvec3&lt;-sapply(vec, sqrt)\nvec3\n\n[1] 5.830952 4.795832 7.280110 6.480741 4.000000 6.480741 8.000000 5.656854\n[9] 8.717798\n\n\nВ принципе, можно это сделать и проще:\n\nvec &lt;- as.integer(c(34,23,53,42,16,42,64,32,76))\nsqrt(vec)\n\n[1] 5.830952 4.795832 7.280110 6.480741 4.000000 6.480741 8.000000 5.656854\n[9] 8.717798\n\n\nНо иногда, когда у нас не вектор, а более сложный объект, функция sapply() и ее родные сестры apply() и lapply()часто очень выручают. Подробнее эти функции будут рассмотрены на следующих занятиях.\n\n\n\n3.2.2 Матрицы\n\nМатрица – двумерная совокупность числовых, логических или текстовых величин. Чтобы создать матрицу, нужно воспользоваться функцией matrix(). Можно думать о матрице как о решетке каких-то числовых величин.\n\nПростой пример:\n\ndata &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA &lt;- matrix(data, ncol=3, nrow=3)\nA\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n\nМы создали матрицу с тремя строками и тремя колонками на основе данных, изначально хранящихся в виде числового вектора.\n\n\n\n\n\n\nВажное уведомление\n\n\n\nR заполняет матрицу сверху вниз, колонку за колонкой, двигаясь справа налево.\n\n\nЕсли мы хотим это изменить, нужно поменять параметр byrow:\n\ndata &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA &lt;- matrix(data, ncol=3, nrow=3, byrow = T)\nA\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n\n\n\n3.2.2.1 Полезные функции и операции над матрицами\n\nКак обратиться к одному из элементов матрицы? В случае с вектором мы задавали один элемент в квадратных скобках, а что теперь? Матрица - двумерный объект, поэтому мы должны теперь в квадратных скобках задать две координаты - номер строки (первое число) и номер колонки (второе число) - через запятую:\n\n\ndata &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA &lt;- matrix(data, ncol=3, nrow=3, byrow = T)\nA\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n\nA[1,1] # Первый элемент первой строки\n\n[1] 1\n\nA[2,3] # Третий элемент второй строки\n\n[1] 6\n\nA[1,]  # Первая строка полностью\n\n[1] 1 2 3\n\nA[,3]  # Третий столбец полностью\n\n[1] 3 6 9\n\n\nЧтобы получить диагональные элементы, есть специальная функция - diag()\n\ndata &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA &lt;- matrix(data, ncol=3, nrow=3, byrow = T)\ndiag(A)\n\n[1] 1 5 9\n\n\nЧтобы узнать размерность матрицы (количество строк и столбцов) - можно использовать функцию dim():\n\ndata &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA &lt;- matrix(data, ncol=3, nrow=3, byrow = T)\ndim(A)\n\n[1] 3 3\n\n\nВ результате применения функции мы получаем числовой вектор, первое значение в котором обозначает количество строк, второе - столбцов.\nЗадание: воспроизведите еще раз матрицу A и напишите код, позволяющий получить произведение первого элемента второй строки и третьего элемента третьей строки.\nС матрицами, как и с векторами, можно совершать разные математические операции - сложение, умножение, вычитание и т.д.:\n\nНапример, прибавить единицу к каждому элементу матрицы:\n\n\ndata &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA &lt;- matrix(data, ncol=3, nrow=3, byrow = T)\nA\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n\nA+1   \n\n     [,1] [,2] [,3]\n[1,]    2    3    4\n[2,]    5    6    7\n[3,]    8    9   10\n\n\n\nУмножить каждый элемент на 2:\n\n\ndata &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA &lt;- matrix(data, ncol=3, nrow=3, byrow = T)\nA\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n\nA*2\n\n     [,1] [,2] [,3]\n[1,]    2    4    6\n[2,]    8   10   12\n[3,]   14   16   18\n\n\n\nВозвести в квадрат:\n\n\ndata &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA &lt;- matrix(data, ncol=3, nrow=3, byrow = T)\nA\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n\nA^2\n\n     [,1] [,2] [,3]\n[1,]    1    4    9\n[2,]   16   25   36\n[3,]   49   64   81\n\n\n\nДовольно часто возникает необходимость транспонирования, когда строки становятся столбцами и наоборот:\n\n\ndata &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA &lt;- matrix(data, ncol=3, nrow=3, byrow = T)\nA\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n\nt(A)\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n\n\nНайдти след матрицы\n\nСлед матрицы - это сумма диагональных элементов:\n\ndata &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA &lt;- matrix(data, ncol=3, nrow=3, byrow = T)\nsum(diag(A))\n\n[1] 15\n\n\n\nСложить две матрицы\n\n\ndata &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA &lt;- matrix(data, ncol=3, nrow=3, byrow = T)\nB &lt;- matrix(1, 3, 3)\nA + B\n\n     [,1] [,2] [,3]\n[1,]    2    3    4\n[2,]    5    6    7\n[3,]    8    9   10\n\n\nЗаметьте, как мы это сделали: мы создали матрицу В одной строкой (матрица 3*3, состоящая из одних единиц).\n\nПеремножить элементы двух матриц:\n\n\ndata &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA &lt;- matrix(data, ncol=3, nrow=3, byrow = T)\nB &lt;- matrix(2, 3, 3)\nA * B\n\n     [,1] [,2] [,3]\n[1,]    2    4    6\n[2,]    8   10   12\n[3,]   14   16   18\n\n\n\nОсуществить матричное умножение:\n\n\ndata &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nA &lt;- matrix(data, ncol=3, nrow=3, byrow = T)\nB &lt;- matrix(2, 3, 3)\nA %*%  B\n\n     [,1] [,2] [,3]\n[1,]   12   12   12\n[2,]   30   30   30\n[3,]   48   48   48\n\n\nВ чем разница между двумя умножениями? В первом случае элементы поэлементно умножаются друг на друга, во втором - происходит умножение матриц по законам линейной алгебры.\nЗадание. Воспроизведите матрицу А из примера выше и осуществите матричное умножение между матрицей А и транспонированной матрицей А.\n\n\n\n3.2.3 Массивы\n\nМассив (array) – объект в R, в котором хранится данные, содержащие более двух измерений. Например, если мы создадим массив с параметрами (2, 3, 4), у нас получится 4 прямоугольные матрицы размером 2 на 3. В массивах хранятся данные только одного типа.\n\nДля того, чтобы создать массив, есть специальная функция array(). Она принимает на входе вектора и использует значения параметра dim, чтобы создать массив.\nПример:\n\nvector1 &lt;- c(5,9,3)\nvector2 &lt;- c(10,11,12,13,14,15)\narr1 &lt;- array(c(vector1,vector2),dim = c(3,3,2))\narr1\n\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    5   10   13\n[2,]    9   11   14\n[3,]    3   12   15\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    5   10   13\n[2,]    9   11   14\n[3,]    3   12   15\n\n\nМы можем присвоить имена строкам, колонкам и матрицам массива с помощью параметра dimnames:\n\nvector1 &lt;- c(5,9,3)\nvector2 &lt;- c(10,11,12,13,14,15)\ncolumn.names &lt;- c(\"COL1\",\"COL2\",\"COL3\")\nrow.names &lt;- c(\"ROW1\",\"ROW2\",\"ROW3\")\nmatrix.names &lt;- c(\"Matrix1\",\"Matrix2\")\nresult &lt;- array(c(vector1,vector2),dim = c(3,3,2),dimnames = list(row.names,column.names,\n   matrix.names))\nresult\n\n, , Matrix1\n\n     COL1 COL2 COL3\nROW1    5   10   13\nROW2    9   11   14\nROW3    3   12   15\n\n, , Matrix2\n\n     COL1 COL2 COL3\nROW1    5   10   13\nROW2    9   11   14\nROW3    3   12   15\n\n\n\n3.2.3.1 Манипуляции с элементами массива\nТак как массив - это по сути совокупность нескольких матриц, то и операции мы с массивами мы можем производить практически такие же.\n\nОбращение к элементам\n\nОбращение к элементам массива практически такое же, как и в случае с матрицами, чуть сложнее, поскольку добавляются новые измерения, но общая логика остается та же - мы в квадратных скобках указываем координаты элемента, которые нам нужны:\n\nvector1 &lt;- c(5,9,3)\nvector2 &lt;- c(10,11,12,13,14,15)\ncolumn.names &lt;- c(\"COL1\",\"COL2\",\"COL3\")\nrow.names &lt;- c(\"ROW1\",\"ROW2\",\"ROW3\")\nmatrix.names &lt;- c(\"Matrix1\",\"Matrix2\")\nresult &lt;- array(c(vector1,vector2),dim = c(3,3,2),dimnames = list(row.names,column.names,\n   matrix.names))\nresult[3,,2] # Третья строка второй матрицы\n\nCOL1 COL2 COL3 \n   3   12   15 \n\nresult[1,3,1] # Третий элемент первой строки первой матрицы\n\n[1] 13\n\nresult[,,2] #Вся вторая матрица\n\n     COL1 COL2 COL3\nROW1    5   10   13\nROW2    9   11   14\nROW3    3   12   15\n\n\n\nСоздание матрицы на основе массива:\n\n\nvector1 &lt;- c(5,9,3)\nvector2 &lt;- c(10,11,12,13,14,15)\ncolumn.names &lt;- c(\"COL1\",\"COL2\",\"COL3\")\nrow.names &lt;- c(\"ROW1\",\"ROW2\",\"ROW3\")\nmatrix.names &lt;- c(\"Matrix1\",\"Matrix2\")\narray1 &lt;- array(c(vector1,vector2),dim = c(3,3,2),dimnames = list(row.names,column.names,\n   matrix.names))\nmatrix1 &lt;- array1[,,1]\nmatrix2 &lt;- array1[,,2]\nmatrix1\n\n     COL1 COL2 COL3\nROW1    5   10   13\nROW2    9   11   14\nROW3    3   12   15\n\nmatrix2\n\n     COL1 COL2 COL3\nROW1    5   10   13\nROW2    9   11   14\nROW3    3   12   15\n\n\n\nАрифметические действия с элементами:\n\n\nvector1 &lt;- c(5,9,3)\nvector2 &lt;- c(10,11,12,13,14,15)\ncolumn.names &lt;- c(\"COL1\",\"COL2\",\"COL3\")\nrow.names &lt;- c(\"ROW1\",\"ROW2\",\"ROW3\")\nmatrix.names &lt;- c(\"Matrix1\",\"Matrix2\")\narray1 &lt;- array(c(vector1,vector2),dim = c(3,3,2),dimnames = list(row.names,column.names,\n   matrix.names))\narray1[1,2,1]+array1[3,2,2]\n\n[1] 22\n\n\n\n\n\n3.2.4 Списки (lists)\nСписок(list) - сложный объект, в котором могут храниться данные разных типов и структуры, включая вектора, матрицы и т.д.\nПример:\n\nA &lt;- list(\"Red\", \"Green\", c(21,32,11), matrix(c(1:9), nrow=3, ncol=3), TRUE, 51.23, 119.1)\nA\n\n[[1]]\n[1] \"Red\"\n\n[[2]]\n[1] \"Green\"\n\n[[3]]\n[1] 21 32 11\n\n[[4]]\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n[[5]]\n[1] TRUE\n\n[[6]]\n[1] 51.23\n\n[[7]]\n[1] 119.1\n\n\nСписки могут даже содержать внутри другие списки!\n\nA &lt;- list(\"Red\", \"Green\", c(21,32,11), matrix(c(1:9), nrow=3, ncol=3), TRUE, 51.23, 119.1)\nA[[8]]&lt;-list(\"One\", 256, TRUE)\nA\n\n[[1]]\n[1] \"Red\"\n\n[[2]]\n[1] \"Green\"\n\n[[3]]\n[1] 21 32 11\n\n[[4]]\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n[[5]]\n[1] TRUE\n\n[[6]]\n[1] 51.23\n\n[[7]]\n[1] 119.1\n\n[[8]]\n[[8]][[1]]\n[1] \"One\"\n\n[[8]][[2]]\n[1] 256\n\n[[8]][[3]]\n[1] TRUE\n\n\nКомпоненты списка также могут иметь имена:\n\nA &lt;- list(\"Red\", \"Green\", c(21,32,11), matrix(c(1:9), nrow=3, ncol=3), TRUE, 51.23, 119.1)\nA[[\"color\"]] &lt;- \"yellow\"\nA\n\n[[1]]\n[1] \"Red\"\n\n[[2]]\n[1] \"Green\"\n\n[[3]]\n[1] 21 32 11\n\n[[4]]\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n[[5]]\n[1] TRUE\n\n[[6]]\n[1] 51.23\n\n[[7]]\n[1] 119.1\n\n$color\n[1] \"yellow\"\n\n\nТаким образом, обратиться к компоненту списка можно по имени или по порядковому номеру элемента:\n\nA &lt;- list(\"Red\", \"Green\", c(21,32,11), matrix(c(1:9), nrow=3, ncol=3), TRUE, 51.23, 119.1)\nA[[\"color\"]] &lt;- \"yellow\"\nA[[\"color\"]]\n\n[1] \"yellow\"\n\nA$color #Альтернативный вариант обращения по имени\n\n[1] \"yellow\"\n\nA[[8]]\n\n[1] \"yellow\"",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Типы и структуры данных</span>"
    ]
  },
  {
    "objectID": "Data-types-and-structures.html#таблицы-данных-data-frame",
    "href": "Data-types-and-structures.html#таблицы-данных-data-frame",
    "title": "3  Типы и структуры данных",
    "section": "3.3 Таблицы данных (data frame)",
    "text": "3.3 Таблицы данных (data frame)\nДля аналитиков данных это самый важный объект, с которым приходится работать чаще всего. Большинство из тех данных, с которыми нам приходится иметь дело, хранятся именно в формате датафрейма.\nТаблица данных (data frame) - может включать данные разного типа, но только по столбцам. Иными словами, в таблице может быть несколько типов данных, но в каждом столбце может быть только один тип.\n\ndf&lt;- data.frame(id = c(1:4), city = c(\"Москва\",\"Лондон\",\"Париж\",\"Нью-Йорк\"), population = c(16555000, 10840000,10960000,21045000))\ndf\n\n  id     city population\n1  1   Москва   16555000\n2  2   Лондон   10840000\n3  3    Париж   10960000\n4  4 Нью-Йорк   21045000\n\n\nОбращаться к элементам таблицы данных можно точно так же, как и к элементам матрицы:\n\ndf&lt;- data.frame(id = c(1:4), city = c(\"Москва\",\"Лондон\",\"Париж\",\"Нью-Йорк\"), population = c(16555000, 10840000,10960000,21045000))\ndf[1,2]\n\n[1] \"Москва\"\n\n\nЧтобы добавить новую переменную, нужно использовать знак $:\n\ndf&lt;- data.frame(id = c(1:4), city = c(\"Москва\",\"Лондон\",\"Париж\",\"Нью-Йорк\"), population = c(16555000, 10840000,10960000,21045000))\ndf$country&lt;-c(\"Россия\", \"Великобритания\", \"Франция\", \"США\")\ndf$pop2&lt;-df$population/1000\ndf\n\n  id     city population        country  pop2\n1  1   Москва   16555000         Россия 16555\n2  2   Лондон   10840000 Великобритания 10840\n3  3    Париж   10960000        Франция 10960\n4  4 Нью-Йорк   21045000            США 21045\n\n\nС помощью этого же знака, можно вывести все значения той или иной переменной:\nЧтобы добавить новую переменную, нужно использовать знак $:\n\ndf&lt;- data.frame(id = c(1:4), city = c(\"Москва\",\"Лондон\",\"Париж\",\"Нью-Йорк\"), population = c(16555000, 10840000,10960000,21045000))\ndf$country&lt;-c(\"Россия\", \"Великобритания\", \"Франция\", \"США\")\ndf$pop2&lt;-df$population/1000\ndf$city\n\n[1] \"Москва\"   \"Лондон\"   \"Париж\"    \"Нью-Йорк\"\n\n\nЧтобы узнать размерность таблицы, можно воспользоваться уже известной нам функции dim():\n\ndf&lt;- data.frame(id = c(1:4), city = c(\"Москва\",\"Лондон\",\"Париж\",\"Нью-Йорк\"), population = c(16555000, 10840000,10960000,21045000))\ndf$country&lt;-c(\"Россия\", \"Великобритания\", \"Франция\", \"США\")\ndf$pop2&lt;-df$population/1000\ndim(df)\n\n[1] 4 5\n\n\nЕсли у нас есть список векторов, мы можем их легко трансформировать в датафрейм:\n\npeople &lt;- list(name=c(\"Alice\", \"Bob\", \"Charlie\"), \n               grade=c(99.4, 87.6, 22.1), \n               sex=c(\"F\", \"M\", \"M\"))\nas.data.frame(people)\n\n     name grade sex\n1   Alice  99.4   F\n2     Bob  87.6   M\n3 Charlie  22.1   M\n\n\nВ R содержатся много загруженных наборов данных, таких например, как mtcars, в котором содержатся данные по 32 маркам автомобилей:\n\nmtcars\n\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nFiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nFiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\n\nСамые простые операции с таблицами данных заключаются в выводе данных, наименований строк и столбцов.\nКак вывести первые несколько наблюдений?\n\nhead(mtcars)\n\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\n\nКак вывести последние несколько наблюдений?\n\ntail(mtcars)\n\n                mpg cyl  disp  hp drat    wt qsec vs am gear carb\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.7  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.9  1  1    5    2\nFord Pantera L 15.8   8 351.0 264 4.22 3.170 14.5  0  1    5    4\nFerrari Dino   19.7   6 145.0 175 3.62 2.770 15.5  0  1    5    6\nMaserati Bora  15.0   8 301.0 335 3.54 3.570 14.6  0  1    5    8\nVolvo 142E     21.4   4 121.0 109 4.11 2.780 18.6  1  1    4    2\n\n\nКакие переменные содержатся в наборе mtcars?\n\nnames(mtcars)\n\n [1] \"mpg\"  \"cyl\"  \"disp\" \"hp\"   \"drat\" \"wt\"   \"qsec\" \"vs\"   \"am\"   \"gear\"\n[11] \"carb\"\n\n\nНу, и напоследок, представим сводку о данных, содержащихся в этом наборе:\n\nsummary(mtcars)\n\n      mpg             cyl             disp             hp       \n Min.   :10.40   Min.   :4.000   Min.   : 71.1   Min.   : 52.0  \n 1st Qu.:15.43   1st Qu.:4.000   1st Qu.:120.8   1st Qu.: 96.5  \n Median :19.20   Median :6.000   Median :196.3   Median :123.0  \n Mean   :20.09   Mean   :6.188   Mean   :230.7   Mean   :146.7  \n 3rd Qu.:22.80   3rd Qu.:8.000   3rd Qu.:326.0   3rd Qu.:180.0  \n Max.   :33.90   Max.   :8.000   Max.   :472.0   Max.   :335.0  \n      drat             wt             qsec             vs        \n Min.   :2.760   Min.   :1.513   Min.   :14.50   Min.   :0.0000  \n 1st Qu.:3.080   1st Qu.:2.581   1st Qu.:16.89   1st Qu.:0.0000  \n Median :3.695   Median :3.325   Median :17.71   Median :0.0000  \n Mean   :3.597   Mean   :3.217   Mean   :17.85   Mean   :0.4375  \n 3rd Qu.:3.920   3rd Qu.:3.610   3rd Qu.:18.90   3rd Qu.:1.0000  \n Max.   :4.930   Max.   :5.424   Max.   :22.90   Max.   :1.0000  \n       am              gear            carb      \n Min.   :0.0000   Min.   :3.000   Min.   :1.000  \n 1st Qu.:0.0000   1st Qu.:3.000   1st Qu.:2.000  \n Median :0.0000   Median :4.000   Median :2.000  \n Mean   :0.4062   Mean   :3.688   Mean   :2.812  \n 3rd Qu.:1.0000   3rd Qu.:4.000   3rd Qu.:4.000  \n Max.   :1.0000   Max.   :5.000   Max.   :8.000",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Типы и структуры данных</span>"
    ]
  },
  {
    "objectID": "Data-types-and-structures.html#самостоятельная-работа-1",
    "href": "Data-types-and-structures.html#самостоятельная-работа-1",
    "title": "3  Типы и структуры данных",
    "section": "3.4 Самостоятельная работа",
    "text": "3.4 Самостоятельная работа\nСамостоятельная работа №22",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Типы и структуры данных</span>"
    ]
  },
  {
    "objectID": "Intro-to-RMarkdown.html",
    "href": "Intro-to-RMarkdown.html",
    "title": "4  Основы работы с R Markdown",
    "section": "",
    "text": "4.1 Что такое R Markdown и зачем он нужен\nMarkdown (Маркдаун) - это облегченный язык разметки с синтаксисом форматирования обычного текста, на основе которой могут быть созданы документы разного формата - HTML (веб страницы), PDF, документы в формате MS Word, интерактивные приложения. Больше информации о R Markdown можно посмотреть на официальной странице проекта http://rmarkdown.rstudio.com.\nВ R Markdown создается огромное количество документов - научных статей и книг, диссертаций, data science блогов и так далее. Лекция, которую вы сейчас читаете, тоже была создана в R Markdown, и ваш итоговый проект по курсу тоже будет реализован именно в нем.\nВот только несколько примеров того, что можно создать в маркдауне:\nСсылка на галерею работ: https://rmarkdown.rstudio.com/gallery.html\nMarkdown был создан дизайнером и блогером в области информационных технологий Джоном Грубером в 2004 году (https://twitter.com/gruber) и сегодня является одним из самых популярных языков разметки. Файлы, создаваемые с помощью маркдауна, имеют расширение .md или .markdown, а если они создаются в R - .Rmd.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Основы работы с R Markdown</span>"
    ]
  },
  {
    "objectID": "Intro-to-RMarkdown.html#что-такое-r-markdown-и-зачем-он-нужен",
    "href": "Intro-to-RMarkdown.html#что-такое-r-markdown-и-зачем-он-нужен",
    "title": "4  Основы работы с R Markdown",
    "section": "",
    "text": "4.1.1 В чем заключаются преимущества работы в R Markdown?\nR Markdown - это программная среда, используемая для оформления результатов научных исследований и сочетающая возможности текстового редактора и редактора программного кода.\n\n\n4.1.2 Как это происходит?\nВы создаете документ в R Markdown на основе определенной структуры, состоящей из разделов, параграфов, глав и т.д.\nЧасти текста оформляются с помощью специального синтаксиса, а текст внутри них снабжается кодом, с помощью которого Вы обрабатыаете данные, создаете модели, визуализируете результаты исследования, ссылаетесь на научные и документационные источники, приводите цитаты, дополняете свой текст иллюстрациями, полученными из внешних ресурсов (например, фото из Интернета или репродукциями всемирно известных картин из музеев, а может быть и собственными фото- и дизайнерскими работами).\nКогда все готово, Вы просто нажимаете кнопку knit (knit по-английски “вязать”), и маркдаун “связывает” отдельные элементы, преврашая их в целостный документ, отформатированный определенным образом:\n\nсоблюдены размеры страницы\nтекст оформлен с помощью нужных шрифтов\nимеет отступы, цвет, заголовки, подписи к рисункам и таблицам и т.д.\n\nОсновными достоинствами и стимулами к использованию R Markdown являются следующие:\n\nэто легкий доступный язык форматирования для не-программистов, позволяющий создавать Интернет-страницы и другие документы;\nмаркдаун позволяет конвертировать код сразу во множество форматов – PDF, HTML, docs и т.д.;\nмаркдаун позволяет писать код не только на R, но и других языках – Python, Bash, D3, SQL, Stan, Rcpp;\nэто возможность создания полностью воспроизводимых документов, сочетающих код (расчеты, методы анализа) и текст. Для научных исследований это чрезвычайно важно, ведь как правило в научных текстах содержатся уже готовые результаты, а как они были получены – не известно. Имея доступ к исходным данным и файлу в R Markdown, другие исследователи могут повторить эксперимент или создать свои собсвенные;\nблагодаря R Markdown у исследователей появляется возможность не отвлекаться и сразу делать все “в одном месте”;\nмаркдаун позволяет использовать средства форматирования для автоматического создания красивых таблиц и графиков в соответствии с публикационными требованиями (думать о содержании, а не о форме);\nнемаловажно и то, что в маркдауне можно быстро и легко создавать динамические и интерактивные документы и приложения (дашборды, shiny-приложения), что может быть очень востребовано при работе с бизнес-партнерами.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Основы работы с R Markdown</span>"
    ]
  },
  {
    "objectID": "Intro-to-RMarkdown.html#установка-r-markdown",
    "href": "Intro-to-RMarkdown.html#установка-r-markdown",
    "title": "4  Основы работы с R Markdown",
    "section": "4.2 Установка R Markdown",
    "text": "4.2 Установка R Markdown\nБудем исходить из того, что на ваших компьютерах уже установлены последние версии языка R и интерфейса для работы с ним - RStudio IDE. Если это еще не сделано, рекомендуем обратиться на официальные сайты (https://www.r-project.org) (R Core Team 2021) и RStudio IDE (https://www.rstudio.com).\nПосле того, как R и RStudio установлены, нужно открыть программу RStudio и установить библиотеку rmarkdown:\n\ninstall.packages('rmarkdown')\n\nДля того, чтобы корректно создавать и работать с документами в формате PDF, рекомендуется также установить LaTeX - набор расширений для компьютерной верстки и разметки текста, облегчающий набор сложных документов. Авторы R Markdown предлагают установить для этого библиотеку TinyTeX (https://yihui.name/tinytex/):\n\ninstall.packages(\"tinytex\")\n\nС этими двумя библиотеками в R Markdown можно скомпилировать практически любые документы, но иногда, в зависимости от конкретных задач, потребуется обращение и к другим программным пакетам.\nЭто и следующие практические задания мы будем выполнять в RMarkdown.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Основы работы с R Markdown</span>"
    ]
  },
  {
    "objectID": "Intro-to-RMarkdown.html#создание-нового-документа-в-r-markdown",
    "href": "Intro-to-RMarkdown.html#создание-нового-документа-в-r-markdown",
    "title": "4  Основы работы с R Markdown",
    "section": "4.3 Создание нового документа в R Markdown",
    "text": "4.3 Создание нового документа в R Markdown\nЧтобы создать новый документ в R Markdown необходимо открыть программу RStudio, выбрать пукты меню File - New File - R Markdown:\n\nДалее, в открывшимся окне нужно написать название документа, фамилию и инициалы автора и выбрать нужный формат - HTML, PDF или Word. Если с помощью R Markdown планируется создание презентаций, интерактивных веб-приложений Shiny и документов на основе шаблонов (документов в формате PDF, адаптированных под определенные требования, например ведущих реферируемых журналов), то нужно в списке слева выбрать не документ, а соответствующий пункт. Нажать OK.\n\nПосле нажатия кнопки OK, программа откроет образец файла .Rmd на английском языке с примерами оформления текста и примерами кода для обработки и визуализации на основе включенных в базовый R наборов данных. Код и текст легко различить: у текста белый фон, тогда как у кода - серый, и такие серые вставки, где пишется код, называют чанками, от английского слова chunk - “кусок”.\nВсе просто: мы пишем текст, а в нужных местах вставляем куски кода - чанки, chunks. Код обрабатывается автоматически, и результаты отображаются в документе. Таким образом, нет необходимости сохранять наши результаты в виде отдельных таблиц или рисунков, все происходит в одном месте - мы обрабатываем результаты исследования и описываем их в одном месте, в одной программе. И это, согласитесь, очень здорово. Безусловно, работа с маркдауном потребует некоторых усилий, поскольку потребуется изменить свой “исследовательский образ жизни”. Так, если вы привыкли работать с SPSS, а потом описывать в Word, то необходимо будет слегка перестроить рабочие процессы, как бы заново научиться анализировать в другом формате. Но зато потом вы будете вознаграждены, во-первых, уникальными результатам анализа и прекрасными визуализациями, научитесь оптимизировать свой код и проводить анализ, а, главное, получать нужные рассчеты гораздо быстрее и сразу в приемлемом для публикации виде, сможете сэкономить свое время.\nНачало и конец чанка обозначается тремя машинописными обратными апострофами {```}, а между ними располагаются обычные строки кода, которые мы уже видели, когда работали в файле скрипта R на прошлых занятиях.\nЧтобы создать новый чанк, нужно нажать на клавиатуре: Ctrl + Alt + I или выбрать в меню специальную кнопку (см. рисунок ниже):\n\nДокумент, который был создан автоматически, будет выглядеть примерно так:\n\nКогда Вы создадите свой первый документ в маркдауне самостоятельно, обратите внимание на код в начале чанка echo = FALSE - он означает, что код будет воспроизведен, но не будет отображаться после того, как документ будет собран, в противном случае читатель увидит и код, и результаты его работы.\nПосле того, как пробный документ откроется, предлагаем пока ничего в нем не менять, а сразу нажать на кнопку knit . Программа предложит сохранить документ, необходимо это сделать. После сохранения автоматически начнется процесс “сшивки”, и после его окончания, поскольку мы выбрали формат HTML, откроется новое окно браузера, в котором будет отображаться примерно следующее:\n\nЕсли при нажатии кнопки knit выбрать Knit to Word, то будет создан новый документ в программе Word, который будет содержать аналогичный текст и графики, что и html-документ. Вот как это может выглядеть: \nИтак, в рамках данного занятия мы узнали:\n\nЧто такое R Markdown и что можно делать с его помощью\nРазобрались с установкой необходимых библиотек, которые нам пригодятся для создания документов с помощью маркдауна\nСоздали тестовый документ и научились применять функцию knit для того, чтобы отобразить разметку в форматах HTML и docx.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Основы работы с R Markdown</span>"
    ]
  },
  {
    "objectID": "Intro-to-RMarkdown.html#задание-для-самостоятельной-работы",
    "href": "Intro-to-RMarkdown.html#задание-для-самостоятельной-работы",
    "title": "4  Основы работы с R Markdown",
    "section": "4.4 Задание для самостоятельной работы",
    "text": "4.4 Задание для самостоятельной работы\n\nСоздать новый документ RMarkdown.\nИзменить текст и код, используя материалы предыдущих уроков.\nСделать небольшие описания.\nСшить получившийся документ в формате html. Внимание: в начале каждого чанка должно быть указано {r echo=TRUE}, чтобы я могла видеть ваш код.\nПриложить файл html в качестве ответа на задание.\n\nПолезные ссылки:\n\nhttps://r4ds.had.co.nz/r-markdown.html\nhttps://docs.microsoft.com/ru-ru/contribute/markdown-reference\nhttps://www.markdownguide.org/\nhttps://rmarkdown.rstudio.com/authoring_quick_tour.html\nhttps://www.rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Основы работы с R Markdown</span>"
    ]
  },
  {
    "objectID": "Functions.html",
    "href": "Functions.html",
    "title": "5  Основы функционального программирования",
    "section": "",
    "text": "5.1 Понятие функции и ее основные элементы\nФункция представляет собой набор утверждений, организованных вместе для выполнения определенной задачи.\nЭто часть программного кода, имеющий определенное имя, который может быть вызван сам по себе или в других частях программы.\nФормула функции\nВ R функция создается очень просто - с помощью ключевого слова function. Базовый синтаксис у функции следующий:\nfunction_name &lt;- function(arg_1, arg_2, ...) {\n   Function body \n}\nКомпоненты функции\nУ функции есть несколько частей",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Основы функционального программирования</span>"
    ]
  },
  {
    "objectID": "Functions.html#понятие-функции-и-ее-основные-элементы",
    "href": "Functions.html#понятие-функции-и-ее-основные-элементы",
    "title": "5  Основы функционального программирования",
    "section": "",
    "text": "В R имеется множество встроенных функций, и огромное количество дополнительных функций можно найти в различных библиотеках. Каждый пользователь может создавать свои собственные функции.\n\n\n\n\n\n\n\n\n\nФункция является объектом, и значит интерпретатор R может проверить, насколько хорошо функция выполняется, нужны ли функции какие-то аргументы для выполнения и есть ли у программы достаточно информации, чтобы все сделать так, как описано в функции.\n\n\n\n\n\n\n\n\n\nВ свою очередь функция выполняет задачу и выдает (возвращает, return) какие-то результаты, которые могут быть сохранены в дальнейшем как отдельные объекты.\n\n\n\n\n\n\n\n\n\nFunction Name (имя функции) − тут все просто - это имя функции, которое хранится в окружении и обозначает конкретный объект (то есть саму функцию). Зная имя функции, ее можно вызвать в любое время и вставить в любую часть программного кода.\n\n\nArguments (аргументы) − это те элементы, параметры, значения, которые вводятся в функцию, чтобы она работала. Аргументы не являются обзательными, функция может иногда работать и без них, либо они могут быть указаны по умолчанию.\n\n\nFunction Body (тело функции) − пожалуй, самая главная часть функции, содержащая утверждения, определяющие то, что именно делает данная функция.\n\n\nReturn Value (возвращаемое значение) − возвращаемое значение - это результат обработки последнего выражения в теле функции, то есть ее конечный результат. Если в функции заложено множество действий - то это последнее действие.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Основы функционального программирования</span>"
    ]
  },
  {
    "objectID": "Functions.html#встроенные-функции",
    "href": "Functions.html#встроенные-функции",
    "title": "5  Основы функционального программирования",
    "section": "5.2 Встроенные функции",
    "text": "5.2 Встроенные функции\nМожно привести огромное количество базовых функций, таких как seq(), mean(), max(), sum(x), paste(...) и т. д. Они вызываются напрямую при написании программы.\n\n# Создать последовательность чисел от 32 до 44\nseq(32,44)\n\n# Найти среднее чисел от 25 до 82.\nmean(25:82)\n\n# Найти сумму чисел от 41 до 68.\nsum(41:68)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Основы функционального программирования</span>"
    ]
  },
  {
    "objectID": "Functions.html#функции-apply-lapply-sapply-tapply",
    "href": "Functions.html#функции-apply-lapply-sapply-tapply",
    "title": "5  Основы функционального программирования",
    "section": "5.3 Функции apply(), lapply(), sapply(), tapply()",
    "text": "5.3 Функции apply(), lapply(), sapply(), tapply()\nСемейство функций apply() позволяет производить различные преобразования с отдельными элементами векторов, матриц и датафреймов. Такие действия в процессе анализа данных приходится проводить довольно часто. Например, нам может потребоваться сдвинуть значения переменных на какую либо константу, или провести трансформации, необходимые для нормализации данных.\n\n5.3.1 apply()\nОбщая формула для функции apply():\napply(data, MARGIN, FUN),\nГде:\n\ndata: массив или матрица\nMARGIN: данный аргумент принимает значения 1 или 2\nMARGIN=1: манипуляции проводятся со строками\nMARGIN=2: манипуляции проводятся со столбцами\nMARGIN=c(1,2): манипуляции проводятся со строками и столбцами одновременно\nFUN: функция, которую необходимо применить, например, рассчитать среднее mean(), медиану median(), сумму sum(), минимум min(), максимум max() и др. Также можно применить пользовательские функции.\n\nПростой пример применения данной функции - суммировать данные по столбцам (запустите код ниже и посмотрите на результат в последней строке):\n\nm1 &lt;- matrix(1:10,nrow=5, ncol=6)\nm1\na_m1 &lt;- apply(m1, 2, sum)\n\na_m1\n\n Самостоятельное задание: попробуйте изменить код так, чтобы сумма считалась не по столбцу, а по строке.\n\n\n5.3.2 lapply()\nФункция lapply() полезна для осуществления операций над списками и возвращает список объектов такой же длины. При этом каждый объект является результатом применения функции к элементу исходного списка. Эта функция может применяться к спискам, векторам или датафрейму, но на выходе - всегда список.\nОбщая формула:\nlapply(data, FUN)\nАргументы:\n\ndata: вектор или другой объект\nFUN: функцию, которую мы собираемся применять к каждому объекту x.\n\nl в функции lapply() обозначает list (список). Различия между lapply() и apply() заключаются именно в формате вывода.\nфункции lapply() не требуется аргумент MARGIN.\nПриведем примеры. Допустим, у нас есть список, в котором содержатся два элемента - вектор A и датафрейм B. Предположим, что нам нужно посчитать сумму по каждому элементу списка (отдельно у вектора и у датафрейма).\n\na &lt;- list(A = c(8, 9, 7, 5),\n          B = data.frame(x = 1:5, y = c(5, 1, 0, 2, 3)))\na\n\n$A\n[1] 8 9 7 5\n\n$B\n  x y\n1 1 5\n2 2 1\n3 3 0\n4 4 2\n5 5 3\n\nlapply(a, sum)\n\n$A\n[1] 29\n\n$B\n[1] 26\n\n\nЕще один пример - со строковыми данными. Поменяем названия фильмов с большой буквы на маленькую.\n\nmovies &lt;- c(\"SPYDERMAN\",\"BATMAN\",\"VERTIGO\",\"CHINATOWN\")\nmovies_lower &lt;-lapply(movies, tolower)\nmovies\n\n[1] \"SPYDERMAN\" \"BATMAN\"    \"VERTIGO\"   \"CHINATOWN\"\n\nmovies_lower\n\n[[1]]\n[1] \"spyderman\"\n\n[[2]]\n[1] \"batman\"\n\n[[3]]\n[1] \"vertigo\"\n\n[[4]]\n[1] \"chinatown\"\n\n\nЧтобы значения из списка опять стали вектором, нужно применить функцию unlist().\n\nunlist(movies_lower)\n\n[1] \"spyderman\" \"batman\"    \"vertigo\"   \"chinatown\"\n\n\nСамостоятельное задание: создайте список из двух датафреймов, в каждом из которых содержалось бы по две переменных с 5 значениями. Затем примените функцию lapply() для того, чтобы поcчитать максимальные значения в каждом датафрейме (функция max()).\n\n\n5.3.3 sapply()\nФункция sapply() используются со списками, векторами или датафреймами и на выходе дают вектор или матрицу. Функция полезна для операций над списками, она работает почти так же, как и lapply(), только возвращает вектор.\nПриведем пример с известным набором cars, в котором содержится информация о скорости и тормозном пути машин 1920-х гг.\nПрименим функцию sapply(), чтобы посчитать минимальные значения:\n\nsapply(cars, min)\n\nspeed  dist \n    4     2 \n\n\nСравним с lapply():\n\nlapply(cars, min)\n\n$speed\n[1] 4\n\n$dist\n[1] 2\n\n\n\n\n5.3.4 tapply()\nФункции tapply() рассчитывает какой-либо показатель (среднее, моду, медиану, минимум, максимум и т.д.) или применяет пользовательскую функцию к каждому элементу вектора в зависимости от уровней факторной переменной. Очень полезная функция, позволяющая отобрать значения и применить функцию именно к ним (провести анализ по группам).\nОбщая формула:\ntapply(data, INDEX, FUN = NULL, ...)\nАргументы:\n\ndata: данные, которые мы хотим агрегировать с помощью tapply\nINDEX: список факторов (группирующих переменных)\nFUN: функция, которую нужно применить к каждому элементу x\n...: другие аргументы, которые мы можем передать функции.\n\nВ процессе анализа данных очень часто возникает необходимость подсчета каких-либо показателей, например, посчитать средние значения в группах наблюдений, образованных на основе каких-либо характеристик. Примеры: проанализировать средний уровень доходов в зависимости от региона, страны, социального статуса и т.д.\nЧтобы понять, как это работает, давайте воспользумся датасетом iris, встроенным в базовый R, содержащий измерения 4 параметров (ширина и длина лепестков и чашелистников) у 150 цветков ирисов, принадлежащих к трем различным видам (по 50 каждого вида) - iris setosa (ирис щетинистый, iris versicolor (ирис разноцветный) и iris virginica (ирис виргинский):\n\nЭто хорошо известный в сфере машинного обучения набор данных, который в используется, например, для иллюстрации того, как можно разработать модели, позволяющие предсказать принадлежность к одному из классов.\nМы можем использовать функцию tapply(), чтобы посчитать медианные значения ширины чашелистника для каждого вида:\n\ntapply(iris$Sepal.Width, iris$Species, median)# знак $ позволяет обратиться к отдельной переменной в наборе данных, Sepal.Width - переменная, хранящая значения ширины чашелистника, Species - переменная принадлежности к виду.\n\n    setosa versicolor  virginica \n       3.4        2.8        3.0 \n\n\n Самостоятельное задание: попробуйте применить функцию tapply() к другим переменным набора - Sepal.Length, Petal.Width, Petal.Length, заменив медиану на максимальное значение (функция max()).",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Основы функционального программирования</span>"
    ]
  },
  {
    "objectID": "Functions.html#пользовательские-функции",
    "href": "Functions.html#пользовательские-функции",
    "title": "5  Основы функционального программирования",
    "section": "5.4 Пользовательские функции",
    "text": "5.4 Пользовательские функции\nКроме встроенных или находящихся в загруженных библиотеках мы легко можем создавать свои собственные функции. Они могут быть достаточно специфическими и использоваться для решения различных задач. Если какое-то однотипное действие выполняется множетсво раз, стоит подумать о создании функции, которая может автоматизировать этот процесс. Однажды созданная функция может потом использоваться наравне со встроенными.\nРассмотрим некоторые особенности создания и использования пользовательских функций.\n\n5.4.1 Пример простой функции\nПредположим, нам нужна функция, которая бы возводила в квадрат какое-то число:\n\nsquare&lt;- function(a) {\n   return(a^2)\n}   \n# Пробуем вызвать эту функцию, задав в качестве аргумента цифру 6.\nsquare(6)\n\n[1] 36\n\n\nДавайте посмотрим на то, как устроена эта функция.\n\nПервая строка:\n\nsquare&lt;- function(a) {\nМы даем функции имя - square - оно должно нам подсказывать, что функция имеет дело с квадратами))) Впрочем, имя может быть любым, например, my_function.\nДалее следует оператор присваивания &lt;- и ключевое слово function, за которым в скобках указывается какой-то аргумент, с которым будут далее происходить какие-то трансформации.\nМы видим, что в нашей функции аргумент один - a.\nЗаканчивается строка открывающейся фигурной скобкой.\nДалее следует тело функции.\n\nВторая строка:\n\nreturn(a^2)\nПоскольку функция простая, мы сразу получаем return value - возвращаемое значение.\nОбратите внимание, что в конце функции обязательно ставится закрывающая фигурная скобка.\n\n\n5.4.2 Вызов функции без аргумента\nРассмотрим еще один пример:\n\n# Создаем функцию без аргумента\nseq_squared5 &lt;- function() {\n  seq&lt;-1:5\n  return(seq^2)\n\n}   \n\n# Запускаем функцию\nseq_squared5()\n\n[1]  1  4  9 16 25\n\n\nЧто изменилось? Изменилось то, в первой функции мы указывали аргумент, а во второй все вычисления сразу “зашиты” в нашу функцию и она может выполнять только одно дело - формировать последовательность от 1 до 5 и возводить каждое число в квадрат.\n\n\n5.4.3 Создание функции с аргументами, различающимися по позиции и именам\nАргументы функции могут предоставляться в той же последовательности, в которой они написаны в функции, без указания имен, или в другой последовательности, но с обязательным указанием имени.\nРассмотрим пример функции, в которой есть три аргумента и которая выполняет следующие действия: первые два аргумента перемножаются, а затем к произведению прибавляется третий аргумент.\n\n# Создаем функцию с аргументами.\nfunction3 &lt;- function(a,b,c) {\n   result &lt;- a * b + c\n   print(result)\n}\n\n# Вызываем функцию, перечисляя аргументы по порядку.\nfunction3(5,3,11)\n\n[1] 26\n\n# Вызываем фунцию, называя аргументы поименно.\nfunction3(a = 11, b = 5, c = 3)\n\n[1] 58\n\n\nПопробуйте поменять аргументы местами и посмотреть, как будет вести себя функция.\n\n\n5.4.4 Создание функции с аргументами по умолчанию\nМы можем определить значение аргумента функции в ходе ее определения и запустить функцию без дополнительного назначения аргументов. В этом случае мы получим некоторый результат по умолчанию. Но мы можем изменить эти исходные значения, и получить новый результат.\nПростой пример такой функции:\n\n# Создаем новую функцию с аргументами.\nfunction4 &lt;- function(a = 3, b = 6) {\n   result &lt;- a * b\n   print(result)\n}\n\n# Запускаем функцию без аргументов в скобках.\nfunction4()\n\n[1] 18\n\n# Вызываем функцию с новыми значениями аргументов.\nfunction4(9,5)\n\n[1] 45\n\n\n\n\n5.4.5 “Ленивая” (Lazy) обработка аргументов функции\nАргументы в функции обрабатываются “лениво” (да-да, в жаргоне программистов есть именно такие выражения - “ленивая функция”, “ленивая загрузка”, “ленивая обработка”), что означает, что эти аргументы вызываются и обрабатываются только в определенный момент времени, когда это требует функция.\n\n# Создаем функцию с двумя аргументами.\nnew.function &lt;- function(a, b) {\n   print(a^2)\n   print(a)\n   print(b)\n}\n\n# Пробуем применить функцию только с одним аргументом.\nnew.function(6)\n\nФункция требует два аргумента, но мы предоставили только один, и поскольку имен мы не указывали, по умлочанию наша функция определила этот аргумент как первый, то есть аргумент a. До определенного момента все было “ок”, поскольку аргумент b не был нужен, но как только дело дошло до строчки print(b) - обнаружилось, что аргумент b отсутствует, и появилась ошибка.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Основы функционального программирования</span>"
    ]
  },
  {
    "objectID": "Functions.html#самостоятельная-работа",
    "href": "Functions.html#самостоятельная-работа",
    "title": "5  Основы функционального программирования",
    "section": "5.5 Самостоятельная работа",
    "text": "5.5 Самостоятельная работа\nУпражнение 1 Создайте функцию, которая будет возвращать сумму двух чисел. Назовите функцию mysum.\nУпражнение 2 Создайте функцию, проверяющую принадлежность числа некоторому вектору. Если число в векторе содержится, функция должна вернуть TRUE.\nУпражнение 3 Создайте функцию, на входе которой будет даваться датафрейм, а на выходе - наименование каждой переменной и тип (класс) данных, которые в них содержатся. Например, переменная1 числовая.\nУпражнение 4 Создать функцию, аргументами которой являются вектор и число. На выходе функция должна показывать, сколько раз число встречается в данном векторе.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Основы функционального программирования</span>"
    ]
  },
  {
    "objectID": "ImportExport.html",
    "href": "ImportExport.html",
    "title": "6  Импорт и экспорт данных",
    "section": "",
    "text": "6.1 Импорт и экспорт файлов Excel\nИмпортировать данные из файла Excel можно несколькими способами.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Импорт и экспорт данных</span>"
    ]
  },
  {
    "objectID": "ImportExport.html#импорт-и-экспорт-файлов-excel",
    "href": "ImportExport.html#импорт-и-экспорт-файлов-excel",
    "title": "6  Импорт и экспорт данных",
    "section": "",
    "text": "Важно!: сохраните все файлы с дополнительными материалами к заданию в ту же директорию, где будете работать (лучше всего создать новый проект под это занятие). Это нужно для того, чтобы лишний раз не прописывать путь к файлу).\nЕще один удобный ход - установить в настройках рабочую директорию в ту же папку, где лежит файл со скриптом:\nSession - Set Working Directory - To Source File Location",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Импорт и экспорт данных</span>"
    ]
  },
  {
    "objectID": "ImportExport.html#способ-1.-скопировать-из-excel-и-сохранить-в-r.",
    "href": "ImportExport.html#способ-1.-скопировать-из-excel-и-сохранить-в-r.",
    "title": "6  Импорт и экспорт данных",
    "section": "6.2 Способ 1. Скопировать из Excel и сохранить в R.",
    "text": "6.2 Способ 1. Скопировать из Excel и сохранить в R.\nДля того, чтобы воспользоваться этим способом, сохраните файл, откройте его, выделите все данные и скопируйте их (Ctrl+C). Затем запустите код ниже:\n\nmy_data &lt;- read.table(file = \"clipboard\", sep = \"\\t\", header=TRUE)\n\nЕсли все сделано правильно, то у Вас в рабочем окружении появится объект my_data, в котором будет 9 наблюдений и 14 переменных (это результаты реализации государственной программы содействия добровольному переселению соотечественников). Чтобы увидеть данные, нажмите на него и он откроется в просмотрщике.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Импорт и экспорт данных</span>"
    ]
  },
  {
    "objectID": "ImportExport.html#способ-2.-импорт-из-файла-excel.",
    "href": "ImportExport.html#способ-2.-импорт-из-файла-excel.",
    "title": "6  Импорт и экспорт данных",
    "section": "6.3 Способ 2. Импорт из файла Excel.",
    "text": "6.3 Способ 2. Импорт из файла Excel.\nПредположим, файл Excel у нас большой, содержит несколько листов, скопировать все и вставить - не очень удачная идея. В этом случае (честно говоря, такие случаи случаются гораздо чаще, чем описанные в способе 1), нам нужно импортировать данные из файла.\nЭто сделать не так сложно, к счастью, у нас есть библиотека readxl, которая как раз и предназначена для таких целей.\nПорядок действий следующий:\n\nЗагружаем библиотеку readxl.\nЗапускаем функцию read_excel(file excel, sheet = \"name of sheet\")\n\nДавайте загрузим тот же файл с соотечественниками, что и в примере выше:\n\nlibrary(readxl)\ndf_excel&lt;-read_excel(\"ProgResCompatriots.xlsx\", sheet=1)\n\nВ рабочем окружении отобразился новый объект, его содержание идентично my_data. Чтобы посмотреть - нужно нажать на голубой кружок с белым треугольником рядом с именем:\n\nПамятка по работе с readxl:",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Импорт и экспорт данных</span>"
    ]
  },
  {
    "objectID": "ImportExport.html#экспорт-результатов-в-excel",
    "href": "ImportExport.html#экспорт-результатов-в-excel",
    "title": "6  Импорт и экспорт данных",
    "section": "6.4 Экспорт результатов в Excel",
    "text": "6.4 Экспорт результатов в Excel\nДавайте попробуем создать новую переменную, куда посчитаем среднее количество перехавших за год в период с 2010 по 2021 гг.\n\nlibrary(dplyr)\ndf_excel$Среднее&lt;-sapply(df_excel[,2:13], mean)\n\nУ нас появился новый столбец в конце таблицы.\nТеперь эту новую таблицу нужно сохранить в новый файл. Для этого нам понадобится библиотека xlsx, а в ней - функция write.xlxs().\nЗапустите следующий код:\n\ninstall.packages(\"xlsx\") #установим библиотеку\nlibrary(xlsx)\nwrite.xlsx(df_excel, \"df_excel_new.xlsx\")",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Импорт и экспорт данных</span>"
    ]
  },
  {
    "objectID": "ImportExport.html#импорт-и-экспорт-файла-в-формате-csv",
    "href": "ImportExport.html#импорт-и-экспорт-файла-в-формате-csv",
    "title": "6  Импорт и экспорт данных",
    "section": "6.5 Импорт и экспорт файла в формате CSV",
    "text": "6.5 Импорт и экспорт файла в формате CSV\nCSV (от англ. Comma-Separated Values — значения, разделённые запятыми) — текстовый формат, предназначенный для представления табличных данных. Строка таблицы соответствует строке текста, которая содержит одно или несколько полей, разделенных запятыми, то есть, по сути, это данные, представленные в текстовом формате.\nСтатистическая информация часто хранится именно в формате CSV, этому формату уже более 40 лет. Текстовые файлы открываются читаются на любом устройстве и в любой среде без дополнительных инструментов. Из-за своих преимуществ CSV — сверхпопулярный формат обмена данными.\nЗа импорт таких файлов отвечает библиотека readr, а в ней - функция read_csv2 (есть и просто read_csv, но там - разделитель действительно запятая, а в read_csv2 - точка с запятой). В чем проблема? Проблема в том, что в России запятая используется в качестве разделителя десятичных разрядов, и когда мы начинаем сохранять в формате csv возникает конфликт. Чтобы его не было, программа вместо запятой использует разделитель - точку с запятой. Это хорошо видно, если посмотреть, как эти данные выглядят в блокноте.\nЕсть и аналогичные функции базового R - read.csv()и read.csv2. Их отличие от функций read_csv2 и read_csvзаключается в быстроте последних, нюансах в обработке строковых переменных (базовые функции принудительно преобразуют их в факторные переменные, тогда как более современные read_csv2 и read_csv оставляют тип character). Есть и некоторые другие отличие, но их обсуждение выходит за рамки данного пособия.\nПорядок действий:\n\nСкачать файл в формате csv.\nОтрыть файл:\n\n\nlibrary(readr)\ndf_csv&lt;-read_csv2(\"ProgResCompatriots.csv\")\n\nУ нас теперь уже три файла с одинаковыми данными). Что с ними делать? Что-нибудь придумаем по ходу занятия…\nНапример, давайте посчитаем прирост соотечественников в 2021 году по сравнению с 2020 годом.\n\ndf_csv$change2021&lt;-df_csv$`2021`-df_csv$`2020`\n\nСохраним наш файл в этом же формате:\n\nwrite.csv2(df_csv, \"df_csv_new.csv\")",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Импорт и экспорт данных</span>"
    ]
  },
  {
    "objectID": "ImportExport.html#импорт-файла-по-url",
    "href": "ImportExport.html#импорт-файла-по-url",
    "title": "6  Импорт и экспорт данных",
    "section": "6.6 Импорт файла по URL",
    "text": "6.6 Импорт файла по URL\nВ Интернете хранится огромное количество различных данных, но с точки зрения импорта можно рассмотреть несколько случаев:\n\nкогда нам нужно просто загрузить файл из Интернета и сохранить его в директорию\nкогда ссылка является прямой и по ней мы можем загрузить данные определенного формата\nкогда у нас есть ссылка на ресурс, в котором содержатся данные вперемешку с текстом, и нам нужно сохранить только табличные данные\n\n\n6.6.1 Загрузка файла в рабочую папку\nВоспользуемся данными, представленными на портале “Открытые данные России” и скачаем оттуда перечень стран и режимов въезда на их территорию.\nМы будем использовать очень простую фунцию download.file(), в которой мы должны указать два аргумента - ссылку и имя файла, в который мы будем сохранять данные. Заметьте, что формат выгружаемого и сохраняемого файла должны совпадать.\n\ndownload.file(\"https://data.gov.ru/sites/default/files/1_28_1.csv\", \"countries.csv\")\n\nПосмотрите в своей рабочей директории, скачался ли файл, попробуйте его открыть.\n\n\n6.6.2 Импорт по прямой ссылке в формате csv\nЗдесь тоже нет ничего сложного. Мы уже только что пробовали открывать файлы в формате csv, которые хранятся у нас на компьютере. То же самое происходит с ссылками из Интернета.\nЗагрузим данные об исследованиии по науке и разработкам, представленное на портале статистического Информационного центра при правительстве Новой Зеландии:\n\nSys.getlocale()\nlibrary(readr)\nRnD&lt;-read_csv(\"https://www.stats.govt.nz/assets/Uploads/Research-and-development-survey/Research-and-development-survey-2022/Download-data/research-and-development-survey-2022.csv\")\n\n\n\n6.6.3 Парсинг таблиц из Интернета\nПожалуй, это самое интересное.\nПредположим, мы читаем статью в Википедии, и нам понравились данные, которые там приводятся. Конечно, мы можем скопировать эти данные с помощью мышки, но зачем? Ведь у нас есть R. К тому же результаты такого копирования часто оставляют желать лучшего.\nНапример, возьмем страницу в Википедии, посвященную международному индексу счастья.\nВпрочем, Вы можете взять любую другую страницу.\nДля того, чтобы выгрузить данные непосредственно со страницы, нам понадобится библиотека rvest.\nЗагрузив библиотеку, создадим объект content, в который мы загрузим данные страницы с помощью функции read_html():\n\nlibrary(rvest)\ncontent &lt;- read_html(\"https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%B6%D0%B4%D1%83%D0%BD%D0%B0%D1%80%D0%BE%D0%B4%D0%BD%D1%8B%D0%B9_%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81_%D1%81%D1%87%D0%B0%D1%81%D1%82%D1%8C%D1%8F\")\n\nЕсли рассмотреть этот объект, то можно увидеть, что это список, содержащий содержимое страницы по тэгам - head и body, в которых что-то хранится в формате xml.\nДалее, с помощью функции html_table давайте “вытащим” таблицы и сохраним их отдельно с именем tables:\n\ntables &lt;- content %&gt;% html_table(fill = TRUE)\n\nВидим, что таких таблиц 5.\nДавайте сохраним первую из них:\n\ntable1 &lt;- tables[[3]]\n\nА теперь сохраним ее себе на компьютер с помощью знакомой уже функции write.xlsx():\n\nwrite.xlsx(table1, \"HPI.xlsx\")",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Импорт и экспорт данных</span>"
    ]
  },
  {
    "objectID": "ImportExport.html#импорт-файла-из-spss-файл-.sav",
    "href": "ImportExport.html#импорт-файла-из-spss-файл-.sav",
    "title": "6  Импорт и экспорт данных",
    "section": "6.7 Импорт файла из SPSS (файл .sav)",
    "text": "6.7 Импорт файла из SPSS (файл .sav)\nЭто наш любимый формат, поскольку мы с вами специалисты по социологическим исследованиям, любим SPSS и хотели бы соединить возможности этого пакета с возможностями R.\nЧтобы загрузить в R файл в формате .sav, мы должны:\n\nво-первых, загрузить файл. Это результаты недавнего исследования кафедры об изменениях климата в высокогорных районах Алтая.\nво-вторых, нам нужно загрузить библиотеку haven, с помощью которой мы можем импортировать данных из формата программы SPSS в R.\n\n\nlibrary(haven)\n\nПосле того, как мы загрузили библиотекy, импортируем базу данных с помощью функции read_sav:\n\ndf&lt;-read_sav(\"База_КлимРиск_2023.sav\", user_na = TRUE) # user_na позволяет активировать настройки, насающиеся пропущенных значений, определяемых пользователем, например, когда значение 99 закодировано как \"затрудняюсь ответить\" и в базе данных оно установлено как пропущенное.\n\nИтак, наши данные теперь сохранены в датафрейме с именем df. Мы видим, что в нем есть 202 переменных и 913 наблюдений.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Импорт и экспорт данных</span>"
    ]
  },
  {
    "objectID": "ImportExport.html#самостоятельная-работа",
    "href": "ImportExport.html#самостоятельная-работа",
    "title": "6  Импорт и экспорт данных",
    "section": "6.8 Самостоятельная работа",
    "text": "6.8 Самостоятельная работа\nУпражнение 1. Используя портал Открытых данных России, найти интересующие Вас данные в разных форматах - excel, csv. Загрузить данные по ссылке, внести в них изменения (создать новую переменную, что-то поменять, используя R) и сохранить новый файл в аналогичном формате.\nУпражнение 2. С официального сайта Алтайского края скачать Указ Губернатора о присвоении звания ветерана труда и загрузить его в рабочую папку.\nУпражнение 3. С официального сайта Алтайского края, из раздела, посвященного национальной политике, скачать список национально-культурных организаций и сохранить его в формате excel.\nУпражнение 4. Загрузить базу данных своего магистерского исследования из SPSS в R.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Импорт и экспорт данных</span>"
    ]
  },
  {
    "objectID": "TidyverseTransformations.html",
    "href": "TidyverseTransformations.html",
    "title": "7  Tidyverse и трансформация данных",
    "section": "",
    "text": "7.1 Прямоугольные и непрямоугольные таблицы, а также tidy и messy данные\nДанные могут быть представлены в различных формах, но на самом базовом уровне их можно представить в виде двух типов структур: данные представленные в виде прямоугольных таблиц и непрямоугольных данных.\nПрямоугольные данные имеют форму прямоугольника (действительно!), то есть каждое значение соответствует какой-то строке и столбцу. Большинство датафреймов содержат как раз прямоугольные данные.\nСоответственно непрямоугольные данные не могут так легко распределяться по строкам и столбцам, они, как правило, представляют собой совокупность различных структур данных, в которых между отдельными элементами имеется какое-то сходство. Обычно непрямоугольные данные хранятся в списках.\nTidy по-английски означает “чистый, аккуратный, опрятный”. По отношению к данным выражение - tidy data - “чистые, правильным образом представленные данные” противопоставляется “messy data” - “грязным данным”, представленным в виде, не совсем пригодном или удобном для анализа.\nTidy data - это когда данные имеют так называемый “длинный формат” - каждый столбец представляет собой отдельную переменную, а строка - наблюдение или случай.\nКак из «грязных» данных сделать «чистые»? Как привести набор данных к виду, пригодному для дальнейшего анализа, отобрать нужные переменные, преобразовать их в формат, который нужен для решения аналитической задачи?\nВ рамках данного раздела будут рассмотрены функции, которые используются для трансформации данных - их чистки, фильтрации, вычисления новых переменных и описательных статистик, а также перевода набора данных из «широкого» в «длинный» и обратно.\nВ основном мы будем работать с двумя библиотеками семейства tidyverse - dplyr и tidyr.\n,\nЭти библиотеки является одними из лучших для разнообразных трансформаций данных, потребность в которых возникает постоянно в процессе анализа.\nРассмотрим основные функции на примере набора данных flights из библиотеки - nycflights13, в котором содержится информация о 336 776 полетах, совершенных из аэропорта Нью-Йорка в 2013 году. Данные предоставлены Бюро по статистике США, справку по ним можно найти по запросу ?flights.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Tidyverse и трансформация данных</span>"
    ]
  },
  {
    "objectID": "TidyverseTransformations.html#фильтрация-строк---filter",
    "href": "TidyverseTransformations.html#фильтрация-строк---filter",
    "title": "7  Tidyverse и трансформация данных",
    "section": "7.2 Фильтрация строк - filter()",
    "text": "7.2 Фильтрация строк - filter()\nПрежде, чем начать, установим библиотеки:\n\ninstall.packages(c(\"nycflights13\", \"tidyverse\"))\n\nТеперь загрузим их в наше рабочее пространство:\n\nlibrary(tidyverse)\nlibrary(nycflights13)\n\nВ наборе данных flights содержится следующая информация о переменных:\n\nyear (год), month (месяц), day (день) - дата вылета\ndep_time - время вылета\narr_time - время прилета\nsched_dep_time, sched_arr_time - время вылета и прилета по расписанию.\ndep_delay, arr_delay - задержка вылета и прилета в минутах. Отрицательные значения означают досрочные вылеты / прилеты.\ncarrier - перевозчик\nflight - номер рейса\ntailnum - номер самолета\norigin, dest - место отправления, место назначения\nair_time - время полета в минутах\ndistance - расстояние в милях\nhour, minute - часов, минут - время отлета, разбитое по часам и минутам\ntime_hour - дата и время полета по расписанию в формате даты.\n\nДавайте сначала просто посмотрим на эти данные:\n\nhead(flights)\n\n# A tibble: 6 × 19\n   year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n  &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n1  2013     1     1      517            515         2      830            819\n2  2013     1     1      533            529         4      850            830\n3  2013     1     1      542            540         2      923            850\n4  2013     1     1      544            545        -1     1004           1022\n5  2013     1     1      554            600        -6      812            837\n6  2013     1     1      554            558        -4      740            728\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nФункция filter() позволяет отобрать наблюдения, основываясь на значениях. Первый аргумент - имя датафрейма (массива, базы данных), второй и последующие аргументы - выражения, позволяющие отфильтровать данные. Например, мы хотим отобрать все полеты, которые произошли 1 января:\n\nfilter(flights, month == 1, day == 1)\n\n# A tibble: 842 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 832 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nКогда мы запускаем эту строку с кодом, dplyr выполняет фильтрующую операцию и выводит новый датафрейм. Однако, стоит учитывать, что исходные данные не меняются, и если нам необходимо сохранить эти изменения как отдельный объект, нам нужно использовать оператор присваивания, &lt;-, и задать новое имя:\n\njan1 &lt;- filter(flights, month == 1, day == 1)\n\nR либо выводит на экран результаты либо сохраняет их в новую переменную (объект). Если мы хотим одновременно создать новую базу данных, сохранить в нее результаты фильтрации и вывести результат на экран, нужно код заключить в скобки:\n\n(dec25 &lt;- filter(flights, month == 12, day == 25))\n\n# A tibble: 719 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013    12    25      456            500        -4      649            651\n 2  2013    12    25      524            515         9      805            814\n 3  2013    12    25      542            540         2      832            850\n 4  2013    12    25      546            550        -4     1022           1027\n 5  2013    12    25      556            600        -4      730            745\n 6  2013    12    25      557            600        -3      743            752\n 7  2013    12    25      557            600        -3      818            831\n 8  2013    12    25      559            600        -1      855            856\n 9  2013    12    25      559            600        -1      849            855\n10  2013    12    25      600            600         0      850            846\n# ℹ 709 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Tidyverse и трансформация данных</span>"
    ]
  },
  {
    "objectID": "TidyverseTransformations.html#логические-операторы",
    "href": "TidyverseTransformations.html#логические-операторы",
    "title": "7  Tidyverse и трансформация данных",
    "section": "7.3 Логические операторы",
    "text": "7.3 Логические операторы\nОчень часто функция filter() сопровождается логическими операторами (“и”, “или” и др.). В этом случае, результат каждого выражения должен быть истинным, для того, чтобы строки были отобраны в новый набор.\n\n\n\n\n\n\nСовет\n\n\n\nЗапомним основные операторы\n& это “и”\n| это “или”\n! “не равно”\n\n\nГрафически различия между операторами можно представить следующим образом:\n\nНапример, давайте отфильтруем данные так, чтобы у нас отображались два месяца - ноябрь и декабрь.\n\nfilter(flights, month == 11 | month == 12)\n\n# A tibble: 55,403 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013    11     1        5           2359         6      352            345\n 2  2013    11     1       35           2250       105      123           2356\n 3  2013    11     1      455            500        -5      641            651\n 4  2013    11     1      539            545        -6      856            827\n 5  2013    11     1      542            545        -3      831            855\n 6  2013    11     1      549            600       -11      912            923\n 7  2013    11     1      550            600       -10      705            659\n 8  2013    11     1      554            600        -6      659            701\n 9  2013    11     1      554            600        -6      826            827\n10  2013    11     1      554            600        -6      749            751\n# ℹ 55,393 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nДля некоторого упрощения кода полезно будет запомнить “законы де Моргана”:\n!(x & y) это то же самое, что и !x | !y,\n!(x | y) равносильно !x & !y.\nНапример, если нам нужно отобрать полеты, которые задерживались (по прилетам и отлетам) не более чем на два часа, мы могли бы пойти двумя путями:\n\nfilter(flights, !(arr_delay &gt; 120 | dep_delay &gt; 120))\n\n# A tibble: 316,050 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 316,040 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n# Или (результат идентичный)\nfilter(flights, arr_delay &lt;= 120, dep_delay &lt;= 120)\n\n# A tibble: 316,050 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 316,040 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n Самостоятельное задание:\n\nСоздайте набор данных arr_depay_over120, в который отберите рейсы, прилет которых (arr_delay) задерживался на 2 или более часа.\nВыгрузите данные о рейсах в аэропорты Хьюстона - George Bush Intercontinental (IAH) или аэропорт William P Hobby (HOU) (по переменной dest) и сохраните их под именем IAH_OR_HOU.\nОтберите из таблицы все полеты, которые совершались в летние месяцы, и сохраните их под именем summer_flights.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Tidyverse и трансформация данных</span>"
    ]
  },
  {
    "objectID": "TidyverseTransformations.html#упорядочение-строк-с-функцией-arrange",
    "href": "TidyverseTransformations.html#упорядочение-строк-с-функцией-arrange",
    "title": "7  Tidyverse и трансформация данных",
    "section": "7.4 Упорядочение строк с функцией arrange()",
    "text": "7.4 Упорядочение строк с функцией arrange()\nФункция arrange() работает практически идентично с filter(), однако, вместо отбора строк она меняет их порядок. На входе функция берет датафрейм и наименования столбцов, по которым нужно сделать сортировку.Если таких столбцов несколько, каждая дополнительная колонка может быть использована для сортировки значений по уже отсортированным значениям предыдущего столбца.\nНапример, отсортируем полеты по дате (сначала по месяцу, потом по дню):\n\narrange(flights, month, day)\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nЕсли нам нужно отсортировать что-то по убыванию, то функция desc() поможет нам перегруппировать значения в столбце. Например, отсортируем по убыванию значения задержки отлета:\n\narrange(flights, desc(dep_delay))\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     9      641            900      1301     1242           1530\n 2  2013     6    15     1432           1935      1137     1607           2120\n 3  2013     1    10     1121           1635      1126     1239           1810\n 4  2013     9    20     1139           1845      1014     1457           2210\n 5  2013     7    22      845           1600      1005     1044           1815\n 6  2013     4    10     1100           1900       960     1342           2211\n 7  2013     3    17     2321            810       911      135           1020\n 8  2013     6    27      959           1900       899     1236           2226\n 9  2013     7    22     2257            759       898      121           1026\n10  2013    12     5      756           1700       896     1058           2020\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n** ! Пропущенные значения (NA) - всегда располагаются в конце списка, независимо от направления сортировки**. Давайте воспроизведем это свойство на примере, содержащем небольшое количество строк:\n\ndf &lt;- tibble(x = c(5, 2, NA))\narrange(df, x)\n\n# A tibble: 3 × 1\n      x\n  &lt;dbl&gt;\n1     2\n2     5\n3    NA\n\narrange(df, desc(x))\n\n# A tibble: 3 × 1\n      x\n  &lt;dbl&gt;\n1     5\n2     2\n3    NA\n\n\n Самостоятельное задание:\n\nОтсортируйте полеты, чтобы найти те, что имеют наибольшие значения времени задержки прилета (arr_delay). Найдите также полеты, которые вылетели раньше времени по расписанию (вспоминаем функцию tail()).\nНайдите самые короткие (быстрые) полеты по переменной air_time.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Tidyverse и трансформация данных</span>"
    ]
  },
  {
    "objectID": "TidyverseTransformations.html#отбор-переменных-с-функцией-select",
    "href": "TidyverseTransformations.html#отбор-переменных-с-функцией-select",
    "title": "7  Tidyverse и трансформация данных",
    "section": "7.5 Отбор переменных с функцией select()",
    "text": "7.5 Отбор переменных с функцией select()\nДостаточно часто нам для анализа не нужен весь наш набор данных, а только ограниченный набор переменных, с которыми мы работаем в какой-то момент времени. Удобно и полезно отобрать эти переменные и работать только с ними, особенно - если данных очень много, и количество переменных исчисляется сотнями или тысячами. Функция select() позволяет быстро отобрать переменные по их именам:\n\nselect(flights, year, month, day)\n\n# A tibble: 336,776 × 3\n    year month   day\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;\n 1  2013     1     1\n 2  2013     1     1\n 3  2013     1     1\n 4  2013     1     1\n 5  2013     1     1\n 6  2013     1     1\n 7  2013     1     1\n 8  2013     1     1\n 9  2013     1     1\n10  2013     1     1\n# ℹ 336,766 more rows\n\n\n\nselect(flights, year:day) # если переменные идут подряд, не обязательно перечислять все, можно воспользоваться оператором :\n\n# A tibble: 336,776 × 3\n    year month   day\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;\n 1  2013     1     1\n 2  2013     1     1\n 3  2013     1     1\n 4  2013     1     1\n 5  2013     1     1\n 6  2013     1     1\n 7  2013     1     1\n 8  2013     1     1\n 9  2013     1     1\n10  2013     1     1\n# ℹ 336,766 more rows\n\n\n\nselect(flights, -(year:day))# знак минуса используется для того, чтобы, наоборот, исключить какие-то переменные\n\n# A tibble: 336,776 × 16\n   dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay carrier\n      &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt; &lt;chr&gt;  \n 1      517            515         2      830            819        11 UA     \n 2      533            529         4      850            830        20 UA     \n 3      542            540         2      923            850        33 AA     \n 4      544            545        -1     1004           1022       -18 B6     \n 5      554            600        -6      812            837       -25 DL     \n 6      554            558        -4      740            728        12 UA     \n 7      555            600        -5      913            854        19 B6     \n 8      557            600        -3      709            723       -14 EV     \n 9      557            600        -3      838            846        -8 B6     \n10      558            600        -2      753            745         8 AA     \n# ℹ 336,766 more rows\n# ℹ 9 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;,\n#   air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nЕсть еще несколько полезных функций, которые идут в паре с select() и делают жизнь проще:\nstarts_with(\"abc\"): имена переменных начинаются на “abc”.\nends_with(\"xyz\"): имена переменных заканчиваются на “xyz”.\ncontains(\"ijk\"): имя переменной содержит “ijk”.\nИногда, в процессе обработки нам требуется переименовать переменную другим способом. Для этой цели подходит функция rename:\n\nrename(flights, tail_num = tailnum)\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tail_num &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n Самостоятельное задание:\n\nИспользовать все возможные способы для того, чтобы отобрать переменные dep_time, dep_delay, arr_time и arr_delay.\nЧто случится, если Вы включите одну и ту же переменную несколько раз в запрос функции select()?",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Tidyverse и трансформация данных</span>"
    ]
  },
  {
    "objectID": "TidyverseTransformations.html#создаем-новую-переменную-с-функцией-mutate",
    "href": "TidyverseTransformations.html#создаем-новую-переменную-с-функцией-mutate",
    "title": "7  Tidyverse и трансформация данных",
    "section": "7.6 Создаем новую переменную с функцией mutate()",
    "text": "7.6 Создаем новую переменную с функцией mutate()\nДа, сейчас явно что-то будет про мутации)))\nПомимо того, что в процессе анализа нам приходится что-то постоянно отбирать (например, только жителей сел или городов, какой-то регион исследования, лиц определенного возраста и пола), часто приходится вычислять новые переменные на основе старых - высчитывать возраст, средний доход, количество детей и т. д.\nВ этом нам может помочь функция mutate().\nПример: создадим новый набор flights_sml, куда отберем даты полета, расстояние и переменные, оканчивающиеся на “delay”. Затем, содадим две новых переменных:\n\nскорость (speed)\nколичество минут, которые самолет смог догнать при задержке рейса (как разность между задержкой вылета и прилета) (gain).\n\n\nflights_sml &lt;- select(flights,\n  year:day,\n  ends_with(\"delay\"),\n  distance,\n  air_time\n)\nmutate(flights_sml,\n  gain = dep_delay - arr_delay,\n  speed = distance / (air_time / 60)\n)\n\n# A tibble: 336,776 × 9\n    year month   day dep_delay arr_delay distance air_time  gain speed\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1  2013     1     1         2        11     1400      227    -9  370.\n 2  2013     1     1         4        20     1416      227   -16  374.\n 3  2013     1     1         2        33     1089      160   -31  408.\n 4  2013     1     1        -1       -18     1576      183    17  517.\n 5  2013     1     1        -6       -25      762      116    19  394.\n 6  2013     1     1        -4        12      719      150   -16  288.\n 7  2013     1     1        -5        19     1065      158   -24  404.\n 8  2013     1     1        -3       -14      229       53    11  259.\n 9  2013     1     1        -3        -8      944      140     5  405.\n10  2013     1     1        -2         8      733      138   -10  319.\n# ℹ 336,766 more rows\n\n\nОтметим, что мы можем «не отходя от кассы» использовать новые переменные в последующих расчетах для создания других переменных. Например, давайте создадим переменную gain (см. пример выше), но и посчитаем время полета в часах и среднее количество минут, которое нагонял самолет каждый час:\n\nmutate(flights_sml,\n  gain = dep_delay - arr_delay,\n  hours = air_time / 60,\n  gain_per_hour = gain / hours\n)\n\n# A tibble: 336,776 × 10\n    year month   day dep_delay arr_delay distance air_time  gain hours\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1  2013     1     1         2        11     1400      227    -9 3.78 \n 2  2013     1     1         4        20     1416      227   -16 3.78 \n 3  2013     1     1         2        33     1089      160   -31 2.67 \n 4  2013     1     1        -1       -18     1576      183    17 3.05 \n 5  2013     1     1        -6       -25      762      116    19 1.93 \n 6  2013     1     1        -4        12      719      150   -16 2.5  \n 7  2013     1     1        -5        19     1065      158   -24 2.63 \n 8  2013     1     1        -3       -14      229       53    11 0.883\n 9  2013     1     1        -3        -8      944      140     5 2.33 \n10  2013     1     1        -2         8      733      138   -10 2.3  \n# ℹ 336,766 more rows\n# ℹ 1 more variable: gain_per_hour &lt;dbl&gt;\n\n\n Самостоятельное задание:\n\nСравните air_time` и `arr_time - dep_time. Что мы можем увидеть? Какие выводы можно сделать?\nСравните dep_time, sched_dep_time и dep_delay. Как эти переменные связаны друг с другом?\nНа основе уже знакомого нам набора iris создайте новую переменную - sepal_ratio, в которой посчитайте отношение длины чашелистника (Sepal.Length) к его ширине (Sepal.Width) и переменную petal_ratio, в которой посчитайте отношение длины лепестка (Petal.Length) к его ширине (Petal.Width). Сохраните данные в новом наборе iris2.\n\n\n\nЕсли трудно, код можно посмотреть здесь\niris2&lt;- mutate(iris, sepal_ratio=Sepal.Length/Sepal.Width, petal_ratio=Petal.Length/Petal.Width)",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Tidyverse и трансформация данных</span>"
    ]
  },
  {
    "objectID": "TidyverseTransformations.html#изменения-в-нескольких-переменных-mutate-across",
    "href": "TidyverseTransformations.html#изменения-в-нескольких-переменных-mutate-across",
    "title": "7  Tidyverse и трансформация данных",
    "section": "7.7 Изменения в нескольких переменных: mutate + across",
    "text": "7.7 Изменения в нескольких переменных: mutate + across\nФункция mutate() не обязательно означает, что мы будем вычислять новые переменные, вполне возможно мы будем как-то видоизменять те переменные, которые у нас уже есть в наборе данных. Например, мы хотим округлить значение только что полученных нами переменных sepal_ratio petal_ratio (см. самостоятельная работа выше, упражнение 3) до одного знака после запятой.\n\n\nWarning: `as.tibble()` was deprecated in tibble 2.0.0.\nℹ Please use `as_tibble()` instead.\nℹ The signature and semantics have changed, see `?as_tibble`.\n\n\n\nmutate(iris2, across(c(sepal_ratio, petal_ratio), round, 1))# функция round используется для округления, цифра 1 означает, что мы будем округлять до одного знака после запятой \n\n# A tibble: 150 × 7\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species sepal_ratio\n          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;         &lt;dbl&gt;\n 1          5.1         3.5          1.4         0.2 setosa          1.5\n 2          4.9         3            1.4         0.2 setosa          1.6\n 3          4.7         3.2          1.3         0.2 setosa          1.5\n 4          4.6         3.1          1.5         0.2 setosa          1.5\n 5          5           3.6          1.4         0.2 setosa          1.4\n 6          5.4         3.9          1.7         0.4 setosa          1.4\n 7          4.6         3.4          1.4         0.3 setosa          1.4\n 8          5           3.4          1.5         0.2 setosa          1.5\n 9          4.4         2.9          1.4         0.2 setosa          1.5\n10          4.9         3.1          1.5         0.1 setosa          1.6\n# ℹ 140 more rows\n# ℹ 1 more variable: petal_ratio &lt;dbl&gt;\n\n\nМы могли бы написать наш код чуть по-другому:\n\niris2 %&gt;%\n  mutate(across(c(sepal_ratio, petal_ratio), round, 1))\n\n# A tibble: 150 × 7\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species sepal_ratio\n          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;         &lt;dbl&gt;\n 1          5.1         3.5          1.4         0.2 setosa          1.5\n 2          4.9         3            1.4         0.2 setosa          1.6\n 3          4.7         3.2          1.3         0.2 setosa          1.5\n 4          4.6         3.1          1.5         0.2 setosa          1.5\n 5          5           3.6          1.4         0.2 setosa          1.4\n 6          5.4         3.9          1.7         0.4 setosa          1.4\n 7          4.6         3.4          1.4         0.3 setosa          1.4\n 8          5           3.4          1.5         0.2 setosa          1.5\n 9          4.4         2.9          1.4         0.2 setosa          1.5\n10          4.9         3.1          1.5         0.1 setosa          1.6\n# ℹ 140 more rows\n# ℹ 1 more variable: petal_ratio &lt;dbl&gt;\n\n\n\nСтоп! Что за новый знак %&gt;%?\nЭто оператор, который позволяет сократить код и написать его по типу “матрешки”. По-английски это называется “pipe-operator”, здесь явная аналогия с телескопическими трубами, которые как бы вкладываются друг с другом. Так и наши различные функции dplyr следуют друг за другом уже без лиших аргументов и дублирования информации о наборе данных, лишних скобок и знаков $, с помощью которых мы вводим имя переменной из набора. Код становится более читаемым и быстрым.\n\nГрафически это можно представить вот так:\n В dplyr оператор %&gt;% попал из библиотеки magrittr, разработчики которой (Stefan Milton Bache, Hadley Wickham, Lionel Henry) преследовали две основных цели - сократить процесс написания кода и улучить его поддержку.\nНазвана библиотека в честь бельгийского художника-сюрреалиста Рене Магритта (1898-1967), который был известен своими остроумными и загадочными работами.\n Причем тут трубы, спросите вы? А вот причем. У Магритта есть одна знаменитая картина – «Вероломство образов», которую автор создал в 1929 году, увлекшись исследованием связи в искусстве между словами и образами. На картине изображена курительная трубка, выглядит она очень правдоподобно и нарисована тщательно. Вдоль нижней кромки полотна идет надпись, сделанная крупным каллиграфическим почерком: «Ceci n’est pas une pipe» - «Это не трубка». Картина породила множество интерпретаций, а сам автор по поводу нее сказал следующее: «Разве я написал неправду? Да, на картине нарисована трубка, но разве вы можете раскурить ее? Нет, потому что это всего лишь репрезентация. И если бы я написал “Это - трубка”, то я бы солгал!».\n В общем, разработчики отдали дань творчеству автора, и в языке R появился новый оператор.\n\n\n\n\n\n\nСовет\n\n\n\nЧтобы быстро набрать пайп-оператор нужно одновременно нажать три клавиши:\nCtrl+Shift+M\n\n\nНачиная с версии R 4.1.0. в базовом R появился свой, «нативный» оператор, почти аналогичный %&gt;%. Выглядит он как |&lt; и “ведет себя” почти всегда так же. Есть некоторые нюансы, однако обсуждать мы их пока не будем. В качестве дополнительного матерала для тех, кто хочет действительно разобраться, отсылаю к статье: https://www.tidyverse.org/blog/2023/04/base-vs-magrittr-pipe/\nВ настройках RStudio можно указать, какой именно операторв вы хотите использовать, но только один:",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Tidyverse и трансформация данных</span>"
    ]
  },
  {
    "objectID": "TidyverseTransformations.html#вычисление-основных-статистик-с-функцией-summarise-и-group_by",
    "href": "TidyverseTransformations.html#вычисление-основных-статистик-с-функцией-summarise-и-group_by",
    "title": "7  Tidyverse и трансформация данных",
    "section": "7.8 Вычисление основных статистик с функцией summarise() и group_by()",
    "text": "7.8 Вычисление основных статистик с функцией summarise() и group_by()\nЕще одна функция, которую мы изучим в рамках данного урока, – summarise(). Как следует из названия, ее предназначение - рассчитывать какие-то новые значения на основе разнообразных функций - арифметических, статистических и др. Например, посчитаем среднее количество минут задержки вылета по набору полетов:\n\nsummarise(flights, dep_delay_mean = mean(dep_delay, na.rm = TRUE))#na.rm = TRUE - данный аргумент удаляет из анализа все пропущенные значения (na - not avaliable, rm - remove), в противном случае вычисление среднего не возможно.\n\n# A tibble: 1 × 1\n  dep_delay_mean\n           &lt;dbl&gt;\n1           12.6\n\n\nФункция summarise() часто идет в паре с другой функцией - group_by(), позволяющей провести анализ в отдельных подгруппах. Соответственно, когда мы применяем функции dplyr к сгруппированным данным, они автоматически рассчитываются для каждой подгруппы по отдельности. Например, мы можем применить код из примера выше, но предварительно сгруппировать данные по месяцам. Получится следующее:\n\nflights %&gt;%\ngroup_by(month) %&gt;%\nsummarise(dep_delay_delay = mean(dep_delay, na.rm = TRUE))\n\n# A tibble: 12 × 2\n   month dep_delay_delay\n   &lt;int&gt;           &lt;dbl&gt;\n 1     1           10.0 \n 2     2           10.8 \n 3     3           13.2 \n 4     4           13.9 \n 5     5           13.0 \n 6     6           20.8 \n 7     7           21.7 \n 8     8           12.6 \n 9     9            6.72\n10    10            6.24\n11    11            5.44\n12    12           16.6 \n\n\nИз таблицы видно, что рейсы в среднем задерживались чаще в летние месяцы (июне и июле) и декабре.\nПриведем еще один пример совместного использования функций: проведем группировку по месту назначения и посчитаем общее количество полетов, среднее расстояние и среднюю задержку вылета в минутах, а также отберем 5 направлений с максимальными средними значениями по задержке вылетов и 5 направлений с минимальным задержками:\n\ndelays &lt;- flights %&gt;%\n  group_by(dest) %&gt;%\n  summarise(\n    Всего = n(),\n    Сред_расст = mean(distance, na.rm = TRUE),\n    Ср_задержка_вылета = mean(arr_delay, na.rm = TRUE)\n  ) %&gt;% \n  arrange(desc(Ср_задержка_вылета)) %&gt;% \n  slice(c(1:5, n()-5:n()))#slice отбирает строки, в скобках указываются номера, 1:5 - первые пять, а n()-5:n() - последние пять: n()-5 - номер строки минус 5 указывает на начало интервала,n() - общее количество строк - на конец. Мы могли бы указать это как 101:105, но допустим, мы не знаем, сколько строк, такой подход позволяет избежать ручного ввода номеров строк.\ndelays\n\n# A tibble: 105 × 4\n   dest  Всего Сред_расст Ср_задержка_вылета\n   &lt;chr&gt; &lt;int&gt;      &lt;dbl&gt;              &lt;dbl&gt;\n 1 CAE     116       604.            41.8   \n 2 TUL     315      1215             33.7   \n 3 OKC     346      1325             30.6   \n 4 JAC      25      1876.            28.1   \n 5 TYS     631       639.            24.1   \n 6 ANC       8      3370             -2.5   \n 7 HNL     707      4973.            -1.37  \n 8 SEA    3923      2413.            -1.10  \n 9 MVY     221       173             -0.286 \n10 LGB     668      2465             -0.0620\n# ℹ 95 more rows\n\n\nХотя в таблице :::callout-note Другие полезные функции: - median() - медиана - sd() - стандартное отклонение - min() - минимум - max() - максимум - first() - первое значение - nth() - значение определенного порядка (2, 3 и т.д.) - last() - последнее - n() - количество, размер группы - n_distinct() - количество уникальных значений :::\nНапример:\n\nflights %&gt;%\nna.omit() %&gt;% #na.omit() - опускает пропущенные значения\ngroup_by(month) %&gt;%\n  summarise(\n    first_dep = first(dep_time),\n    last_dep = last(dep_time)\n  )\n\n# A tibble: 12 × 3\n   month first_dep last_dep\n   &lt;int&gt;     &lt;int&gt;    &lt;int&gt;\n 1     1       517     2354\n 2     2       456     2359\n 3     3         4     2358\n 4     4       454     2351\n 5     5         9     2355\n 6     6         2     2359\n 7     7         1     2352\n 8     8        12     2359\n 9     9         9     2349\n10    10       447     2357\n11    11         5     2354\n12    12        13     2356\n\n\nЕще пример: сгруппируем полеты по месту назначения и посчитаем уникальных перевозчиков, отсортировав нашу таблицу по месту назначения.\n\nflights %&gt;%\nna.omit() %&gt;%\ngroup_by(dest) %&gt;%\n  summarise(carriers = n_distinct(carrier)) %&gt;%\n  arrange(desc(carriers))\n\n# A tibble: 104 × 2\n   dest  carriers\n   &lt;chr&gt;    &lt;int&gt;\n 1 ATL          7\n 2 BOS          7\n 3 CLT          7\n 4 ORD          7\n 5 TPA          7\n 6 AUS          6\n 7 DCA          6\n 8 DTW          6\n 9 IAD          6\n10 MSP          6\n# ℹ 94 more rows",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Tidyverse и трансформация данных</span>"
    ]
  },
  {
    "objectID": "TidyverseTransformations.html#сочетание-нескольких-трансформаций-mutate-filter-summarise",
    "href": "TidyverseTransformations.html#сочетание-нескольких-трансформаций-mutate-filter-summarise",
    "title": "7  Tidyverse и трансформация данных",
    "section": "7.9 Сочетание нескольких трансформаций (mutate, filter, summarise)",
    "text": "7.9 Сочетание нескольких трансформаций (mutate, filter, summarise)\nГруппировка обычно сопутствует функции summarise(),но ее также можно сочетать с mutate() и filter():\nНапример, мы хотим оставить в наболе данные только по наиболее популярным направлениям, принявшим не менее 5000 полетов за год:\n\nflights %&gt;%\n  group_by(dest) %&gt;%\n  filter(n()&gt;17000)\n\n# A tibble: 34,498 × 19\n# Groups:   dest [2]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      554            600        -6      812            837\n 2  2013     1     1      554            558        -4      740            728\n 3  2013     1     1      558            600        -2      753            745\n 4  2013     1     1      600            600         0      837            825\n 5  2013     1     1      606            610        -4      837            845\n 6  2013     1     1      608            600         8      807            735\n 7  2013     1     1      615            615         0      833            842\n 8  2013     1     1      629            630        -1      824            810\n 9  2013     1     1      656            700        -4      854            850\n10  2013     1     1      658            700        -2      944            939\n# ℹ 34,488 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nИли, например, нам понадобилось посчитать по каждому направлению среднее количество полетов и сохранить его в переменной mean:\n\nflights %&gt;%\n  group_by(dest) %&gt;%\n  mutate(mean=mean(n()), .keep = \"used\") #.keep = \"used\" - оставляет в наборе только используемые переменные, в противном случае останется весь набор\n\n# A tibble: 336,776 × 2\n# Groups:   dest [105]\n   dest   mean\n   &lt;chr&gt; &lt;dbl&gt;\n 1 IAH    7198\n 2 IAH    7198\n 3 MIA   11728\n 4 BQN     896\n 5 ATL   17215\n 6 ORD   17283\n 7 FLL   12055\n 8 IAD    5700\n 9 MCO   14082\n10 ORD   17283\n# ℹ 336,766 more rows",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Tidyverse и трансформация данных</span>"
    ]
  },
  {
    "objectID": "TidyverseTransformations.html#создание-новых-переменных-из-старых-по-условиям-if_else-и-case_when",
    "href": "TidyverseTransformations.html#создание-новых-переменных-из-старых-по-условиям-if_else-и-case_when",
    "title": "7  Tidyverse и трансформация данных",
    "section": "7.10 Создание новых переменных из старых по условиям: if_else() и case_when()",
    "text": "7.10 Создание новых переменных из старых по условиям: if_else() и case_when()\nТакого рода перекодировки в исследовательской практике встречаются очень часто, когда мы хотим объединить некоторые значения в группы или заменить на другие значения. В решении этой задачи нам помогут две полезные функции: if_else()и case_when().\n\n7.10.1 if_else()\nЭта функция позволяет нам перекодировать значения, совпадающие или несовпадающие с некоторым условием, и одновременно обрабатывать отсутствующие значения. Для того, чтобы корректно применить эту функцию, нам нужно знать, какое значение в наших данных будет условно «истинным, корректным», какое «ложным, неправильным», и какое значение будут принимать пропущенные значения.\nОбщая формула для этой функции выглядит так:\nif_else(condition, true, false, missing = NULL)\nВ аргументах функции задается следующее: condition - условие, которое мы проверяем true - значение, которое присваиваем, если условие выполняется false- значение, которое присваиваем, если условие не выполняется.\nПриведем простой пример: Создадим вектор x, содержащий значения от -10 до +10, а затем все положительные значения заменим на 555:\n\nx &lt;- c(-10:10)\nif_else(x &gt; 0, 555, x)\n\n [1] -10  -9  -8  -7  -6  -5  -4  -3  -2  -1   0 555 555 555 555 555 555 555 555\n[20] 555 555\n\n\nКонструкция if_else() очень часто используется вместе с mutate()для того, чтобы создать новые переменные.\nДавайте создадим по набору iris новую переменную - sepal_group, которую перекодируем следующим образом: если значение Sepal.Length равно превышает среднее значение по всем наблюдениям - 1, если меньше - 0.\n\niris3&lt;-iris %&gt;%\n  mutate(sepal_group = if_else(Sepal.Length &gt;= mean(Sepal.Length), 1, 0))\n\n Самостоятельное задание:\n1.Создайте в набореiris3 переменную petal_group, таким же способом, как мы только что создавали sepal_group. 2. Перекодируйте переменную petal_group с помощью if_else() так, чтобы 1 были трансформированы в “Больше среднего”, а 0 - “Меньше среднего”.\n\n\n7.10.2 case_when()\nКогда условий несколько, можно использовать вложенные конструкции if_else(), но это не очень удобно. Вместо это лучше использовать специальную функцию case_when(), которая как раз предназначена для таких случаев.\nДопустим, нам нужно перекодировать полеты из набора flights в зависимости от расстояния (dist)и создать переменную dist_group, в которой бы все полеты были бы распределены по четырем категориям: “менее 500 миль”, “от 500 до 1000 миль”, “от 1000 до 1500 миль” и “свыше 1500 миль”. Получается, что нам нужно сверить множество условий, и, значит, это работа для case_when ():\n\nflights %&gt;%\n  mutate(dist_group=  case_when(\n  distance &lt; 500 ~ \"менее 500 миль\",\n  between(distance, 501, 1000) ~ \"от 500 до 1000 миль\",\n  between(distance, 1001, 1500) ~ \"от 1000 до 1500 миль\",\n  distance &gt; 1500 ~ \"свыше 1500 миль\"), .keep=\"used\")\n\n# A tibble: 336,776 × 2\n   distance dist_group          \n      &lt;dbl&gt; &lt;chr&gt;               \n 1     1400 от 1000 до 1500 миль\n 2     1416 от 1000 до 1500 миль\n 3     1089 от 1000 до 1500 миль\n 4     1576 свыше 1500 миль     \n 5      762 от 500 до 1000 миль \n 6      719 от 500 до 1000 миль \n 7     1065 от 1000 до 1500 миль\n 8      229 менее 500 миль      \n 9      944 от 500 до 1000 миль \n10      733 от 500 до 1000 миль \n# ℹ 336,766 more rows\n\n\n Самостоятельное задание:\n\nПо набору iris создайте переменную sepal4cats, в которой бы содержались следующие значение о длине чашелистника: “Меньше 5,0”, “от 5,1 до 5.8”, “от 5.9 до 6.4” и “свыше 6.5”.\nПосчитайте количество ирисов в каждой группе.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Tidyverse и трансформация данных</span>"
    ]
  },
  {
    "objectID": "TidyverseTransformations.html#между-широким-и-длинным-форматом",
    "href": "TidyverseTransformations.html#между-широким-и-длинным-форматом",
    "title": "7  Tidyverse и трансформация данных",
    "section": "7.11 Между «широким» и «длинным» форматом",
    "text": "7.11 Между «широким» и «длинным» форматом\nПоследнее, чем мы займемся в рамках данной темы, будет преобразование из «широкого» в «длинный» формат и обратно.\n\n7.11.1 Случай 1. Из «широкого» в «длинное»\nИногда случается так, что данные представлены в виде двумерной таблицы, уже подготовленной для описания, но такие данные не очень подходят для дальнейшего анализа.\nНапример, давайте посмотрим на таблицу взаимосвязей между уровнем дохода и религиозной принадлежностью:\n\nrelig_income\n\n# A tibble: 18 × 11\n   religion `&lt;$10k` `$10-20k` `$20-30k` `$30-40k` `$40-50k` `$50-75k` `$75-100k`\n   &lt;chr&gt;      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;\n 1 Agnostic      27        34        60        81        76       137        122\n 2 Atheist       12        27        37        52        35        70         73\n 3 Buddhist      27        21        30        34        33        58         62\n 4 Catholic     418       617       732       670       638      1116        949\n 5 Don’t k…      15        14        15        11        10        35         21\n 6 Evangel…     575       869      1064       982       881      1486        949\n 7 Hindu          1         9         7         9        11        34         47\n 8 Histori…     228       244       236       238       197       223        131\n 9 Jehovah…      20        27        24        24        21        30         15\n10 Jewish        19        19        25        25        30        95         69\n11 Mainlin…     289       495       619       655       651      1107        939\n12 Mormon        29        40        48        51        56       112         85\n13 Muslim         6         7         9        10         9        23         16\n14 Orthodox      13        17        23        32        32        47         38\n15 Other C…       9         7        11        13        13        14         18\n16 Other F…      20        33        40        46        49        63         46\n17 Other W…       5         2         3         4         2         7          3\n18 Unaffil…     217       299       374       365       341       528        407\n# ℹ 3 more variables: `$100-150k` &lt;dbl&gt;, `&gt;150k` &lt;dbl&gt;,\n#   `Don't know/refused` &lt;dbl&gt;\n\n\nФункция pivot_longer() приведет данные в более удобоваримый вид:\nКомментарии: - cols- на основе каких переменных мы “переворачиваем” данные - names_to - как будет называться новая переменная (или переменные, если их несколько) - values_to- как будет называться переменная, содержащая частоту\n\nrelig_income %&gt;% \n  pivot_longer(\n    cols = !religion, \n    names_to = \"income\", \n    values_to = \"count\"\n  )\n\n# A tibble: 180 × 3\n   religion income             count\n   &lt;chr&gt;    &lt;chr&gt;              &lt;dbl&gt;\n 1 Agnostic &lt;$10k                 27\n 2 Agnostic $10-20k               34\n 3 Agnostic $20-30k               60\n 4 Agnostic $30-40k               81\n 5 Agnostic $40-50k               76\n 6 Agnostic $50-75k              137\n 7 Agnostic $75-100k             122\n 8 Agnostic $100-150k            109\n 9 Agnostic &gt;150k                 84\n10 Agnostic Don't know/refused    96\n# ℹ 170 more rows\n\n\nДавайте посмотрим на еще один вариант:\n\nbillboard\n\n# A tibble: 317 × 79\n   artist     track date.entered   wk1   wk2   wk3   wk4   wk5   wk6   wk7   wk8\n   &lt;chr&gt;      &lt;chr&gt; &lt;date&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 2 Pac      Baby… 2000-02-26      87    82    72    77    87    94    99    NA\n 2 2Ge+her    The … 2000-09-02      91    87    92    NA    NA    NA    NA    NA\n 3 3 Doors D… Kryp… 2000-04-08      81    70    68    67    66    57    54    53\n 4 3 Doors D… Loser 2000-10-21      76    76    72    69    67    65    55    59\n 5 504 Boyz   Wobb… 2000-04-15      57    34    25    17    17    31    36    49\n 6 98^0       Give… 2000-08-19      51    39    34    26    26    19     2     2\n 7 A*Teens    Danc… 2000-07-08      97    97    96    95   100    NA    NA    NA\n 8 Aaliyah    I Do… 2000-01-29      84    62    51    41    38    35    35    38\n 9 Aaliyah    Try … 2000-03-18      59    53    38    28    21    18    16    14\n10 Adams, Yo… Open… 2000-08-26      76    76    74    69    68    67    61    58\n# ℹ 307 more rows\n# ℹ 68 more variables: wk9 &lt;dbl&gt;, wk10 &lt;dbl&gt;, wk11 &lt;dbl&gt;, wk12 &lt;dbl&gt;,\n#   wk13 &lt;dbl&gt;, wk14 &lt;dbl&gt;, wk15 &lt;dbl&gt;, wk16 &lt;dbl&gt;, wk17 &lt;dbl&gt;, wk18 &lt;dbl&gt;,\n#   wk19 &lt;dbl&gt;, wk20 &lt;dbl&gt;, wk21 &lt;dbl&gt;, wk22 &lt;dbl&gt;, wk23 &lt;dbl&gt;, wk24 &lt;dbl&gt;,\n#   wk25 &lt;dbl&gt;, wk26 &lt;dbl&gt;, wk27 &lt;dbl&gt;, wk28 &lt;dbl&gt;, wk29 &lt;dbl&gt;, wk30 &lt;dbl&gt;,\n#   wk31 &lt;dbl&gt;, wk32 &lt;dbl&gt;, wk33 &lt;dbl&gt;, wk34 &lt;dbl&gt;, wk35 &lt;dbl&gt;, wk36 &lt;dbl&gt;,\n#   wk37 &lt;dbl&gt;, wk38 &lt;dbl&gt;, wk39 &lt;dbl&gt;, wk40 &lt;dbl&gt;, wk41 &lt;dbl&gt;, wk42 &lt;dbl&gt;, …\n\n\nЭто данные о песнях их ротации по радиостанциям и о занимаемой позиции:\n\nbillboard %&gt;% \n  pivot_longer(\n    cols = starts_with(\"wk\"), \n    names_to = \"week\", \n    values_to = \"rank\",\n    values_drop_na = TRUE\n  )\n\n# A tibble: 5,307 × 5\n   artist  track                   date.entered week   rank\n   &lt;chr&gt;   &lt;chr&gt;                   &lt;date&gt;       &lt;chr&gt; &lt;dbl&gt;\n 1 2 Pac   Baby Don't Cry (Keep... 2000-02-26   wk1      87\n 2 2 Pac   Baby Don't Cry (Keep... 2000-02-26   wk2      82\n 3 2 Pac   Baby Don't Cry (Keep... 2000-02-26   wk3      72\n 4 2 Pac   Baby Don't Cry (Keep... 2000-02-26   wk4      77\n 5 2 Pac   Baby Don't Cry (Keep... 2000-02-26   wk5      87\n 6 2 Pac   Baby Don't Cry (Keep... 2000-02-26   wk6      94\n 7 2 Pac   Baby Don't Cry (Keep... 2000-02-26   wk7      99\n 8 2Ge+her The Hardest Part Of ... 2000-09-02   wk1      91\n 9 2Ge+her The Hardest Part Of ... 2000-09-02   wk2      87\n10 2Ge+her The Hardest Part Of ... 2000-09-02   wk3      92\n# ℹ 5,297 more rows\n\n\nНам возможно было бы интересно, сколько недель какой-либо трек продержался в чарте, но для этого нужно превратить неделю из строковой переменной в числовую. Это можно сделать следующим образом:\n\nbillboard %&gt;% \n  pivot_longer(\n    cols = starts_with(\"wk\"), \n    names_to = \"week\", \n    names_transform = readr::parse_number,\n    values_to = \"rank\",\n    values_drop_na = TRUE,\n  )\n\n# A tibble: 5,307 × 5\n   artist  track                   date.entered  week  rank\n   &lt;chr&gt;   &lt;chr&gt;                   &lt;date&gt;       &lt;dbl&gt; &lt;dbl&gt;\n 1 2 Pac   Baby Don't Cry (Keep... 2000-02-26       1    87\n 2 2 Pac   Baby Don't Cry (Keep... 2000-02-26       2    82\n 3 2 Pac   Baby Don't Cry (Keep... 2000-02-26       3    72\n 4 2 Pac   Baby Don't Cry (Keep... 2000-02-26       4    77\n 5 2 Pac   Baby Don't Cry (Keep... 2000-02-26       5    87\n 6 2 Pac   Baby Don't Cry (Keep... 2000-02-26       6    94\n 7 2 Pac   Baby Don't Cry (Keep... 2000-02-26       7    99\n 8 2Ge+her The Hardest Part Of ... 2000-09-02       1    91\n 9 2Ge+her The Hardest Part Of ... 2000-09-02       2    87\n10 2Ge+her The Hardest Part Of ... 2000-09-02       3    92\n# ℹ 5,297 more rows\n\n\n\n\n7.11.2 Случай 2: из «длинного» в «широкий» формат\nФункция pivot_wider() является противоположной pivot_longer(): она расширяет набор данных за счет создания новых столбцов и сокращения количества строк. Например, это может быть полезно для написания отчетов или создания презентаций.\nЧтобы посмотреть на эту функцию в действии, давайте создадим “длинные” данные из набора о пингвинах:\n\nlibrary(palmerpenguins)\npenguins_long &lt;- penguins %&gt;%  \n  mutate(sample = row_number()) %&gt;%  \n  pivot_longer(contains(\"_\"),\n               names_to = c(\"part\", \"measure\" , \"unit\"),\n               names_sep = \"_\",\n               values_drop_na = TRUE)\npenguins_long\n\n# A tibble: 1,368 × 9\n   species island    sex     year sample part    measure unit   value\n   &lt;fct&gt;   &lt;fct&gt;     &lt;fct&gt;  &lt;int&gt;  &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;  &lt;dbl&gt;\n 1 Adelie  Torgersen male    2007      1 bill    length  mm      39.1\n 2 Adelie  Torgersen male    2007      1 bill    depth   mm      18.7\n 3 Adelie  Torgersen male    2007      1 flipper length  mm     181  \n 4 Adelie  Torgersen male    2007      1 body    mass    g     3750  \n 5 Adelie  Torgersen female  2007      2 bill    length  mm      39.5\n 6 Adelie  Torgersen female  2007      2 bill    depth   mm      17.4\n 7 Adelie  Torgersen female  2007      2 flipper length  mm     186  \n 8 Adelie  Torgersen female  2007      2 body    mass    g     3800  \n 9 Adelie  Torgersen female  2007      3 bill    length  mm      40.3\n10 Adelie  Torgersen female  2007      3 bill    depth   mm      18  \n# ℹ 1,358 more rows\n\n\nА теперь превратим их в широкий формат:\n\npenguins_long |&gt; \n  pivot_wider(names_from = c(\"part\", \"measure\", \"unit\"),\n              names_sep = \"_\",\n              values_from = value)\n\n# A tibble: 342 × 9\n   species island    sex     year sample bill_length_mm bill_depth_mm\n   &lt;fct&gt;   &lt;fct&gt;     &lt;fct&gt;  &lt;int&gt;  &lt;int&gt;          &lt;dbl&gt;         &lt;dbl&gt;\n 1 Adelie  Torgersen male    2007      1           39.1          18.7\n 2 Adelie  Torgersen female  2007      2           39.5          17.4\n 3 Adelie  Torgersen female  2007      3           40.3          18  \n 4 Adelie  Torgersen female  2007      5           36.7          19.3\n 5 Adelie  Torgersen male    2007      6           39.3          20.6\n 6 Adelie  Torgersen female  2007      7           38.9          17.8\n 7 Adelie  Torgersen male    2007      8           39.2          19.6\n 8 Adelie  Torgersen &lt;NA&gt;    2007      9           34.1          18.1\n 9 Adelie  Torgersen &lt;NA&gt;    2007     10           42            20.2\n10 Adelie  Torgersen &lt;NA&gt;    2007     11           37.8          17.1\n# ℹ 332 more rows\n# ℹ 2 more variables: flipper_length_mm &lt;dbl&gt;, body_mass_g &lt;dbl&gt;",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Tidyverse и трансформация данных</span>"
    ]
  },
  {
    "objectID": "TidyverseTransformations.html#самостоятельная-работа",
    "href": "TidyverseTransformations.html#самостоятельная-работа",
    "title": "7  Tidyverse и трансформация данных",
    "section": "7.12 Самостоятельная работа",
    "text": "7.12 Самостоятельная работа\n\nДля каждого направления (dest) по набору flights посчитайте общее пройденное расстояние, используя функцию sum().\nПерекодируйте переменную month таким образом, чтобы вместо цифр были названия месяцев.\nНа основе переменной air_time, показывающей время в полете в минутах, создайте переменную air_time_hours, в которой время переведено в часы.\nНабор данных о пингвинах penguins из библиотеки palmerpenguinsсгруппируйте по видам и полу пингвинов (species, sex) и посчитайте средний размер клюва в мм (bill_length_mm). Затем трансформируйте результаты так, чтобы получилась вот такая таблица (там будут пропущенные значения по полу, их нужно будет убрать):\n\n\n\n\n\n\nspecies\nfemale\nmale\n\n\n\n\nAdelie\n37.3\n40.4\n\n\nChinstrap\n46.6\n51.1\n\n\nGentoo\n45.6\n49.5\n\n\n\n\n\n\n\n\nВсе результаты оформить в виде документа RMarkdown и опубликовать на RPubs. Результаты прикрепить в виде ссылки.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Tidyverse и трансформация данных</span>"
    ]
  },
  {
    "objectID": "Base_ggplot2.html",
    "href": "Base_ggplot2.html",
    "title": "8  Основы визуализации в ggplot2",
    "section": "",
    "text": "8.1 Создаем первый график ggplot\nСоздадим график, визуализирующий взаимосвязь между объемом двигателя displ (по оси x) и расходом топлива на трассе hwy (по оси y):\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy))\nГрафик показывает наличие негативной взаимосвязи между объемом двигателя и эффективностью потребления топлива (сколько миль пожно проехать на одном галлоне), другими словами, чем больше объем двигателя, тем больше топлива требуется и тем меньше эффективность двигателя. Подтверждает ли график наши изначальные гипотезы?",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Основы визуализации в ggplot2</span>"
    ]
  },
  {
    "objectID": "Base_ggplot2.html#основная-синтаксическая-конструкция-ggplot2",
    "href": "Base_ggplot2.html#основная-синтаксическая-конструкция-ggplot2",
    "title": "8  Основы визуализации в ggplot2",
    "section": "8.2 Основная синтаксическая конструкция ggplot2",
    "text": "8.2 Основная синтаксическая конструкция ggplot2\nДавайте еще раз посмотрим на код, с помощью которого мы построили график:\nggplot(data = mpg) +   geom_point(mapping = aes(x = displ, y = hwy))\nКод всегда начинается с функции ggplot(), которая создает систему координат, на которую накладываются дальнейшие графические слои.\nПервый аргумент - data - указывает, какие данные нужно использовать для построения графика. Но если мы просто напишем ggplot(data = mpg) - график будет пустым (можете попробовать сами), так как мы больше ничего, кроме данных не добавили.\nЧтобы график получился, мы должны добавить к ggplot() по крайней мере один слой. Функция geom_point() добавляет слой в виде диаграммы рассеяния. Существует множетсво различных geom-функций, каждая из которых добавляет свой тип графического представления (слой). В рамках данного урока мы постараемся охватить несколько различных типов графиков, которые можно построить с помощью различных geom-ов.\nВнутри функции geom располагаются mapping-аргументы, определяющие, какие визуальные свойства будут присвоены переменным из нашего набора данных.\nАргумент mapping всегда идет в паре с функцией aes() (aes - сокращенное от Aesthetics - в русском языке есть похожее слово “эстетика”, одно из значений которого - “красота, художественная сущность объекта”, то есть данный аргумент отвечает за внешний вид нашего графика), и аргументы x и y функции aes() определяют, какие переменные будут располагаться по осям x и y.\nОбщая формула (шаблон) для графика выглядит следующим образом:\nggplot(data = &lt;DATA&gt;) +   &lt;GEOM_FUNCTION&gt;(mapping = aes(&lt;MAPPINGS&gt;))\nВ течение этого урока мы будем последовательно заменять различные части этого шаблона на реальные данные и настройки, чтобы строить графики различного типа.\nНачнем с компонента MAPPINGS.\nНа графике ниже, группа точек (закрашены в красный цвет), кажется, выпадает из общего тренда. В чем же дело? У этих машин явно лучше показатели эффективности топлива, чем мы могли бы ожидать. Как можно объяснить данное явление?\n\n\n\n\n\n\n\n\n\nПредположим, что, возможно, это гибридные машины, сочетающие различные виды топлива (например, бензин и электричество). Чтобы проверить эту гипотезу, мы можем посмотреть на переменную класса машины, согласно которой все автомобили в наборе данных классицируются как компактные (compact), среднего размера (midsize) или кроссоверы (SUV). Гибридные машины скорее всего принадлежат к классу компактных или субкомпактных (когда данные собирались, гибридные машины еще не были так распространены.\nДавайте добавим третью переменную - класс - к нашему двумерному графику в качестве дополнительного агрумента функции aes(). Такими аргументами могут быть: размер (size), форма (shape) или цвет наших точек (color). Мы можем отобразить точки разными способами, меняя характеристики аргументов, вернее присваивая им определенные “уровни”, например, сделать точки разного размера, формы или цвета:\n\nДавайте раскрасим точки на графике в зависимости от класса машины.\n\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy, color = class))\n\n\n\n\n\n\n\n\nЧто и требовалось доказать! Почти все точки выделенной группы - это красные точки, представляющие класс двухместных машин. На самом деле, это не совсем гибридные машины, это спортивные машины! У таких машин большие двигатели, как у кроссоверов или грузовиков, но маленькие кузова, как у компактных машин, что повышает их эффективность. То есть дело вовсе не в гибридности.\nЧтобы “привязять” аргумент aesthetic к переменной, нужно внутри функции aes() связать имя переменной с именем одного из аргументов (color, size, shape), и ggplot2 автоматически присвоит уникальный уровень каждому уникальному значению переменной (этот процесс называется масштабированием, по-английски scaling). Кроме того, ggplot2 автоматически добавит легенду, объясняющую, как уровни соответствуют значениям переменной.\nВ данном примере мы связали переменную “класс” с аргументом цвета, но мы могли бы таким же образом, вместо цвета выбрать другой аргумент, например “размер”. В этом случае, размер точки указывал бы на принадлежность к отдельному классу. Если мы запустим подобный код, программа нам выдаст предостережение о том, что применять такую “эстетику” к неупорядоченным данным (классы не имеют уровней, которые можно было бы привязать к размерам) - не очень хорошая идея.\n\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy, size = class))\n\n\n\n\n\n\n\n\nМы могли бы отметить класс с помощью атрибута alpha (отвечает за прозрачность) или с помощью атрибута формы (shape).\n\n# Выделяем разные классы с помощью прозрачности\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy, alpha = class))\n\nWarning: Using alpha for a discrete variable is not advised.\n\n\n\n\n\n\n\n\n\n\n# Выделяем классы с помощью форм для точек\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy, shape = class))\n\nWarning: The shape palette can deal with a maximum of 6 discrete values because more\nthan 6 becomes difficult to discriminate\nℹ you have requested 7 values. Consider specifying shapes manually if you need\n  that many have them.\n\n\nWarning: Removed 62 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\n\n\nЧто произошло с кроссоверами? Почему программа выдала ошибку? Дело в том, что в ggplot2 есть только шесть различных форм, которые могут использоваться одновременно. По умолчанию, если групп больше шести, то они на графике не отображаются.\nВажно отметить, что функция aes() собирает вместе все аргументы aesthetic, используемые в одном слое, при этом, переменные x и y тоже могут иметь свои характеристики. При этом пользователь лишь задает имена переменных, а ggplot2 заботится об остальном - подбирает нужную шкалу, обозначает оси именами переменных.\nМы можем установить дополнительные опции вручную, например, сделать все точки синего цвета:\nОбратите внимание, что color = \"blue\"указывается за скобками функции aes(), так как мы не создаем отдельного измерения (каким являлся класс, например), а присваеваем свойство цвета всему графику.\n\nggplot(data = mpg) +\n  geom_point(aes(x = displ, y = hwy), color = \"blue\")\n\n\n\n\n\n\n\n\nИными словами, цвет тут не несет никакой информации о данных, это просто характеристика внешнего вида, такая же как фон, цвет линий, шрифта и пр.\nЧтобы установить такие настройки, нужно вынести имя аргумента за пределы функции aes() и установить такое значение, которое бы имело значение для него (которое поймет R).\nНапример, имя цвета (color) - это строковая переменная (“red”, “blue”, “green” огромный список имен цветов - http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf)\nРазмер (size) - размер в мм.\nФорма тоже задается с помощью чисел (см. рисунок ниже):\n\n Самостоятельное задание:\n\nЧто не так с этим кодом? (попробуйте запустить, посмотреть и разобраться и в ячейке внизу написать правильный код)\n\nggplot(data = mpg) +   geom_point(mapping = aes(x = displ, y = hwy, color = \"blue\"))\n\nКакие переменные в наборе mpg являются категориальными, а какие непрерывными?\nВыберите одну из количественных переменных и включите ее в в код в качестве аргумента color, size или shape. Посмотрите, как различается представление категориальных и количественных переменных? В каком случае возникает ошибка? Почему?\nЧто произойдет, если одну и ту же переменную, например, drv, назначить в качестве аргумента в разных настройках (например, и в качестве shape и в качестве color)? Измените исходный код графика и запишите его ниже.\nВ функции geom_point есть еще несколько аргументов в функции aes(), например - stroke, fill и group. Посмотрите, примеры кода для построения графиков с такими аргументами и приведите один из примеров ниже.\nЧто произойдет, если вместо имены переменной указать что-то другое, наприме, aes(colour = displ &lt; 5)? Попробуйте измеить код и вставить ниже.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Основы визуализации в ggplot2</span>"
    ]
  },
  {
    "objectID": "Base_ggplot2.html#потенциальные-проблемы",
    "href": "Base_ggplot2.html#потенциальные-проблемы",
    "title": "8  Основы визуализации в ggplot2",
    "section": "8.3 Потенциальные проблемы",
    "text": "8.3 Потенциальные проблемы\nКогда вы начнете писать код на R, вероятнее всего, вы будете допускать ошибки и сталкиваться с проблемами. Не отчаивайтесь! Так происходит со всеми, даже очень опытными пользователями (вспомните ситуацию на лекции, когда мы пытались перевести список в вектор, и ничего не получилось).\n\nСовет: сравните свой код с кодом в примере, обращайте внимание на мелочи - расположение скобок и запятых, особенно знаков “+”, связывающих разные слои графической информации. Также обязательно посчитайте количество скобок - каждая открывающая скобка должна иметь свою пару - закрывающую скобку, в противном случае, будут возникать ошибки.\n\nИногда вы можете запустить код, а ничего не происходит. Если вы работаете в RStudio, посмотрите в окно консоли - знак + будет означать, что в ваш код не закончен и “чего-то не хватает”. В этом случае, чаще всего, лучше нажать клавишу Esc и начать все заново (ну, или кропотливо, символ за символом, проверить, что не так).\nОдна из часто встречающихся проблем при создании графиков ggplot2 постановка + в неправильном месте: знак должен быть в конце строки, не в начале. Удостоверьтесь, что ваш код не похож на такой:\n\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy))\n\n\n\n\n\n\n\n\nЕсли вы не смогли исправить ошибку, не стесняйтесь обращаться за помощью к справочным материалам. По любой функции можно запустить справку с помощью кода ?имя_функции в консоли или выбрать имя функции и нажать на клавишу F1 в RStudio. Полезные материалы можно найти на ресурсах: http://r-bloggers.com/, http://www.cookbook-r.com/, https://stackoverflow.com/questions/tagged/r и др.\nЕще один совет: тщательно читайте сообщение об ошибке. Чаще всего ответ кроется именно в нем. Можно “загуглить” сам текст ошибки: с большой вероятностью кто-то уже встречался с подобным случаем, и решение уже было найдено.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Основы визуализации в ggplot2</span>"
    ]
  },
  {
    "objectID": "Base_ggplot2.html#facets-аспекты",
    "href": "Base_ggplot2.html#facets-аспекты",
    "title": "8  Основы визуализации в ggplot2",
    "section": "8.4 Facets (аспекты)",
    "text": "8.4 Facets (аспекты)\nКроме возможности отобразить переменные на графике в качестве эстетических атрибутов, можно их представить (особенно хорошо - если они категориальные) - на отдельных графиках, то есть разбить основной график на несколько мелких, в каждом из которых будет отражаться дополнительная информация, задаваемая путем разделения данных на отдельные поднаборы (подгруппы).\nЧтобы разбить график на отдельные подгруппы на основе одной переменной можно использовать функцию facet_wrap(). Ее первый аргумент - это формула, которая создается с помощью знака тильды ~, за которым следует имя переменной (формула - это не уравнение, а тип структур данных, с помощью которых задается алгоритм анализа). Переменную, которую вы используете для facet_wrap должна быть дискретной (то есть иметь конкретные числовые значения). Например, разобьем наш график взаимосвязи между расходом топлива и объемом двигателя на основе переменной класса:\n\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy)) +\n  facet_wrap(~ class, nrow = 2)\n\n\n\n\n\n\n\n\nЧтобы разбить график на основе двух дополнительных переменных, используется функция facet_grid(). Первый аргумент этой функции - тоже формула, но в ней уже должно содержаться две переменных, разделенных тильдой ~.\n\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy)) +\n  facet_grid(drv ~ cyl)# разбиваем график на отдельные графики - по вертикали тип привода, по горизонтали - количество цилиндров.\n\n\n\n\n\n\n\n\nЭту функцию можно использовать и с одной переменной, просто поставьте точку . вместо одного из имен переменных, например + facet_grid(. ~ cyl).\n\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy)) +\n  facet_grid(. ~ cyl)\n\n\n\n\n\n\n\n\nУпражнения: 1. Что произойдет, если в функцию facet вставить непрерывную переменную? 2. Что означают пустые ячейки в графике с facet_grid(drv ~ cyl)?\nВставьте тут свой комментарий:",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Основы визуализации в ggplot2</span>"
    ]
  },
  {
    "objectID": "Base_ggplot2.html#геометрические-объекты-geometric-objects---geoms",
    "href": "Base_ggplot2.html#геометрические-объекты-geometric-objects---geoms",
    "title": "8  Основы визуализации в ggplot2",
    "section": "8.5 Геометрические объекты (geometric objects - geoms)",
    "text": "8.5 Геометрические объекты (geometric objects - geoms)\nЧем похожи эти два графика?\n\n\nОба графика имеют одни и те же x и y переменные, оба - описывают одни и те же данные. Но все же они не идентичны. Каждый график представляет данные по своему, использует разные визуальные объекты. Каждый такой объект в синтаксисе ggplot2 называется geom.\nЛюди описывают графики по типу геометрического объекта, который лежит в его основе. Например, столбчатые диаграммы (bar charts) используют bar geom, линейчатаые диагранны (line chart) - line geom, ящичные (boxplot) - boxplot geom и так далее. Для диаграммы рассеяния есть point geom.\nМы можем использовать разные geom-ы, чтобы по-разному представлять наши данные. Так, на графике выше слева предствлена точечная диаграмма (диаграмма рассеяния), а справа приведена линейная диаграмма со сглаживанием (smooth geom), где линия соответствует степенной функции, максимально приближенной к исходным данным.\nЧтобы поменять геометрический объект на графике, нужно изменить функцию geom. Чтобы воспроизвести код на картинке:\n\n# Левый график\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy))\n\n\n\n\n\n\n\n# Правый график\nggplot(data = mpg) +\n  geom_smooth(mapping = aes(x = displ, y = hwy))\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nУ каждой функции geom в библиотеке ggplot2 есть свои аргументы mapping, но не с каждым geom будет работать каждый эстетический аргумент. Например, мы можем установить форму (shape) для точки, но не сможем сделать это для линии. А для линии возможно установить аргумент linetype (тип линии), и geom_smooth() нарисует различные линии для каждого уникального значения переменной, которая указана для данного аргумента.\nПример:\n\nggplot(data = mpg) +\n  geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv))\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nВ этом примере geom_smooth() разделяет машины на три группы, в зависимости от значения привода (drv), и по каждой группе отображает отдельную линию. Так, одна линия описывает все полноприводные машины (4), другая - переднеприводные (f), третья - заднеприводные (r).\nМы можем добавить цвета для наглядности:\n\nggplot(data = mpg) +\n  geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv, color=drv))+\n  geom_point(mapping = aes(x = displ, y = hwy, color=drv))\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nОбратите внимание, что этом графике мы использовали два слоя - точечную диаграмму и сглаживание!\nВ библиотеке ggplot2 содержится более 40 geom-функций, а в дополнительных библиотеках - еще больше (подробности можно посмотреть здесь: https://r-graph-gallery.com/, https://exts.ggplot2.tidyverse.org/gallery/). Чтобы узнать больше по каждой функции, запросите справку, например: ?geom_smooth.\nДавайте рассмотрим еще один пример с двойным слоем, где одни и те же данные отображены на графике и как диаграмма сглаживания и как диаграмма рассеяния:\n\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy)) +\n  geom_smooth(mapping = aes(x = displ, y = hwy))\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nНаверняка вы заметили, что происходит дублирование кода (в скобках), и если нам бы понадобилось поменять переменную, то пришлось бы менять ее дважды - в каждом слое. Это не очень рационально, и можно сделать код более лаконичным благодаря переносу эстетических аргументов на уровень вверх, в основную функцию ggplot(). Тогда ggplot2 будет считать эти аргументы глобальными и применять ко всем геометрическим объектам графика.\nВот как можно было сделать:\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +\n  geom_point() +\n  geom_smooth()\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nСоответственно, если вы указываете эстетические аргументы внутри функции-geom, то ggplot2 рассматривает их как локальные аргументы слоя. В этом случае (поскольку код обрабатывается последовательно), настройки слоя “переписывают” глобальные настройки, что позволяет еще больше дифференцировать внешний вид нашего графика.\nПример:\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + #глобальные настройки\n  geom_point(mapping = aes(color = class)) + #локальные настройки для точечного графика\n  geom_smooth()\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nЭту идею можно развить дальше для того, чтобы каждый слой представлял только определенные данные. В примере ниже, сглаженная линия отображает только данные по одному классу - субкомпактных машин, и локальный аргумент фильтра данных в geom_smooth() как бы переписывает аргументы в глобальных настройках, но только для этого слоя.\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +\n  geom_point(mapping = aes(color = class)) +\n  geom_smooth(data = filter(mpg, class == \"subcompact\"), se = FALSE)\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Основы визуализации в ggplot2</span>"
    ]
  },
  {
    "objectID": "Base_ggplot2.html#темы",
    "href": "Base_ggplot2.html#темы",
    "title": "8  Основы визуализации в ggplot2",
    "section": "8.6 Темы",
    "text": "8.6 Темы\nТе графики, которые мы только что создали, оформлены с помощью темы по умолчанию, но она может нас не устраивать. Возможно, кому-то не понравится решетка или серый фон, комку-то захочется убрать легенду или поменять оформление осей. Всеми этими параметрами управляет такой слой графика, как тема - theme. Параметром по умолчанию является тема - theme_grey().\nВ библиотеке ggplot2 встроено 11 разных тем.\nДавайте возьмем наш базовый график и попробуем применить к нему различные темы:\n\ntheme_bw()\ntheme_void()\ntheme_dark()\n\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +\n  geom_point() +\n  geom_smooth() +\n  theme_bw()\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nКроме встроенных тем, есть по меньшей мере пять библиотек, специализирующихся на разработке тем для ggplot2.\nДополнительный материал: https://r-charts.com/ggplot2/themes/",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Основы визуализации в ggplot2</span>"
    ]
  },
  {
    "objectID": "Base_ggplot2.html#статистические-трансформации",
    "href": "Base_ggplot2.html#статистические-трансформации",
    "title": "8  Основы визуализации в ggplot2",
    "section": "8.7 Статистические трансформации",
    "text": "8.7 Статистические трансформации\nМы много времени уделили количественным переменными, давайте теперь посмотрим на качественные (категориальные), каких в социологических исследований встречается огромное количество. Чаще всего для их визуализации используются столбчатые диаграммы (bar chart), которые кажутся простыми, но только с первого взгляда, так как на самом деле не все так просто.\nПредставим себе базовый график, созданный с помощью функции geom_bar(). На графике ниже представлена информация о количестве бриллиантов из одноименного набора данных (diamonds), сгруппированных по критерию огранки (cut). Датасет diamonds прилагается к библиотеке ggplot2 и содержит информацию о ~54,000 бриллиантах, включая данные о цене (price) количестве каратов (carat), цвете (color), чистоте (clarity) и огранке (cut). График ниже показывает, что количество бриллиантов с хорошим качеством огранки больше, чем плохих бриллиантов с огранкой похуже.\n\nggplot(data = diamonds) +\n  geom_bar(mapping = aes(x = cut))\n\n\n\n\n\n\n\n\nПо оси x у нас располагается переменная cut (огранка), а по оси y - количество (count).\nЗдесь может быть непонятный момент, откуда взялось количество, ведь такой переменной в наборе нет?\nЗдесь нужно пояснить, что многие типы графиков (типа диаграмм рассеяния) отображают на графике сами значения, тогда как другие - например барчарты или гистограммы, полигоны частот разделяют данные на группы (bins), а затем по каждой группе рассчитывают частоты или другие показатели.\nДиаграммы, демонстрирующие подгонку кривых, строят модель, а затем визуализируют предсказания данной модели.\nБоксплоты рассчитывают робастные показатели (медиану, квартили) и отображают их в характерном виде.\nСоответственно, алгоритм, который используется для подсчета новых значений, используемых в графике, называется статистической трансформацией.\nО том, какую статистику использует каждый geom, можно узнать, проинспектировав статистику, рассчитываемую по умолчанию. Так, ?geom_bar показывает, что статистика по умолчанию для барчарта - это stat_count() - то есть простой подсчет количества.\nМы можем использовать geom-ы и статистические функции как взаимозаменяемые. Например, мы можем воспроизвести предыдущий график не с помощью geom_bar (), а с помощью stat_count(), результат будет идентичным:\n\nggplot(data = diamonds) +\n  stat_count(mapping = aes(x = cut))\n\n\n\n\n\n\n\n\nТакой подход работает, потому что у каждого geom есть своя статистика, а у каждой статистики - свой типичный график.\nИменно поэтому мы можем создавать графические слои, не беспокоясь о том, что нам могут потребоваться какие-то статистические расчеты.\nОднако иногда мы можем задавать статистику принудительно, вместо установок по умолчанию. Например, если мы хотим вместо количества (абсолютные значения) указать относительные частоты (проценты):\n\nggplot(data = diamonds) +\n  geom_bar(mapping = aes(x = cut, y = stat(prop), group = 1))\n\nWarning: `stat(prop)` was deprecated in ggplot2 3.4.0.\nℹ Please use `after_stat(prop)` instead.\n\n\n\n\n\n\n\n\n\nДополнительный материал: в библиотеку ggplot2 включено более 20 статистических функций, которые мы можем использовать в своих визуализациях https://ggplot2.tidyverse.org/reference/#stats",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Основы визуализации в ggplot2</span>"
    ]
  },
  {
    "objectID": "Base_ggplot2.html#дополнительные-настройки-цвета",
    "href": "Base_ggplot2.html#дополнительные-настройки-цвета",
    "title": "8  Основы визуализации в ggplot2",
    "section": "8.8 Дополнительные настройки цвета",
    "text": "8.8 Дополнительные настройки цвета\nСо столбчатыми диаграммами связана еще одна «магическая история»: мы можем применять настройки цвета как в отношении контура (обычный аргумент color), так и заполнять цветом столбцы (аргумент fill):\n\n# Посмотрите на эти два графика и найдите отличия\nggplot(data = diamonds) +\n  geom_bar(mapping = aes(x = cut, colour = cut))\n\n\n\n\n\n\n\nggplot(data = diamonds) +\n  geom_bar(mapping = aes(x = cut, fill = cut))\n\n\n\n\n\n\n\n\nЧто произойдет, если мы аргументу fill присвоим другую переменную, например чистоту (clarity): столбцы автоматически разделяются по группам, и каждый столбец представляет собой комбинацию огранки и чистоты.\n\nggplot(data = diamonds) +\n  geom_bar(mapping = aes(x = cut, fill = clarity))\n\n\n\n\n\n\n\n\nЕсли мы не желаем, чтобы у нас получилась комбинированная диаграмма, мы должны использовать аргумент, задающий позицию элементов - position: identity, dodge или fill:\n\nposition = “identity” - поставит каждый объект на ту позицию, которую он занимает в контексте. С барчартами применять не очень актуально, поскольку получается пересечение категорий, что хорошо заметно, если вместо закрашивания использовать прозрачность или вообще убрать цвет, а вот для точечных диаграмм это позиция по умолчанию:\n\n\nggplot(data = diamonds, mapping = aes(x = cut, fill = clarity)) +\n  geom_bar(alpha = 1/5, position = \"identity\")\n\n\n\n\n\n\n\nggplot(data = diamonds, mapping = aes(x = cut, colour = clarity)) +\n  geom_bar(fill = NA, position = \"identity\")\n\n\n\n\n\n\n\n\n\nposition = “fill” работает по типу накопленной диаграммы, приводит все столбцы к единой высоте, что позволяет более наглядно представить распределение ответов и сравнивать группы.\n\n\nggplot(data = diamonds) +\n  geom_bar(mapping = aes(x = cut, fill = clarity), position = \"fill\")\n\n\n\n\n\n\n\n\n\nposition = “dodge” помещает пересекающиеся объекты рядом друг с другом, что позволяет сравнить индивидуальные значения по каждой категории.\n\n\nggplot(data = diamonds) +\n  geom_bar(mapping = aes(x = cut, fill = clarity), position = \"dodge\")\n\n\n\n\n\n\n\n\nЕсть еще один тип уточнения позиции, который не очень подходит для барчартов, но может быть полезен для диаграмм рассеяния.\nПомните наш первый график? Отметили ли вы, что на графике всего 126 точек (может быть вы и не считали, но просто засомневались, что на графике отображены не все данные)? А ведь в наборе 234 наблюдения.\n\n\n\nЗначения переменных hwy и displ приводятся в округленном виде, что приводит к тому, что на графике точки располагаются одна над другой, происходит их пересечение. Соответственно, нам не очень хорошо видно скопление точек, это может быть очень критичный момент для анализа.\nЧтобы избежать такой ситуации, пожно применить аргумент мэппинга position = \"jitter\", который добавляет немного статистического шума к каждой точке и, таким образом, раздвигает их немного в стороны.\n\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy), position = \"jitter\")\n\n\n\n\n\n\n\n\nЧтобы узнать больше, просим запустить справку: ?position_dodge, ?position_fill, ?position_identity, ?position_jitter, ?position_stack.\nУпражнения: 1. Какие проблемы у этого графика? Как сделать его лучше?\nggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +   geom_point()\n\nСоздайте столбчатый график, покзывающий взаимосвязь между цветом и огранкой бриллиантов. Сделайте настройки так, чтобы столбцы были одинаковой длины.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Основы визуализации в ggplot2</span>"
    ]
  },
  {
    "objectID": "Base_ggplot2.html#поворот-системы-координат",
    "href": "Base_ggplot2.html#поворот-системы-координат",
    "title": "8  Основы визуализации в ggplot2",
    "section": "8.9 Поворот системы координат",
    "text": "8.9 Поворот системы координат\nПоследний вопрос, который мы рассмотрим, связан с поворотом системы координат, которое иногда применяется для того, чтобы сделать график более читаемым.\ncoord_flip() меняет местами оси x и y. Применяется, например, для транспонирования боксплота, если метки переменных очень длинные и не входят по ширине:\n\nggplot(data = mpg, mapping = aes(x = class, y = hwy)) +\n  geom_boxplot()#обычный боксплот\n\n\n\n\n\n\n\n\n\nggplot(data = mpg, mapping = aes(x = class, y = hwy)) +\n  geom_boxplot() +\n  coord_flip()#повернутый боксплот\n\n\n\n\n\n\n\n\ncoord_polar() превращает столбчатую диаграмму в круговую, в итоге получается график - нечто среднее между столбчатым графиком и графиком “петушиный гребень”.\n\nbar &lt;- ggplot(data = diamonds) +\n  geom_bar(\n    mapping = aes(x = cut, fill = cut),\n    show.legend = FALSE,\n    width = 1\n  ) +\n  theme(aspect.ratio = 1) +\n  labs(x = NULL, y = NULL)\n\nbar + coord_flip()#линейчатая диаграмма (перевернутый барчарт)\n\n\n\n\n\n\n\n\n\nbar + coord_polar()#диаграмма с круговыми координатами",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Основы визуализации в ggplot2</span>"
    ]
  },
  {
    "objectID": "Base_ggplot2.html#самостоятельная-работа",
    "href": "Base_ggplot2.html#самостоятельная-работа",
    "title": "8  Основы визуализации в ggplot2",
    "section": "8.10 Самостоятельная работа",
    "text": "8.10 Самостоятельная работа\n\nКакой geom нужно использовать, чтобы нарисовать линейный график? А боксплот? А гистограмму? А диаграмму с областями (area chart)? Создайте такие графики для переменных набора mpg, mtcars или diamonds.\n\nИспользуйте памятку: \n\nПостройте вот такие графики:\n\n\n\n\n\n\n\n\nПостройте перевернутый барчарт по одной из категориальных переменных набора данных diamonds.\nПримените опцию coord_polar() к созданному графику.\nВсе результаты оформить в виде документа RMarkdown и опубликовать на RPubs. Результаты прикрепить в виде ссылки.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Основы визуализации в ggplot2</span>"
    ]
  },
  {
    "objectID": "ExploratoryDataAnalysis.html",
    "href": "ExploratoryDataAnalysis.html",
    "title": "9  Разведочный анализ данных в R",
    "section": "",
    "text": "9.1 Для чего нам нужен разведочный анализ (Exploratory Data Analysis)\nРазведочный анализ в общем смысле – это предварительный анализ данных с целью выявления наиболее общих зависимостей, закономерностей и тенденций, характера и свойств анализируемых данных, законов распределения анализируемых величин. Именно с разведочного анализа начинается любая обработка данных результатов научного исследования.\nПри этом, разведочный анализ - это не какой-то один статистический тест или метод. При разведочном анализе учитывается и сравнивается большое число признаков, а для поиска закономерностей или обоснования имеющихся различий используются самые разные процедуры и техники.\nТермин «разведочный анализ» и набор техник, которые применяются для его проведения, был впервые введен и популяризирован американским математиком и статистиком из Принстонского университета Джоном Тьюки, написавшим в 1977 году книгу «Разведочный анализ данных» (Exploratory Data Analysis).\nЭтот термин кажется «сухим» и «занудным», однако практики, используемые в рамках разведочного анализа, не только являются крайне важными, но и весьма волнующими для исследователя. Не случайно, сам Дж. Тьюки сравнил EDA с работой детектива: каждый новое исследование данных представляет собой «мистическую историю», которую мы должны расследовать, вскрыть скрытые свойства и секретные характеристики наших данных.\nОсновными целями разведочного анализа являются:\nРезультаты разведочного анализа не используются напрямую для выработки управленческих решений, скорее они предоставляют помощь в разработке лучшей стратегии углубленного анализа, способствуют выдвижению новых гипотез, обосновывают возможности применения тех или иных математических методов и моделей. Без разведочного анализа дальнейший анализ данных, часто включающий разработку комплексных статистических моделей, будет производиться практически «вслепую».\nРазведочный (эксплораторный, описательный) анализ данных по своему содержанию, целям и задачам противопоставлен подтверждающему анализу данных (Confirmatory Data Analysis), основанному на конкретных предположениях и уже имеющихся данных.\nК основным методам разведочного анализа относятся анализ распределений, особенно с помощью методов визуального анализа (гистограмм, диаграмм рассеяния, ящичных диаграмм), тестирование гипотез о соответствии определенному виду распределения, методы группового и корреляционного анализа. Довольно часто к методам разведочного анализа также относят техники, позволяющие осуществить кластеризацию и снизить размерность данных, графически представить высоко-размерные данные, включающие множество переменных, в также предсказательные модели, такие как линейная регрессия, использующие данные и статистические показатели для предсказания целевых показателей. В рамках данного пособия такие методы будут рассмотрены в следующем разделе, посвященном многомерному анализу и возможностям статистического моделирования.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Разведочный анализ данных в R</span>"
    ]
  },
  {
    "objectID": "ExploratoryDataAnalysis.html#для-чего-нам-нужен-разведочный-анализ-exploratory-data-analysis",
    "href": "ExploratoryDataAnalysis.html#для-чего-нам-нужен-разведочный-анализ-exploratory-data-analysis",
    "title": "9  Разведочный анализ данных в R",
    "section": "",
    "text": "проникновение в данные и описание их во всей полноте;\nвыявление основных структур (паттернов) и тенденций;\nидентификация взаимосвязей и корреляций между переменными\nвыбор наиболее важных переменных;\nобнаружение отклонений и аномалий;\nпроверка основных гипотез (предположений);\nразработка начальных моделей и подготовка данных для дальнейшего анализа.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Разведочный анализ данных в R</span>"
    ]
  },
  {
    "objectID": "ExploratoryDataAnalysis.html#анализ-характеристик-распределения-количественной-переменной",
    "href": "ExploratoryDataAnalysis.html#анализ-характеристик-распределения-количественной-переменной",
    "title": "9  Разведочный анализ данных в R",
    "section": "9.2 Анализ характеристик распределения количественной переменной",
    "text": "9.2 Анализ характеристик распределения количественной переменной\nМы начнем наше разведочное исследование с количественных переменных и затем перейдем к категориальным переменным, двумерному и корреляционному анализу.\nЧтобы наши действия были ближе к «социологической жизни», мы будем использовать результаты исследования восприятия и оценки адаптивных стратегий населения в отношении климатических рисков в высокогорных районах Алтая.\n\nЕсли Вы не сохранили данные с предыдущих занятий, скачайте их еще раз.\nСкачать данные/\n\n\nlibrary(haven)\ndf&lt;-read_sav(\"files/База_КлимРиск_2023.sav\")\n\nПрежде, чем мы начнем «препарировать» наши данные, давайте взглянем на них издалека, в целом. Для этой цели хорошо подойдут библиотеки так называемого автоматизированного разведочного анализа, позволяющие быстро подготовить отчеты сразу по всему массиву данных, представить остовные статистики и графики. В R существует по меньшей мере 10 таких библиотек, наиболее известными из которых являются: - summarytools - DataExplorer - visdat - funModeling - arsenal - dataMaid - dlookr\nПодробный анализ данных библиотек в действии, их положительных и отрицательных сторон, можно найти в статье: Mateusz Staniak и Przemysław Biecek The Landscape of RPackages for Automated Exploratory Data Analysis.\nМы воспользуемся некоторыми функциями библиотеки DataExplorer. Для начала установим ее:\n\ninstall.packages(\"DataExplorer\")\n\nПосле установки, как всегда, загружаем библиотеку в текущую сессию и запускаем ее:\n\nlibrary(DataExplorer)\n\nДавайте проведем самый общий анализ по всей базе данных с помощью функции introduce(), которая выдаст нам самые общие сведения: количество строк и колонок (переменных), сколько из них являются дискретными и непрерывными, если такие переменные, в которых все данные пропущены, а также данные о количестве наблюдений и пропущенных значений.\n\nintroduce(df)\n\n\n\n\n\n\nrows\n913\n\n\ncolumns\n202\n\n\ndiscrete_columns\n29\n\n\ncontinuous_columns\n173\n\n\nall_missing_columns\n0\n\n\ntotal_missing_values\n30851\n\n\ncomplete_rows\n0\n\n\ntotal_observations\n184426\n\n\nmemory_usage\n1854656\n\n\n\n\n\n\n\nЧтобы визуализировать данную таблицу, можно использовать функцию plot_intro(). На графике отображаются основные показатели набора данных - количество дискретных и непрерывных переменных, полных наблюдений и переменных с отстутствующими значениями.\nПочему у нас так много пропусков и нет ни одной строки с полными данными? Все просто: ведь в ходе анализа учитываются абсолютно все переменные набора, включая дополнительные переменные «Другое», которые вполне могли остаться пустыми, если респондент не выбирал данный вариант ответа, а также переменные, предназначенные для определенных категорий респондентов, на которые по определению отвечали не все. Если бы мы отобрали меньшее количество переменных, которые нам нужны для конкретного анализа, результаты были бы совершенно иными. Кроме того, следует учитывать, что при подсчете «дискретных» и «непрерывных» переменных функция руководствуется результатам присвоения категорий данных в SPSS и их импорта в haven. Так что, если изначально тип переменной был задан неверно, то и результаты такого анализа, мягко скажем, не будут соответствовать действительности.\n\nplot_intro(df)\n\n\n\n\n\n\n\n\nВ доказательство вышеприведенного тезиса приведем график пропущенных значений по некоторым переменным. Можно легко заметить, что переменные образуют две группы - те, где количество пропусков не составляет выше 5% и переменные, где пропусков существенно больше (обозначены оранжевым цветом). Это ответы на вопрос 9, где спрашивалось о том, каким имуществом владели домохозяйства, проживающие в горных районах (сельхозтехника, сад, огород, пастбище, участки леса и пр.). Нет ничего удивительного в том, что более пятой части опрошенных не обладали ни одним из перечисленных вариантов, более того, часть из них, учитывая, что опрос проводился в зонах экстремального земледелия (приравненных к условиям Крайнего Севера), можно считать признаками высокого статуса и богатства (например, если у жителя есть в пользовании теплица и он может сам выращивать овощи).\n\nplot_missing(df[,30:50])\n\n\n\n\n\n\n\n\n\n9.2.1 Основные описательные характеристики\nУ нас не так много количественных данных, и одной из непрерывных переменных является возраст (age).\nСамым простым способом анализа основных характеристик распределения является базовая функция summary(), предоставляющая семь ключевых статистик: минимум, максимум, среднее, медиану, 1-й и 3-й квартили, а также количество пропущенных значений:\n\nsummary(df$age)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n     11      33      42      44      55      91      26 \n\n\nБолее расширенный статистический анализ можно получить, обратившись к функции describe()из библиотеки psych (не забываем устанавливать новые библиотеки). Набор аргументов по умолчанию достаточно широк: здесь уже есть и стандартное отклонение, и усеченное среднее, и показатели асимметрии и эксцесса.\n\npsych::describe(df$age)\n\n\n\n\n\n\n\nX1\n\n\n\n\nvars\n1.00\n\n\nn\n887.00\n\n\nmean\n44.00\n\n\nsd\n14.57\n\n\nmedian\n42.00\n\n\ntrimmed\n43.57\n\n\nmad\n16.31\n\n\nmin\n11.00\n\n\nmax\n91.00\n\n\nrange\n80.00\n\n\nskew\n0.32\n\n\nkurtosis\n-0.39\n\n\nse\n0.49\n\n\n\n\n\n\n\nВпрочем, каждый из них можно получить отдельно, с помощью базовых функций, например, стандартное отклонение:\n\nsd(df$age, na.rm = T)\n\n[1] 14.57424\n\n\nДисперсия:\n\nvar(df$age, na.rm = T)\n\n[1] 212.4086\n\n\nАсимметрия:\n\npsych::skew(df$age, na.rm = T)\n\n[1] 0.3166113\n\n\n\n\n9.2.2 Графические методы анализа распределения\nБольшую роль в анализе данных играет визуализация, и в случае анализа количественных переменных она просто незаменима. Часто именно график, без какого-либо статистического анализа, дает лучшее представление о том, что происходит с данными, тогда как статистические «точечные» оценки, такие как среднее или дисперсия, могут ввести в заблуждение.\nКоличественную переменную обычно графически представляют несколькими разными способами: - с помощью гистограмм; - с помощью квантильного графика; - с помощью ящичной диаграммы.\nСамый быстрый и простой способ получения гистограммы - с помощью базовой функции hist():\n\nhist(df$age, col=\"steelblue\", xlab = \"Возраст (лет)\", main=\"Возраст опрошенных\")\n\n\n\n\n\n\n\n\nЕсли мы хотим более «продвинутый» вариант гистограммы, можно обратиться к возможностям библиотеки ggstatsplots, основанной на философии создания визуальных материалов в рамках библиотеки ggplot2 и предназначенной для создания публикабельных визуализаций, сопровожденной результатами статистического анализа и возможностями проверки статистических гипотез. При несколько излишней сложности, это, пожалуй, лучшее, что есть сегодня в плане описательного анализа. Это не просто библиотека, создающая графики, это одновременно и способ визуализации, и способ проведения статистического анализа, включая представление регрессионных моделей и мета-анализ.\n\nggstatsplot::gghistostats(\n  data            = df,\n  x               = age,\n  xlab            = \"Возраст\",\n  effsize.type = \"d\",\n  type = \"parametric\",\n  test.value = 40.4 #Протестируем гипотезу об отличии среднего возраста по выборке от среднего возраста россиян\n)\n\n\n\n\n\n\n\n\nРезультаты визуального анализа указывают на то, что наше среднее (44,0 года) довольно сильно отклоняется от общероссийских данных, что было протестировано с помощью одновыборочного t-критерия. Однако, довольно заметно, что у наших данных положительная асимметрия и довольно длинный «хвост» из больших значений. Попробуем робастный подход, где вместо среднего используется усеченное среднее (по умолчанию в настройках указывается значение «усечения» - 0.2), а для подсчета p-значения при сравнении средних используется метод [бутстрэпа](https://ru.wikipedia.org/wiki/%D0%91%D1%83%D1%82%D1%81%D1%82%D1%80%D1%8D%D0%BF_(%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%81%D1%82%D0%B8%D0%BA%D0%B0). Результаты неутешительные - различия по-прежнему значимые.\n\nggstatsplot::gghistostats(\n  data            = df,\n  x               = age,\n  xlab            = \"Возраст\",\n  effsize.type = \"d\",\n  type = \"robust\",\n  test.value = 40.4 #Протестируем гипотезу об отличии среднего возраста по выборке от среднего возраста россиян\n)\n\n\n\n\n\n\n\n\nЕще один очень важный график: квантильный или Q-Q plot.\nАрхитектура этого графика проста: по оси x откладываются квантили для эмпирических данных, а по оси y - квантили распределения, с которыми мы их сравниваем (обычно - нормальное). Таким образом, Q-Q plot это диаграмма рассеяния, в которой два набора квантилей представлены друг напротив друга. Если оба они происходят из одного распределения, мы увидим точки, формирующие прямую.\nЧто такое квантиль?\nКвантиль — это одна из точек, делящих функцию плотности распределения на участки, вероятность попадания в которые одинакова, то есть на участки одинаковой площади.\n\nКвантильная функция — это функция, которая по значению вероятности P возвращает такое число (квантиль) q, что вероятность того, что случайная величина примет значение меньше q равняется P:\n В базовом R, чтобы создать такой график, нужно соединить две функции - qqnorm () иqqline()`. Одна создает, собственно квантильный график, другая - референтную прямую, на которую можно ориентироваться при оценке полученных значений.\n\nqqnorm(df$age, frame = FALSE)\nqqline(df$age, col = \"steelblue\", lwd = 2)\n\n\n\n\n\n\n\n\nКак всегда, могут быть и другие варианты. На мой личный вкус один из лучших QQ-plot создается в библиотеке ggpubr, позволяющей добавить на график доверительные интервалы для квантилей, а также выбрать тему, применить трансформации к шкалам (“log2”, “log10”, “sqrt”), изменить другие настройки:\n\nggpubr::ggqqplot(df, x = \"age\", color = \"steelblue\")\n\n\n\n\n\n\n\n\nЕще одна форма графического представления количественных данных - ящичная диаграмма.\nАнатомию данного графика лучше представить в визуальном виде (см. рисунок ниже). В центре графика - медиана, сам «ящик» формируется на основе межквартильного размаха (IQR), а «усы» ограничиваются либо минимальным и максимальным значениями, либо границами Q3+1,5*IQRи Q1-1,5*IQR, если в распределении имеются выбросы.\n Можно воспользоваться простой функцией `boxplot(), либо использовать более изощренные варианты.\n\nboxplot(df$age, col=\"steelblue\")\n\n\n\n\n\n\n\n\n\nlibrary(ggplot2)\nggplot(df, aes(y=age, fill=\"red\")) + \n  geom_boxplot()+\n  theme_bw()+\n  theme(legend.position=\"none\")\n\n\n\n\n\n\n\n\n\n\n9.2.3 Нахождение аномальных наблюдений\nУже на гистограмме и квантиль-квантильном графе хорошо видны все «огрехи» распределения, а ящичная диаграмма даже выносит особые наблюдения («статистические выбросы») за пределы основного графика.\nМы могли бы представить в виде диаграммы стандартизированные значения, и сразу понять, сколько и как много в нашей выборке наблюдений, превышающих допустимый предел (например, лежащих далее, чем 3 «сигмы» от нулевого значения):\n\ndf$z_age &lt;- scale(df$age)\nhist(df$z_age)\n\n\n\n\n\n\n\n\nДавайте посмотрим на описательные статистики:\n\nsummary(df$z_age)\n\n       V1         \n Min.   :-2.2644  \n 1st Qu.:-0.7549  \n Median :-0.1374  \n Mean   : 0.0000  \n 3rd Qu.: 0.7546  \n Max.   : 3.2247  \n NA's   :26       \n\n\nМы видим, что у нас нет маленьких значений за пределами «-3», но есть некоторые значения, превышающие «+3).\nМы можем посмотреть номера (строки) этих наблюдений:\n\nwhich(df$z_age &gt; 3.0)\n\n[1] 562 593 872\n\n\nТаких значений три - 562, 593, 872. Это серьезные долгожители:\n\ndf[c(562,593,872),]$age\n\n[1] 91 89 91\nattr(,\"label\")\n[1] \"Возраст\"\nattr(,\"format.spss\")\n[1] \"F8.0\"\nattr(,\"display_width\")\n[1] 10\n\n\nВопрос о том, как выявлять аномальные значения и что с ними делать, не является тривиальным. Помимо графических методов, есть и специальные статистические методы, позволяющие вычленить наблюдения, содержащие нетипичные значения.\n\n9.2.3.1 Фильтр Хэмпеля\nТак, еще один метод, известный как фильтр Хэмпеля, рассматривает в качестве выбросов значения, попадающих в интервал (\\(I\\)), образуемый медианой плюс или минус три абсолютных отклонения от медианы (median absolute, MAD):\n\\[I = [median - 3 \\cdot MAD; median + 3 \\cdot MAD]\\] где \\(MAD\\) определяется как:\n\\(MAD = median(|X_i - \\tilde{X}|)\\)\nДавайте определим нижнюю и верхнюю границы фильтра и отберем наблюдения, которые не попадают в указанный диапазон:\n\nlower_bound &lt;- median(df$age, na.rm = T) - 3 * mad(df$age, na.rm=T, constant = 1)\nlower_bound\n\n[1] 9\n\n\n\nupper_bound &lt;- median(df$age, na.rm = T) + 3 * mad(df$age, na.rm=T, constant = 1)\nupper_bound\n\n[1] 75\n\n\n\noutlier_ind &lt;- which(df$age &lt; lower_bound | df$age &gt; upper_bound)\noutlier_ind\n\n [1]  38 421 462 503 525 529 556 562 583 584 593 601 809 866 872\n\n\nЛегко увидеть, что наблюдений гораздо больше, чем было выявлено с помощью z-значений, что указывает на то, что фильтр Хэмпеля является довольно консервативным подходом.\n\n\n9.2.3.2 Статистические тесты для выявления аномалий\nКроме графических методов и механического отбора, нетипичные наблюдения можно выявлять и с помощью специальных тестов, например, таких как:\n\nТест Груббса\nТест Диксона\nТест Роснера\n\nЭти три статистических теста являются частью более формальных техник нахождения выбросов, так как они основаны на вычислении тестовой статистики, которая сопоставляется с табличными критическими значениями, основанными на объеме выборки и определяемого доверительного уровня).\n\n9.2.3.2.1 Grubbs’s test\nТест Груббса позволяет сделать вывод о том, являются ли максимальное и минимальное значение выбросами.\n\\(H_0\\): максимальное значение не является аномальным. \\(H_1\\): максимальное значение является аномальным.\nАналогичным образом формулируются гипотезы о минимальных значениях:\n\\(H_0\\): минимальное значение не является аномальным. \\(H_1\\): минимальное значение является аномальным.\nКак и для любого статистического теста, мы решаем, если p-значение меньше выбранного уровня значимости (чаще всего α=0,05) нулевая гипотеза отклоняется и мы делаем вывод, о том, что значения являются выбросами.\nЭтот тест не подходит для выборок, в которых содержится менее 6 наблюдений.\nЧтобы выполнить тест Груббса в R, мы будем использовать функцию grubbs.test() из библиотеки {outliers}:\n\n# install.packages(\"outliers\")\nlibrary(outliers)\ntest &lt;- grubbs.test(df$age, type=10)\ntest\n\n\n    Grubbs test for one outlier\n\ndata:  df$age\nG = 3.22471, U = 0.98825, p-value = 0.5426\nalternative hypothesis: highest value 91 is an outlier\n\n\nТест «говорит» нам о том, что максимальное значение не является выбросом.\n Самостоятельное задание:\nПроверьте, является ли выбросом минимальное значение. Для этого в настройках установите opposite = TRUE. Проверьте гипотезу о принадлежности к выбросам обоих - минимального и максимального значений. Поменяйте настройки на type=11.\n\n\n9.2.3.2.2 Тест Диксона\nПодобно тесту Груббса, тест Диксона используется для определения того, является ли минимальное или максимальное значение выбросом. Если у нас есть подозрение относительно других значений, мы должны тестировать их индивидуально.\nЕще одно ограничение: этот тест хорошо работает только на маленьких выборках (n≤25).\nЧтобы попробовать этот метод на наших данных, мы должны сократить нашу выборку и использовать соответствующую функцию из той же библиотеки:\n\nsubdat &lt;- df[1:20, ]\ntest &lt;- dixon.test(subdat$age)\ntest\n\n\n    Dixon test for outliers\n\ndata:  subdat$age\nQ = 0.31579, p-value = 0.5913\nalternative hypothesis: lowest value 22 is an outlier\n\n\n\n\n9.2.3.2.3 Тест Роснера\nК теста Роснера есть несколько преимуществ: - его можно использовать для вычленения нескольких выбросов за один раз - позволяет решать проблемы маскировки, когда один выброс, близкий по значению к другому выбросу, остается незамеченным - подходит для больших выборок. В R функцияrosnerTest()находится в библиотеке{EnvStats}`. Функция требует по меньшей мере двух аргументов: ссылки на данные и количество выбросов (по умолчанию 3).\nФормула теста следующая: Наблюдаемые значения сортируются от меньшего к большему, далее определяется максимальное значение выбросов (не больше 10), и затем считается серия статистических тестов, путем последовательного удаления значений (высоких или низких), которые максимально удалены от среднего значения и пересчета стандартных значений по формуле:\n\\[\\large R_{i+1} = \\frac{|x^{(i)} - \\bar x^{(i)}|}{s^{(i)}}\\] Как только все статистики $ R_1…R_k$ посчитаны, начинается проверка гипотез путем сопоставления с критическими значениями для определенного уровня значимости.\nПопробуем провести этот тест на наших данных:\n\n#install.packages(\"EnvStats\")\nlibrary(EnvStats)\ntest &lt;- rosnerTest(df$age,\n  k = 3\n)\ntest\n\n\nResults of Outlier Test\n-------------------------\n\nTest Method:                     Rosner's Test for Outliers\n\nHypothesized Distribution:       Normal\n\nData:                            df$age\n\nNumber NA/NaN/Inf's Removed:     26\n\nSample Size:                     887\n\nTest Statistics:                 R.1 = 3.224713\n                                 R.2 = 3.245654\n                                 R.3 = 3.128295\n\nTest Statistic Parameter:        k = 3\n\nAlternative Hypothesis:          Up to 3 observations are not\n                                 from the same Distribution.\n\nType I Error:                    5%\n\nNumber of Outliers Detected:     0\n\n  i   Mean.i     SD.i Value Obs.Num    R.i+1 lambda.i+1 Outlier\n1 0 44.00225 14.57424    91     562 3.224713   4.010252   FALSE\n2 1 43.94921 14.49655    91     872 3.245654   4.009971   FALSE\n3 2 43.89605 14.41806    89     593 3.128295   4.009690   FALSE\n\n\nВидим, что результаты также схожи с теми, что мы получили в ходе анализа стандартизированных значений, что неудивительно, учитывая сходство статистических процедур.\n\n\n\n\n9.2.4 Проверка на нормальность\nПодчиняются ли анализируемые количественные переменные закону нормального распределения вероятностей? Очень многие статистические методы предполагают положительный ответ на этот вопрос, и поэтому проверка исследуемых переменных на нормальность распределения является важной составной частью разведочного анализа данных.\nКак известно, кривая нормального распределения имеет красивый «колоколообразный вид» и описывается формулой функции плотности вероятности (probability density function, PDF):\n\\[f(x) = \\frac{e^{-(x - \\mu)^{2}/(2\\sigma^{2}) }} {\\sigma\\sqrt{2\\pi}}\\]\n\n\n\n\n\n\n\n\n\nНапример, мы желаем проверить гипотезу о равенстве средних значений в двух независимых выборках. Для этой цели подходит критерий Стьюдента. Но применение критерия Стьюдента обосновано, только если данные подчиняются нормальному распределению. Поэтому перед применением критерия необходимо проверить гипотезу о нормальности исходных данных. Или проверка остатков линейной регрессии на нормальность — позволяет проверить, соответствует ли применяемая модель регрессии исходным данным.\nНормальное распределение естественным образом возникает практически везде, где речь идет об измерении с ошибками. Более того, в силу центральной предельной теоремы, распределение многих выборочных величин (например, выборочного среднего) при достаточно больших объемах выборки хорошо аппроксимируется нормальным распределением вне зависимости от того, какое распределение было у выборки исходно.\nПроверяя условие нормальности распределения данных, необходимо, однако, хорошо представлять себе, в каких случаях его выполнение является критическим для применения конкретного статистического метода. Так, например, метод главных компонент (Principle Components Analysis, PCA) не требует, чтобы данные были распределены нормально. Линейная регрессия (Linear Regression) хотя и предполагает нормальность распределения зависимой переменной, является достаточно робастным методом при незначительных отклонениях от этого условия. В то же время для успешного применения дискриминантного анализа (Discriminant Analysis) нормальность распределениях признаков в каждой группе классифицируемых объектов - условие обязательное (Мастицкий, 2012).\nПроверку выборки на нормальность можно производить несколькими путями.\n\nБольшое распространение получили графические методы – анализ распределения с помощью гистограммы, диаграммы плотности, визуально показывающие, насколько велики отклонения от нормальности.\n\nМы уже строили для наших данных квантиль-квантиль график, гистограмму и ящичную диаграмму. Пожалуй, единственный график, который мы еще не делали - график плотности.\n\n ggplot(df, aes(x=age)) + \n  geom_density(fill=\"lightblue\")+\n  theme_bw()\n\n\n\n\n\n\n\n\n\nМожно использовать и данные описательных статистик, помня как в нормальном распределении соотносятся среднее, мода, медиана, какими должны быть асимметрия и эксцесс, выполняется ли «правило 3-х сигм». Обычно обращают внимание на показатели асимметрии и эксцесса, анализируют их абсолютные значения и сравнивают их со стандартными ошибками. Выше мы пробовали функцию describe() из библиотеки psych. Еще один хороший вариант - функция Desc() из библиотеки DescTools:\n\n\nlibrary(DescTools)\nDesc(df$age, plotit = TRUE)\n\n------------------------------------------------------------------------------ \ndf$age (numeric) :\n  Возраст\n\n\n  length      n    NAs  unique     0s   mean  meanCI'\n     913    887     26      74      0  44.00   43.04\n          97.2%   2.8%           0.0%          44.96\n                                                    \n     .05    .10    .25  median    .75    .90     .95\n   22.00  26.00  33.00   42.00  55.00  63.00   68.00\n                                                    \n   range     sd  vcoef     mad    IQR   skew    kurt\n   80.00  14.57   0.33   16.31  22.00   0.32   -0.39\n                                                    \nlowest : 11.0, 13.0, 14.0, 15.0 (2), 16.0 (6)\nhighest: 82.0 (2), 85.0, 86.0, 89.0, 91.0 (2)\n\n' 95%-CI (classic)\n\n\n\n\n\n\n\n\n\nОтдельно можно посчитать показатели асимметрии и эксцесса вместе с доверительными интервалами. У нормального распределения они должны быть близкими к нулю.\n \nАсимметрия:\n\nSkew(df$age, na.rm=TRUE, conf.level = 0.95, ci.type = \"classic\")\n\n  skewness     lwr.ci     upr.ci \n 0.3166113 -0.1603833  0.1603833 \n\n\nЭксцесс:\n\nKurt(df$age, na.rm=TRUE, method=2, conf.level = 0.95, ci.type = \"classic\")\n\n  kurtosis     lwr.ci     upr.ci \n        NA -0.3169093  0.3169093 \n\n\n\nособая группа методов — критерии нормальности. Их существует множество - по меньшей мере 15. Подробные материалы про все критерии с формулами и нюансами интерпретации можно посмотреть вот здесь\n\nВ R реализованы практически все имеющиеся тесты на нормальность — либо в виде стандарных функций, либо в виде функций, входящих в состав отдельных пакетов. Примером базовой функции является shapiro.test(), при помощи которой можно выполнить широко используемый тест Шапиро-Уилка\n\n9.2.4.1 Тест Шапиро-Уилка\nТест Шапиро-Уилка был впервые опубликован в 1965 году Самюэлем Санфордом Шапиро и Мартином Уилком.\n\\[W=\\frac{(\\Sigma^n_{i=1}a_ix_{(i)})^2}{\\Sigma^n_{i=1}(x_i-\\bar{x})^2}\\] где:\n\\(x_i\\) – упорядоченные значения анализируемой переменной \\(a_i\\) – константы, созданные на основе ковариаций, дисперсий и средних значений по выборке (размера \\(n\\)) из нормального распределения (обычно берутся из таблиц).\nСчитается одним из лучших и наиболее мощных тестов.\n\nshapiro.test(df$age)\n\n\n    Shapiro-Wilk normality test\n\ndata:  df$age\nW = 0.98589, p-value = 1.545e-07\n\n\nОсновные классические критерии проверки на нормальность собраны в пакете nortest. Пакет можно установить с CRAN при помощи вызова функции install.packages():\n\ninstall.packages(\"nortest\")\n\n\n\n9.2.4.2 Тест Колмогорова-Смирнова\nнаверное, одним из самых известных является тест Колмогорова-Смирнова, носящий имена российских математиков Андрея Николаевича Колмогорова и Николая Васильевича Смирнова.\nСтатистика \\(D\\) Колмогорова-Смирнова вычисляется как максимум модуля разности между эмпирической и теоретической функциями распределения. Эта статистика критерия согласия используется для проверки гипотезы о том, что наблюдения взяты из указанного распределения:\n\\[D = \\max_{1 \\le i \\le N} \\left( F(Y_{i}) -\n               \\frac{i-1} {N}, \\frac{i}{N} - F(Y_{i}) \\right)\\] где \\(F\\) является теоретическим кумулятивным распределением, которое должно обязательно принадлежать к семейству непрерывных распределений. Нулевая гипотеза отклоняется в случае, если тестовая статистика, \\(D\\), превышает критическое значение.\nКогда данные сравниваются с теоретическим нормальным распределением, используется поправка Лиллиефорса.\n\nnortest::lillie.test(df$age)\n\n\n    Lilliefors (Kolmogorov-Smirnov) normality test\n\ndata:  df$age\nD = 0.063661, p-value = 4.699e-09\n\n\n\nplot(ecdf(scale(df$age)), col=\"red\", main=\"Эмпирическая и теоретическая кумулятивные функции\")\ncurve(pnorm, from = -10, to = 10, add = TRUE, col=\"blue\")\n\n\n\n\n\n\n\n\n\n\n9.2.4.3 Тест Андерсона-Дарлинга\nТест Андерсона-Дарлинга (Stephens, 1974) используется для тестирования гипотезы о том, что выборочные данные имеют специфическое распределение. Это модификация теста Колмогорова-Смирнова (K-S test), в которой больший вес придается крайним значениям (хвостам), по сравнению с оригинальным тестом\nФормула для вычисления критерия такова:\n\\[A^{2} = -N - S\\]\n\\[S = \\sum_{i=1}^{N}\\frac{(2i - 1)}{N}[\\ln{F(Y_{i})} + \\ln{(1 - F(Y_{N+1-i}))}]\\]\nгде \\(F\\) - это кумулятивная функция распределения, показывающая вероятность того, что целевое значение меньше указанного значения либо равно ему.\nВ библиотеке nortest тест Андерсона-Дарлинга реализован в функции ad.test():\n\nnortest::ad.test(df$age)\n\n\n    Anderson-Darling normality test\n\ndata:  df$age\nA = 3.7285, p-value = 2.644e-09\n\n\n\n\n9.2.4.4 Тест Крамера-фон-Мизеса\nТест Крамера-фон-Мизеса является еще одной альтернативой тесту Колмогорова-Смирнова и представляет собой комплексный тест для проверки нормальности. Он использует сумму квадратов различий между наблюдаемыми и ожидаемыми кумулятивными пропорциями в качестве тестовой статистики.\nТест имеет следующую формулу:\n\\[\\begin{align}\nW_n^2:=n\\int(F_n(x)-F_0(x))^2\\,\\mathrm{d}F_0(x).\n\\end{align}\\]\nЕсли \\(H_0: F=F_0\\) справедливо, то \\(W^2_n\\) являются маленькими значениями. Соответственно, отвержение гипотезы происходит при больших значениях \\(W^2_n\\). Считается, что тест Крамера-фон-Мизеса более мощный, по сравнению с классическим тестом Колмогорова-Смирнова.\nВ библиотеке nortest для теста Крамера-фон-Мизеса используется функция cvm.test():\n\nnortest::cvm.test(df$age)\n\n\n    Cramer-von Mises normality test\n\ndata:  df$age\nW = 0.68776, p-value = 7.727e-08",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Разведочный анализ данных в R</span>"
    ]
  },
  {
    "objectID": "ExploratoryDataAnalysis.html#анализ-категориальных-переменных",
    "href": "ExploratoryDataAnalysis.html#анализ-категориальных-переменных",
    "title": "9  Разведочный анализ данных в R",
    "section": "9.3 Анализ категориальных переменных",
    "text": "9.3 Анализ категориальных переменных\nРассмотрев возможности разведочного анализа количественных переменных, перейдем к категориальным данным, представленным в номинальных и порядковых шкалах\n\n9.3.1 Описание таблиц без их представления в тексте\nВо многих случаях в ходе анализа нам нужны просто цифры, ведь не все результаты представляются в виде таблиц и графиков, что-то просто описывается словами, поэтому иногда проще и быстрее использовать базовый код, без премудростей.\nПредставим ситуацию, что мы описываем нашу выборочную совокупность и хотим представить информацию по количеству опрошенных по разным регионам исследования.\nИтак, если нам нужны простые частоты, не проценты, одним из простых решений будет функция из базового R table ().\nНапример, посмотрим распределение по регионам, предварительно переведя все переменные факторные, поскольку их большинство:\n\ndf &lt;- haven::as_factor(df)\ntable(df$Region)\n\n\n  Алтайский край Республика Алтай  Республика Тыва         Монголия \n             274              446              192                1 \n\n\nЕсли нам нужны не абсолютные, а относительные частоты по отдельным вопросам, для которых мы не собираемся делать какие-то таблицы или графики (то есть эти данные нужны только для описания), то для этой цели можно использовать , базовую функцию prop.table.\nНапример, мы хотим узнать пропорции по полу во всех регионах исследования (умножим на 100, чтобы получить значения в процентах, а не долях:\n\nprop.table(table(df$V1))*100\n\n\n Мужской  Женский \n32.07127 67.92873 \n\n\nС помощью этих же функций можно создать и двумерные таблицы:\n\nprop.table(table(df$V1, df$Region), margin = 2)*100\n\n         \n          Алтайский край Республика Алтай Республика Тыва  Монголия\n  Мужской       26.66667         38.67277        24.73684   0.00000\n  Женский       73.33333         61.32723        75.26316 100.00000\n\n\nБолее интересный вариант предлагает функция flat_table (переводится как “плоская таблица”) из библиотеки sjmisc.\n\nsjmisc::flat_table(df, V1, margin = \"cell\")\n\nV1 Мужской Женский\n                  \n     32.07   67.93\n\n\nМы видим, что в наших исследованиях приняло участие гораздо больше женщин (почти 68%), чем мужчин (35%).\nЕсли нужна двумерная таблица, функция flat_table также подойдет (так же как и функции prop.table, sjt.xtab и другие, запомним, что в R всегда можно сделать одно и то же разными путями, здесь дело вкуса):\n\ntable&lt;-sjmisc::flat_table(df, Region, V1, margin = \"row\")# df - наша база данных, Region V1 - переменные для строк и столбцов, margin = \"row\"  - процент по строке\ntable\n\n                 V1 Мужской Женский\nRegion                             \nАлтайский край        26.67   73.33\nРеспублика Алтай      38.67   61.33\nРеспублика Тыва       24.74   75.26\nМонголия               0.00  100.00\n\n\nВыглядит не очень с точки зрения оформления, зато мы быстро получили результаты и можем их описать. Видим, что женщины превалируют во всех регионах, из доля составляет более 60%, в Республике Тыва - 75%.\nБолее того, мы можем сохранить эту таблицу в формате датафрейма и потом использовать в других приложениях:\n\ntable&lt;-tidyr::as_tibble(table)\ntable\n\n# A tibble: 8 × 3\n  Region           V1       Freq\n  &lt;fct&gt;            &lt;fct&gt;   &lt;dbl&gt;\n1 Алтайский край   Мужской  26.7\n2 Республика Алтай Мужской  38.7\n3 Республика Тыва  Мужской  24.7\n4 Монголия         Мужской   0  \n5 Алтайский край   Женский  73.3\n6 Республика Алтай Женский  61.3\n7 Республика Тыва  Женский  75.3\n8 Монголия         Женский 100  \n\n\nЕсли мы посмотрим, то получилось не совсем то, что нам бы хотелось: у нас получилась таблица в «длинном формате», вместо широкого. К счастью это можно быстро исправить с помощью уже знакомой нам функции pivot_wider()из библиотеки tidyr, являющейся частью экосистемы tidyverse.\n\nlibrary(tidyr)\ntable&lt;-table %&gt;% \n  pivot_wider(names_from = V1, values_from = Freq)\ntable\n\n# A tibble: 4 × 3\n  Region           Мужской Женский\n  &lt;fct&gt;              &lt;dbl&gt;   &lt;dbl&gt;\n1 Алтайский край      26.7    73.3\n2 Республика Алтай    38.7    61.3\n3 Республика Тыва     24.7    75.3\n4 Монголия             0     100  \n\n\nЕще нам постоянно мешает это единственное наблюдение из Монголии. Давайте его уберем и пересчитаем все заново.\nДля начала отфильтруем переменную Region так, чтобы в нее входили все регионы, кроме Монголии:\n\nlibrary(dplyr)\n\n\nПрисоединяю пакет: 'dplyr'\n\n\nСледующий объект скрыт от 'package:kableExtra':\n\n    group_rows\n\n\nСледующие объекты скрыты от 'package:stats':\n\n    filter, lag\n\n\nСледующие объекты скрыты от 'package:base':\n\n    intersect, setdiff, setequal, union\n\ndf&lt;-df %&gt;% \n  filter(Region!=\"Монголия\")\n\nПопробуем сделать простую таблицу:\n\ntable(df$Region, df$V1)\n\n                  \n                   Мужской Женский\n  Алтайский край        72     198\n  Республика Алтай     169     268\n  Республика Тыва       47     143\n  Монголия               0       0\n\n\nКак видим, наблюдение мы удалили, но метка (уровень факторной переменной) осталась, и нам нужно его убрать. Сделать это можно с помощью функции droplevels. Удалим уровень и сделаем новую таблицу\n\ndf$Region&lt;-droplevels(df$Region)\nsjmisc::flat_table(df, Region, V1, margin = \"row\")\n\n                 V1 Мужской Женский\nRegion                             \nАлтайский край        26.67   73.33\nРеспублика Алтай      38.67   61.33\nРеспублика Тыва       24.74   75.26\n\n\nВсе получилось!\nМежду тем, очевидно, что для хорошей статьи (диссертации, отчета об исследовании) описания результатов частотного анализа недостаточно, требуется представлять результаты комплексно, сразу по нескольким переменным, часто с учетом группировки, и приводить доказательства значимости имеющихся различий на основе применения статистических методов.\n\n\n9.3.2 Создание таблиц по нескольким переменным: возможности библиотек gtsummary и flextable\n\nflextable – чудо-библиотека от Дэвида Гоэля - француза и сотрудника ArData, созданная специально для работы с таблицами и улучшения их отображения в различных форматах, в частности в Word и Power Point\ngtsummary – библиотека для создания эффектных таблиц с описательными статистиками для научных публикаций\n\nПредположим, что для нашей будущей статьи, которую мы готовим по результатам исследования, мы хотим создать большую таблицу, содержащую распределения сразу по нескольким переменным, описывающим все важные демографические и социальные характеристики, такие как пол, возраст по группам, социальный статус, в том числе - с учетом региональных различий. Желательно также посчитать, являются ли эти различия значимыми, используя для этого критерий \\(\\chi^2\\) Пирсона.\nБиблиотека gtsummary была создана специально для того, чтобы быстро создавать гибкие с точки зрения форматирования таблицы с описательными статистиками и результатами регрессионного анализа, оформленные по стандартам для научных публикаций.\nНастоятельно рекомендуется посетить сайт проекта и подробно ознакомиться с возможностями данной библиотеки. https://www.danieldsjoberg.com/gtsummary/index.html\nДля начала создадим общую таблицу, где в строках будут располагаться данные по возрасту, полу, региону проживания, социальному статусу, а также наличию гражданства другой страны.\n\nlibrary(dplyr)\n#install.packages(\"gtsummary\") - убрать решетку и запустить строку\nlibrary(gtsummary)\n#вспоминаем урок по dplyr\ntable&lt;-df %&gt;% \n  select(Region, V1, age_cats3, V10, V6)  #отберем нужные переменные в отдельный сет и сохраним его под именем table\n# создадим таблицу\ntable %&gt;% \n  tbl_summary(missing=\"no\") #функция tbl_summary позволяет создать комплексные таблицы\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nN = 9121\n\n\n\n\nRegion\n\n\n\n\n    Алтайский край\n274 (30%)\n\n\n    Республика Алтай\n446 (49%)\n\n\n    Республика Тыва\n192 (21%)\n\n\nПол\n\n\n\n\n    Мужской\n288 (32%)\n\n\n    Женский\n609 (68%)\n\n\nВозраст\n\n\n\n\n    До 30 лет\n160 (18%)\n\n\n    31-49 лет\n423 (48%)\n\n\n    50 лет и старше\n303 (34%)\n\n\nКаков уровень материального достатка Вашей семьи?\n\n\n\n\n    Живем очень бедно, фактически голодаем, денег иногда не хватает даже на питание, имевшиеся ранее накопления кончились\n13 (1.5%)\n\n\n    Живем бедно, денег хватает только на скромное питание, оплату коммунальных услуг,\n51 (5.7%)\n\n\n    Живем средне, денег хватает на питание, недорогую одежду, крайне необходимые вещи и оплату коммунальных услуг,\n620 (69%)\n\n\n    Живем достаточно обеспеченно, (есть денежные накопления и возможность покупать практически все необходимое для жизни)\n198 (22%)\n\n\n    Очень хорошо, богато (не отказываем себе ни в чем, денежные накопления постоянно прирастают)\n14 (1.6%)\n\n\nКакой у Вас САМЫЙ ВЫСОКИЙ уровень образования, по которому Вы получили аттестат, свидетельство, диплом?\n\n\n\n\n    Основное общее образование (9 классов) или меньше\n52 (5.8%)\n\n\n    Среднее (полное) общее образование\n162 (18%)\n\n\n    Начальное или среднее профессиональное образование\n294 (33%)\n\n\n    Высшее образование (диплом специалиста, бакалавра или магистра)\n382 (42%)\n\n\n    Аспирантура, ординатура, ученая степень кандидата или доктора наук\n9 (1.0%)\n\n\n    Другое\n1 (0.1%)\n\n\n\n1 n (%)\n\n\n\n\n\n\n\n\nВ принципе, очень неплохо. Добавим группировку по региону и поменяем заголовок у переменных с “Characteristic” на “Характеристику”:\n\ntable %&gt;% \n  tbl_summary(by=Region, missing=\"no\") %&gt;%#by=V004 - так мы обозначаем группирующую переменную\n  modify_header(#функция, позволяющая изменить заголовок\n    update = list(\n      label ~ \"Характеристика\" #\n    )\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\nХарактеристика\nАлтайский край, N = 2741\nРеспублика Алтай, N = 4461\nРеспублика Тыва, N = 1921\n\n\n\n\nПол\n\n\n\n\n\n\n\n\n    Мужской\n72 (27%)\n169 (39%)\n47 (25%)\n\n\n    Женский\n198 (73%)\n268 (61%)\n143 (75%)\n\n\nВозраст\n\n\n\n\n\n\n\n\n    До 30 лет\n35 (13%)\n75 (17%)\n50 (27%)\n\n\n    31-49 лет\n114 (43%)\n215 (49%)\n94 (51%)\n\n\n    50 лет и старше\n115 (44%)\n147 (34%)\n41 (22%)\n\n\nКаков уровень материального достатка Вашей семьи?\n\n\n\n\n\n\n\n\n    Живем очень бедно, фактически голодаем, денег иногда не хватает даже на питание, имевшиеся ранее накопления кончились\n4 (1.5%)\n7 (1.6%)\n2 (1.1%)\n\n\n    Живем бедно, денег хватает только на скромное питание, оплату коммунальных услуг,\n10 (3.7%)\n34 (7.8%)\n7 (3.7%)\n\n\n    Живем средне, денег хватает на питание, недорогую одежду, крайне необходимые вещи и оплату коммунальных услуг,\n193 (71%)\n304 (70%)\n123 (65%)\n\n\n    Живем достаточно обеспеченно, (есть денежные накопления и возможность покупать практически все необходимое для жизни)\n57 (21%)\n86 (20%)\n55 (29%)\n\n\n    Очень хорошо, богато (не отказываем себе ни в чем, денежные накопления постоянно прирастают)\n6 (2.2%)\n5 (1.1%)\n3 (1.6%)\n\n\nКакой у Вас САМЫЙ ВЫСОКИЙ уровень образования, по которому Вы получили аттестат, свидетельство, диплом?\n\n\n\n\n\n\n\n\n    Основное общее образование (9 классов) или меньше\n23 (8.4%)\n24 (5.5%)\n5 (2.6%)\n\n\n    Среднее (полное) общее образование\n37 (14%)\n85 (19%)\n40 (21%)\n\n\n    Начальное или среднее профессиональное образование\n80 (29%)\n173 (40%)\n41 (22%)\n\n\n    Высшее образование (диплом специалиста, бакалавра или магистра)\n125 (46%)\n155 (35%)\n102 (54%)\n\n\n    Аспирантура, ординатура, ученая степень кандидата или доктора наук\n8 (2.9%)\n0 (0%)\n1 (0.5%)\n\n\n    Другое\n0 (0%)\n0 (0%)\n1 (0.5%)\n\n\n\n1 n (%)\n\n\n\n\n\n\n\n\nПрочитать подробнее о функции tbl_summary, ее атрибутах, с подробным разбором примеров и возможностей изменения таблицы: http://www.danieldsjoberg.com/gtsummary/articles/tbl_summary.html\nМожно сделать и простую двумерную таблицу:\n\n table %&gt;%\n  tbl_cross(row = V1, col = age_cats3, percent = \"cell\", missing=\"no\", ) %&gt;%\n  add_p(test=\"chisq.test\") %&gt;% #добавляем статистику хи-квадрат\n  modify_header(#функция, позволяющая изменить заголовок\n    update = list(\n      label ~ \"**Характеристика**\" #\n    )\n  ) %&gt;% \n  modify_caption(\"**Взаимосвязь пола и возраста** (N = {N})\") #меняем заголовок на нужный, причем заголовок вставляем количество опрошенных\n\nFALSE observations with missing data have been removed.\n\n\n\n\n\n\nВзаимосвязь пола и возраста (N = 875)\n\n\n\n\n\n\n\n\n\n\nХарактеристика\nВозраст\nTotal\np-value1\n\n\nДо 30 лет\n31-49 лет\n50 лет и старше\n\n\n\n\nПол\n\n\n\n\n\n\n\n\n0.5\n\n\n    Мужской\n53 (6.1%)\n127 (15%)\n103 (12%)\n283 (32%)\n\n\n\n\n    Женский\n106 (12%)\n291 (33%)\n195 (22%)\n592 (68%)\n\n\n\n\nTotal\n159 (18%)\n418 (48%)\n298 (34%)\n875 (100%)\n\n\n\n\n\n1 Pearson’s Chi-squared test\n\n\n\n\n\n\n\n\n\n\n9.3.3 Пример анализа вопроса с множественными ответами\nДля выполнения данного задания нам понадобится questionr - библиотека, позволяющая анализировать таблицы с множественными ответами.\nПрежде чем выполнить последующий код, установите пакет questionr на свой комьютер и запустите библиотеку:\n\n#install.packages(\"questionr\") - убрать решетку и запустить строку\nlibrary(questionr)\n\nУ нас в анкете был вопрос 9, в котором изучалось, чем владеет домохозяйство. Можно было выбрать несколько вариантов ответа, а также дать собственный вариант ответа - «Другое». Ответы были закодированы дихотомическим способом, выбор кодировался как 1, а его отсутствие - как 0.\nКак в других программах статистической обработки, в R нам потребуется сделать два шага для того, чтобы проанализировать вопрос с множественным выбором: - создать набор данных, в который объединяются отдельные подвопросы; - сделать таблицу, которая может быть как одномерной, так и многомерной.\nДавайте объединим все подвопросы вопроса V9 в один набор и сохраним его под отдельным именем - V9. Воспользуемся знакомыми нам функциями select() - для отбора переменных и contains() - отбора переменных, имена которых содержат определенный паттерн:\n\nlibrary(dplyr)\nV9&lt;-df %&gt;% \n  select(contains(\"V9\")) %&gt;% \n  select_if(is.factor)#дополнительный select нужен, чтобы убрать текстовую переменную «другое»\n\nДалее, создадим таблицу и сохраним ее в качестве отдельного датафрейма.\n\nlibrary(questionr)\nlibrary(dplyr)\nV9tab&lt;-V9 %&gt;% \nmulti.table(true.codes=list(\"да\"), freq=TRUE) %&gt;% \n    as.data.frame() %&gt;% \n  rename(Pct=`%multi`) %&gt;% \n  arrange(desc(Pct))\nV9tab\n\n        n  Pct\nV9_2  498 54.6\nV9_4  326 35.7\nV9_6  312 34.2\nV9_8  224 24.6\nV9_10 181 19.8\nV9_9  160 17.5\nV9_1  135 14.8\nV9_7   96 10.5\nV9_13  82  9.0\nV9_5   70  7.7\nV9_88  45  4.9\nV9_3   26  2.9\nV9_11  22  2.4\nV9_12   4  0.4\n\n\nДа, выглядит так себе, но зато все посчитано) сразу.\nПоясним, что true.codes=list(\"да\") - обозначаем вариант ответа, используемый для подсчета частот и процентов, freq=TRUE - вывод процентов, а не только частот.\nКак добавить метки вопросов в нашу таблицу? Извлечем метки вопросов по блоку V9 в отдельное место:\n\nlibrary(sjlabelled)\nV9labs&lt;-df %&gt;% \nselect(contains(\"V9\")) %&gt;% \n  select_if(is.factor) %&gt;% \n  get_label()\nV9labs\n\n                                                       V9_1 \n                                                      \"Сад\" \n                                                       V9_2 \n                                                   \"Огород\" \n                                                       V9_3 \n                                                   \"Пасека\" \n                                                       V9_4 \n                                                \"Транспорт\" \n                                                       V9_5 \n                             \"Сельскохозяйственная техника\" \n                                                       V9_6 \n                                     \"Крупный рогатый скот\" \n                                                       V9_7 \n                                                    \"Птицы\" \n                                                       V9_8 \n                  \"Козы, овцы, мелкий рогатый скот, свиньи\" \n                                                       V9_9 \n                                              \"Конь (кони)\" \n                                                      V9_10 \n\"Покосы, земельные участки для обработки (не приусадебные)\" \n                                                      V9_11 \n                                           \"Лесные участки\" \n                                                      V9_12 \n                                         \"Рыбное хозяйство\" \n                                                      V9_13 \n                                                 \"Пастбище\" \n                                                      V9_88 \n                                                   \"Другое\" \n\n\nПрисвоим имена в переменную n:\n\nV9tab$n&lt;-V9labs\nV9tab\n\n                                                              n  Pct\nV9_2                                                        Сад 54.6\nV9_4                                                     Огород 35.7\nV9_6                                                     Пасека 34.2\nV9_8                                                  Транспорт 24.6\nV9_10                              Сельскохозяйственная техника 19.8\nV9_9                                       Крупный рогатый скот 17.5\nV9_1                                                      Птицы 14.8\nV9_7                    Козы, овцы, мелкий рогатый скот, свиньи 10.5\nV9_13                                               Конь (кони)  9.0\nV9_5  Покосы, земельные участки для обработки (не приусадебные)  7.7\nV9_88                                            Лесные участки  4.9\nV9_3                                           Рыбное хозяйство  2.9\nV9_11                                                  Пастбище  2.4\nV9_12                                                    Другое  0.4\n\n\n\n\n9.3.4 Таблица сопряженности с множественными ответами\n\nV9Regiontab&lt;-cross.multi.table(V9, df$Region, true.codes=list(\"да\"), freq=TRUE)\nV9Regiontab&lt;-as_tibble(V9Regiontab)\nV9Regiontab$n&lt;-V9labs\nV9Regiontab&lt;-V9Regiontab %&gt;% \n  relocate(n)\n\n\n\n9.3.5 Графики для категориальных переменных\nОсновными графиками для категориальных переменных являются круговые и столбиковые диаграммы, а также мозаичные и ассоциативные графики, когда в анализе задействовано более двух переменных.\nДавайте создадим такие графики для переменных по возрасту. Красивые минималистичные графики с небольшим количеством кода и исправлений можно создать с помощью библиотеки ggpubr от Alboukadel Kassambara (биолог, автор книг по биоинформатике и биологии рака).\nСоздадим одномерную таблицу для возраста и двумерную для взаимосвязи между полом и возрастом.\n\nage&lt;- as.data.frame(sjmisc::flat_table(df, age_cats3, margin = \"cell\", digits = 1))\nage_sex&lt;-as.data.frame(sjmisc::flat_table(df, age_cats3, V1, margin = \"row\", digits = 1))\n\nСделаем простую столбиковую диаграмму по возрастным группам, в качестве «изюминки» добавим красивые шрифты.\nПрежде чем сделать сам график, установим шрифты, чтобы потом ими можно было пользоваться постоянно.\n\ninstall.packages(\"extrafont\")\nlibrary(extrafont)\nfont_import()#шрифты устанавливаются сразу все, это может занять некоторое время\n\nВ результате будут импортированы следующие шрифты:  После установки шрифты нужно загружать каждую сессию:\n\nloadfonts(device = \"win\", quiet = TRUE)\n\nТеперь займемся самим графиком. Разберем его структуру строчка за строчкой: - ggplot(data=age, aes(x=age_cats3, y=Freq)) + - создаем базовый график, где по оси x у нас будут возрастные категории, а по y - проценты - geom_bar(stat=\"identity\", fill=\"steelblue\", width = 0.6)+ - добавляем слой для столбиковой диаграммы, stat=\"identity\" - означает, что мы будем использовать данные «как есть», а не агрегировать на основе исходных, fill=\"steelblue\" - задаем цвет, width = 0.6 - устанавливаем ширину столбцов чуть меньше обычного, для красоты)) - geom_text(aes(label=scales::number(Freq,accuracy=0.1, decimal.mark = \",\")),  family = \"Ink Free\", vjust=0.5, hjust=-0.5, color=\"steelblue\", size=4)+ - тут много всего, эта часть кода отвечает за подписи к столбцам. label=number(Freq,accuracy=0.1, decimal.mark = \",\")) - устанавливаем подписи в числовом формате, запятую в качестве разделителя и округление до одного знака после запятой, family = \"Ink Free\", vjust=0.5, hjust=-0.5 - задаем шрифт Ink Free, делаем выравнивание, чтобы число было ровно посредине столбца и слегка выходило за его пределы (можно поэкспериментировать с этими настройками), color=\"steelblue\", size=4 - эти настройки отвечают за цвет и размер текста - coord_flip() - переворачиваем диаграмму в горизонтальную проекцию - theme_void()- устанавливаем тему, в которой есть только белый фон - expand_limits(y=c(0,50)) - раздвигаем границы по оси y, там, где проценты (это неважно, что при повороте диаграмма «ложится на бок» и оси вроде как меняются местами) - theme(axis.text.y = element_text(size = 10, family = \"Ink Free\") - устанавливаем размер и семейство шрифтов для подписей - категорий возраста - scale_x_discrete(limits=rev) - ну и, напоследок, меняем порядок категорий, от младшей возрастной группы к старшей\n\nlibrary(ggplot2)\nlibrary(scales)#нужна для того, чтобы отформатировать подпись\nggplot(data=age, aes(x=age_cats3, y=Freq)) +\n  geom_bar(stat=\"identity\", fill=\"steelblue\", width = 0.6)+\n  geom_text(aes(label=number(Freq,accuracy=0.1, decimal.mark = \",\")),  family = \"Ink Free\", vjust=0.5, hjust=-0.5, color=\"steelblue\", size=4)+\n  coord_flip()+\n  theme_void()+\n  expand_limits(y=c(0,50))+\n  theme(axis.text.y = element_text(size = 10, family = \"Ink Free\"))+\n  scale_x_discrete(limits=rev)\n\n\n\n\n\n\n\n\nДобавим данные по полу. В нашем коде почти ничего не поменялось, за исключением некоторых моментов: - fill=V1 - мы добавили в исходный график, чтобы сделать разбивку по полу - в geom_bar(stat=\"identity\", position=\"dodge\", width = 0.6) добавили position=\"dodge\" - чтобы столбцы располагались рядом друг с другом, такой же аргумент добавлен и в geom_text - в конце появилось две новых строки theme(legend.position=\"bottom\")+  theme(legend.title=element_blank()), они нужны для оформления легенды\n\nlibrary(ggplot2)\nlibrary(scales)#нужна для того, чтобы отформатировать подпись\nggplot(data=age_sex, aes(x=age_cats3, y=Freq, fill=V1)) +\n  geom_bar(stat=\"identity\", position=\"dodge\", width = 0.6)+\n  geom_text(aes(label=number(Freq,accuracy=0.1, decimal.mark = \",\")),  position = position_dodge(width = 0.6), hjust=-0.3, family = \"Ink Free\", size=4)+\n  coord_flip()+\n  theme_void()+\n  expand_limits(y=c(0,100))+\n  theme(axis.text.y = element_text(size = 10, family = \"Ink Free\"))+\n  scale_x_discrete(limits=rev)+\n  theme(legend.position=\"bottom\")+\n  theme(legend.title=element_blank())\n\n\n\n\n\n\n\n\nВ качестве альтернативы можно создать сгруппированные столбиковые диаграммы в библиотеке ggstatsplot:\n\nggstatsplot::ggbarstats(df, x = V1, y = age_cats3)\n\n\n\n\n\n\n\n\nсоздать круговую диаграмму:\n\nggplot(age, aes(x = \"\", y = Freq, fill = age_cats3)) +\n  geom_col(color = \"black\") +\n  geom_label(aes(label=number(Freq,accuracy=0.1, decimal.mark = \",\")), color = \"white\",\n            position = position_stack(vjust = 0.5),\n            show.legend = FALSE) +\n  guides(fill = guide_legend(title = \"Возраст\")) +\n  scale_fill_viridis_d() +#эта строка добавляет цветовую палитру\n  coord_polar(theta = \"y\") + \n  theme_void()\n\n\n\n\n\n\n\n\nБолее простым решением является создание круговой диаграммы с помощью функции ggpiestats из библиотеки ggstatsplot:\n\nggstatsplot::ggpiestats(df, age_cats3, legend.title = \"Возраст\")\n\n\n\n\n\n\n\n\nС помощью этой же функции можно создать серию круговых диаграмм:\n\nggstatsplot::ggpiestats(df, V1, age_cats3)\n\n\n\n\n\n\n\n\nПосмотреть отдельно хи-квадрат:\n\nchisq.test(df$V1, df$age_cats3)\n\n\n    Pearson's Chi-squared test\n\ndata:  df$V1 and df$age_cats3\nX-squared = 1.4769, df = 2, p-value = 0.4779\n\n\nСделаем график для вопросов с множественными ответами, по вопросу V9. В описаниях вариантов ответов есть длинные формулировки, которые будут не очень хорошо смотреться на графике, поэтому прежде, чем создавать график, давайте уберем все, что написано в скобках, так как это скорее не основная, а уточняющая информация.\nДля этого мы воспользуемся функцией gsub, в которую включим выражение, позволяющее отсечь текст, лежащий после знака (.\n\nV9tab$n&lt;-gsub(\"\\\\(.*\", \"\", V9tab$n)\n\nХотя в таблице значения отсортированы, на графике они все равно будут отображаться в том порядке, в котором представлены уровни факторной переменной. Поэтому, чтобы на графике у нас были отображены значения по убыванию (мы же не хотим, чтобы у нас получился хаос из 14 вариантов ответа), нам нужно отсортировать уровни, для чего нам потребуется библиотека forcats.\nИ поскольку ширина подписей, несмотря на то, что мы их сократили, будет довольно существенной, мы сделаем самые длинные подписи в две строки, что, в свою очередь, потребует работы с библиотекой stringr (раз это новые для нас библиотеки и мы про них не слышали, нужно их установить).\n\nlibrary(forcats)\n\n\nПрисоединяю пакет: 'forcats'\n\n\nСледующий объект скрыт от 'package:sjlabelled':\n\n    as_factor\n\nlibrary(stringr)\n#| fig-width: 200%\nV9tab %&gt;%\n  mutate(n = fct_reorder(n, Pct)) %&gt;% # переставим местами уровни\nggplot(aes(x=n, y=Pct, fill=n)) + # создадим типовой график\n  geom_bar(stat=\"identity\", width = 0.6)+  # добавим geom\n  geom_text(aes(label=number(Pct,accuracy=0.1, decimal.mark = \",\")), hjust=-0.3, family = \"Ink Free\", size=4)+   # поработаем с подписями данных\n  expand_limits(y=c(0,80))+# увеличим лимит оси \n  coord_flip()+  # перевернем график в горизонтальное положение\n  theme_void()+   # добавим минималистичную тему\n  theme(axis.text.y = element_text(size = 10, family = \"Ink Free\"))+    # установим шрифт для подписей\n  theme(legend.position=\"none\")+       # уберем легенду\n  scale_x_discrete(labels = function(x) str_wrap(x, width = 30))       # Сделаем длинные подписи в несколько строк",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Разведочный анализ данных в R</span>"
    ]
  },
  {
    "objectID": "ExploratoryDataAnalysis.html#самостоятельная-работа",
    "href": "ExploratoryDataAnalysis.html#самостоятельная-работа",
    "title": "9  Разведочный анализ данных в R",
    "section": "9.4 Самостоятельная работа",
    "text": "9.4 Самостоятельная работа\n\nПровести комплексную проверку на нормальность переменной Sepal.Length из набора `iris.\nПровести одномерный анализ по переменным V12, V13, V15. Сделать двумерный анализ по региону и возрасту.\nПроанализировать переменные с множественным выбором V14 и V16, также сделать двумерный анализ по региону. По всем видам анализа сделать таблицы и графики.\nПредставить все в виде отдельного документа - по желанию в каком формате.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Разведочный анализ данных в R</span>"
    ]
  },
  {
    "objectID": "lesson10.html",
    "href": "lesson10.html",
    "title": "10  Регрессионный анализ",
    "section": "",
    "text": "Раздел находится в разработке…",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Регрессионный анализ</span>"
    ]
  },
  {
    "objectID": "lesson12.html",
    "href": "lesson12.html",
    "title": "11  Моделировние структурными уравнениями в R",
    "section": "",
    "text": "Раздел находится в разработке…",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Моделировние структурными уравнениями в R</span>"
    ]
  },
  {
    "objectID": "lesson13.html",
    "href": "lesson13.html",
    "title": "12  Количественный анализ текстовых данных в Quanteda",
    "section": "",
    "text": "Раздел находится в разработке…",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Количественный анализ текстовых данных в Quanteda</span>"
    ]
  }
]
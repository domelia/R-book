---
title: "Типы и структуры данных"
execute:
  class-source: "numberLines"
callout-appearance: minimal
---

## Типы данных в R

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(webexercises)
```

*Тип данных* (встречается также термин «вид данных») — фундаментальное понятие теории программирования.

Тип данных определяет множество значений, набор операций, которые можно применять к таким значениям и способ реализации хранения значений и выполнения операций. Любые данные, которыми оперируют программы, относятся к определённым типам.

R может хранить и обрабатывать различные виды информации и типы данных:

-   **Логический (logical)** – TRUE, FALSE – ИСТИНА, ЛОЖЬ.

```{r dt1, echo=TRUE}
2 > 3
```

Мы можем присваивать логические значения в качестве значений переменных, используя полный или краткий вариант:

```{r, echo=TRUE, eval=F}
a <- TRUE
b <- FALSE
# Или
a <- T
b <- F
```

Логический тип данных может интерпретироваться как числовой. При такой интерпретации значение TRUE эквивалентно числу 1, а значение FALSE — числу 0.


Например:

```{r dt1_3, echo=TRUE}
TRUE + TRUE  # TRUE считается как 1
```

```{r dt1_4, echo=TRUE}
FALSE * 7 # FALSE принимается за 0
```

Или, вот еще интересный пример:

```{r dt1_5, echo=TRUE}
(2 < 3) + (1 == 2)
```

Почему получился именно такой результат?

2 \< 3 - TRUE, то есть 1

1 == 2 - FALSE, то есть 0

TRUE + FALSE = 1 + 0 = 1

-   **Числовой (numeric)** тип включает целые и дробные, положительные и отрицательные числа.

Например, проверим, принадлежит ли число -5,6 к типу `numeric`. Сделать это можно с помощью функции `is.numeric()`. 

Общая функция, с помощью которой проверяетс тип данных -- `class()`.

```{r dt3, echo=TRUE}
is.numeric(-5.6)
a <- -11
b <- 13.37
c <- 1/137
class(a)
class(b)
class(c)
```

С числовыми переменными мы можем совершать различные математические операции, например, сложение, вычитание, возведение в степень и другие.

Основные функции, которые могут встречаться в социальных исследованиях, приведены в таблице 
Вот таблица с базовыми математическими функциями R, отобранными для применения в анализе данных социальных исследований (описательная статистика, индексы, нормализация переменных).  

| Функция | Описание | Пример применения в социологических исследованиях |
|---------|----------|-------------------------------------|
| `abs(x)` | Абсолютное значение | Расчет отклонений от медианы в анализе дисперсии мнений |
| `min(...)`, `max(...)` | Минимум и максимум значений | Определение диапазона шкал (возраст, доход) в описательной статистике|
| `round(x, digits)` | Округление | Форматирование коэффициентов корреляции или p-value в отчетах |
| `sqrt(x)` | Квадратный корень | Нормализация в индексах уязвимости или стандартизация отклонений|
| `log(x, base)` | Логарифм | Трансформация скошенных распределений (доходы, миграционные потоки) |
| `exp(x)` | Экспонента | Обратная трансформация логарифмированных данных в статистических моделях  |


- Примеры: 
```{r dt3_1, echo=TRUE}
a <- -11
b <- 13.37
c <- 1/137
a + b * c
a^2 + sqrt(b) - c/5
```

-   **Целый, целочисленный (integer)** тип включает только целые числа, положительные и отрицательные.

Например, проверим, к какому принадлежит переменная, содержащая значение 28:

```{r dt4, echo=TRUE}
x <- 28
class(x)
#Проверим, является ли x целым числом
is.integer(x)
```
#Создадим переменную y

Иногда, для того, чтобы имплицитно привести число к целочисленному типу в конце добавляется буква L:
```{r dt4a, echo=TRUE} 
y<-25L #при вводе, для того, чтобы R понял, что число именно целое, добавляется буква L
#Проверим, является ли y целым числом
is.integer(y)
#Проверим, является ли y числовой переменной
is.numeric(y)
```

-   **Комплексные (complex)** числа и соответствующий тип – это уже абстрактная математика (числа состоящие из действительной (реальной) и мнимой части), например, $3+2i$. Нам они вряд ли пригодятся, но на всякий случай запомним.

```{r dt5, echo=TRUE}
z <- 1:2 + 1i*(8:9)
class(z)
```

-   **Текстовые, строковые (character)** данные, как уже понятно из названия, содержат "буквенные" значения, например: «Привет, мир!», «а», «4В»

```{r dt6, echo=TRUE}
color<-"Красный"
class(color)
is.character(color)
```

При вводе строковых данных возможны разные варианты написания, как с помощью двойных кавычек, так и одинарных. Главное, не использовать те и другие вместе, иначе будет ошибка.

Пример корректного употребления кавычек:

```{r dt6_1, echo=TRUE}
d <- "Hello"         # С помощью двойных кавычек 
e <- 'how are you?'  # С помощью одинарных кавычек
d
e
```

Однако, нельзя использовать и те, и другие сразу, будет ошибка:

```{r dt6_2, echo=TRUE, eval=FALSE}
f <- "Так работать не будет' 
```

Иногда вместо текста нет ничего, но это все равно будет строковая переменная (пустая строка):

```{r dt6_3, echo=TRUE}
h <- ""              # Это пустая строка!
```

С числовыми переменными мы можем совершать различные операции. Как насчет строковых переменных? К ним тоже можно применять разные функции, и их довольно много. Вот некоторые:

Посчитаем количество символов в строке:

```{r dt6_4, echo=TRUE}
g<-"Как упоительны в России вечера!"
nchar(g)
```

Если нам нужен какой-то определенный фрагмент текста, мы можем его «вытащить» оттуда:

```{r dt6_5, echo=TRUE}
g<-"Как упоительны в России вечера!"
substr(g, 4, 25) 
```

Довольно часто при анализе текстовых данных их нужно разделить на отдельные кусочки. В этом может помочь функция `strplit()`. В качестве аргументов этой функции указываются: переменная, содержащая текст, и символ, используемый для разделения, например, знак «пробела»:

```{r dt6_6, echo=TRUE}
g<-"Как упоительны в России вечера!"
strsplit(g, " ")   
```


-   **Факторные (factor)** переменные – могут быть строковыми и числовыми. Они использования для распределения значений по категориям или группам, которые, в случае порядкового измерения, могут быть разбиты на уровне. Этот тип объединяет номинальные и порядковые переменные, часто также называемые категориальными. Примеры: пол, семейный статус, цвет волос и т.д.
```{r dt7, echo=TRUE}
x <- c("single","married","married","single")
class(x)
```

- `factor ()` - функция, которая создает факторные переменные. Аргумент `levels` используется для обозначения уровней (порядка, если он нужен).

```{r dt8, echo=TRUE}
x <- factor(levels = c("Согласен", "И да, и нет", "Не согласен"))
class(x)
```

Функция `str()` дает больше информации о переменной, не только какого она типа, но сколько элементов содержит, какие в ней значения, уровни и т.д.

```{r dt8a, echo=T}
str(x)
```

`as.factor()` - данная функция превращает в факторный тип переменные другого типа, даже если они числовые или строковые.

```{r dt9, echo=TRUE}
colors<-c("red", "yellow", "green")
colors<-as.factor(colors)
str(colors)
```

Итак, мы познакомились с различными типами данных в R. С ними мы будем сталкиваться постоянно, поэтому нужно уметь не только корректно определять тип переменной, но и понимать, как происходит конверсия типов, каковы требования различных методов. Например, в сравнительном анализе часто используется некоторая группирующая переменная (пол, уровень образования, национальность, профессиональный статус). Эта переменная может быть закодирована числами, но для того, чтобы корректно применять методы статистического анализа, предназначенные для групповых сравнений (например, t-критерий), группирующая переменная должна быть факторой. Перевод в факторную переменную требуется и для создания визуализаций, если требуется группировка по уровням переменной. Эти и другие случаи мы обязательно рассмотрим в следующих разделах. 


### Вопросы для самопроверки

**1. К какому типу переменных относится число -3,5?**

```{r}
    type_data <- c(
        answer ="numeric",
       "character",
       "complex", 
       "integer"
    )
```

`r longmcq(type_data)`

**2. Какой результат получится, если попытаться превратить в число строковую переменную?**

```{r}
    string_to_number <- c(
        answer ="NA",
       "TRUE",
       "NAs introduced by coercion"
    )
```

`r longmcq(string_to_number)`

**3. Какая функция используется для проверки принадлежности переменной к факторному типу?**

```{r}
    check_factor <- c(
        answer ="is.factor()",
       "as.factor()",
       "factor()"
    )
```

`r longmcq(check_factor)`

**4. Могут ли логические переменные быть представлены в числовом виде?**

```{r}
    logical_numbers <- c(
        answer ="Да",
       "Нет",
       "Затрудняюсь ответить"
    )
```

`r longmcq(logical_numbers)`


## Структуры данных
:::callout-note
**Структура данных** — это способ организации информации для более эффективного использования. В программировании структурой обычно называют набор данных, связанных определённым образом.
:::

Основные структуры данных в R это векторы, матрицы, массивы, списки и таблицы данных.

Рассмотрим их подробнее.

![](images/DataStructures/1.png)

### Векторы

-   **Вектор** – одномерный массив проиндексированных (пронумерованных) элементов, набор однотипных элементов (либо числа, либо буквы) без их сочетания. Векторы могут быть такими же, как и типы данных - числовыми, строковыми, логическими и пр.

Вот пример того, как можно создать числовой вектор, содержащий числа от 1 до 10:

```{r vec1, echo=TRUE}
x<-1:10
x
```

А вот так - вектор с текстовыми элементами:

```{r vec2, echo=TRUE}
y<-c("Красный", "Синий", "Желтый")
y
```

Заметьте, чтобы создать вектор с наименованиями цветов, мы использовали функцию `c()`, в которой `c` является производной от`combine`. В этом есть смысл, поскольку мы соединяем, как бы "комбинируем", несколько числовых или текстовых объектов в один ряд.

::: callout-important
## Про имена

Как назвать вектор (да и другие структуры данных) правильно? Есть несколько простых правил. Имя может содержать:

-   буквы
-   числа
-   точку или символ «подчеркивания" (\_)

и обязательно должно начинаться с буквы или точки, но за точкой нельзя поставить цифру.

Так, например, имя ".2b" не является валидным, а ".b2" - вполне годится для именования.

Нельзя также использовать в именах **зарезервированные слова**,такие как `if, else, repeat, while, function, for, in, next, break, TRUE, FALSE, NULL, Inf, NaN, NA, NA_integer_, NA_real_, NA_complex_, NA_character_` некоторых других, которые являются базовыми конструкциями языка и используются в качестве аргументов при вызове функций.
:::

Например, если мы попробуем создать такой вектор, то программа выдаст ошибку:

```{r, echo=TRUE}
#| error: true
break<-1:5
```

Длину числового вектора можно определить с помощью функции `length()`:

```{r vec3, echo=TRUE}
x<-1:3
length(x)
```

Функция `class()` помогает определить, какой тип данных хранится в векторе. Напомним, что вектор содержит данные одного типа.

```{r vec4, echo=TRUE}
x<-c(1:3)
class(x)
```

Еще примеры создания логических и текстовых векторов:

```{r vec5, echo=TRUE}
y <- c(TRUE, TRUE, FALSE, TRUE)
z <- c("to", "be", "or", "not", "to", "be") 
class(y)
length(y)
class(z)
length(z)
```

::: callout-important
Если мы попытаемся соединить два вектора - числовой и строковый - то цифры "превратятся" в буквы, поскольку R автоматически переведет все элементы к наиболее подходящему общему типу данных. Поскольку слова в цифры превратить нельзя, то таким общим типом будет строковый.
:::

```{r vec6, echo=TRUE}
x<-c(1:10)
y<-c("Красный", "Синий", "Желтый")
z<-c(x,y)
x
y
z
```

То, что произошло в коде выше, называется *конверсией типов*. Такая конверсия случается тогда, когда элементы вектора разные. Запомниим, что вектор всегда хранит данные только одного типа!

А что будет, если мы соединим вместе логические и числовые?

```{r vec8, echo=TRUE}
x<-c(TRUE, 5, FALSE, 6)
x
```
Мы можем также создавать «пустые» вектора, обозначая только тип данных и количество элементов. 

Например:

```{r vec9, echo=TRUE}
empty <- numeric(10)   # Создаем пустой числовой вектор с 10 элементами
print(empty)
```

Заметьте, что даже если мы не просили R внести какие-то значения, в числовом векторе всем элементам автоматически были присвоены нули - это значение *по умолчанию*.

Вот таким образом можно создать пустые векторы других типов:

```{r, echo=TRUE}
empty_int <- integer(45)   # числовой вектор с 45 элементами
empty_cha <- character(2)  # строковый вектор с 2 элементами
empty_log <- logical(1000)    # логический вектор с 1000 элементами
```


#### Адресация и изменение элементов вектора

После того, как вектор создан, как мы можем посмотреть или изменить его элементы. Это сделать достаточно просто:

Поменять элемент в векторе:

```{r vec10, echo=TRUE}
a <- c(1, 2, 3)  # Создадим числовой вектор с 3 элементами
a[2] <- 4        # Изменим значение второго элемента на 4
a                # Посмотрим, что получилось
```

Как вы уже догадались, чтобы обратиться к какому-то элементу вектора, нужно набрать его порядковый номер в квадратных скобках \[ порядковыйномер \]:

```{r vec11, echo=TRUE}
a <- c(1, 2, 3)  # Создадим числовой вектор с 3 элементами
a[3]             # Попросим R вывести третий элемент
```

Как вы думаете, что будет если запустить следующий код? Каким будет результат?

```{r, echo=TRUE, eval=FALSE}
vec <- c(4, 5, 6)
vec[3] == 6
```

Догадались? Попробуйте теперь запустить этот код и проверить, правы вы или нет:

```{r vec12, echo=TRUE}

```

#### Операции над векторами

С векторами можно производить большое количество действий, которые позволяют те типы данных, которые в них содержатся.

Проще всего совершать арифметические действия:

```{r vec13, echo=TRUE}
a <- 3   # Создаем единичный числовой объект
a + 4  # Прибавляем к нему константу
```

Мы можем прибавить число не только к другому числу, но и ко всему вектору:

```{r vec14, echo=TRUE}
a <- c(1, 2, 3)   # Создаем числовой вектор
a + 4   # Прибавляем к нему константу
```

Такой тип "поведения" программы называется *поэлементным*. То есть операция производится над каждым элементом по отдельности.

Еще примеры:

```{r vec15, echo=TRUE}
a <- c(1, 2, 3)
a - 3 
a * 1.5
a ^ 2
a == 2
```

В последнем случае мы сравнивали каждый элемент со значением два и в результате получили новый вектор, состоящий из логических значений.

В R имеется много различных функций для трансформации, мы с ними будем активно работать на следующих занятиях. Но самая простая функциюя - `sum()`, которая просто складывает все элементы вектора вместе:

```{r vec16, echo=TRUE}
a <- c(1, 2, 3)
sum(a)
```

Некоторые операции можно производить над векторами, если у них одинаковая длина:

```{r vec18, echo=TRUE}
a <- c(1, 2, 3)
b <- c(1, 0, 1)
a + b
b * a
a ^ b

```

Мы можем даже сравнить два вектора и сохранить результат в отдельном логическом векторе

```{r vec19, echo=TRUE}
a <- c(1, 2, 3)
b <- c(1, 0, 1)
z <- a > b   # сравниваем a и b, поэлементно, результат сохраняем в векторе z
z
z == TRUE
z == FALSE
!z #выдает противоположное значение

```

А что можно делать со строковыми векторами?

Давайте создадим пару векторов и попробуем с ними совершить какие-нибудь действия, например, сравним их попарно:

```{r vec20, echo=TRUE}
a <- c("собака", "молоко", "квартира", "чай", "морозы", "душа")
b <- c("собака", "мыло", "сахар", "чай", "малина", "душа")
a==b

```

Чтобы найти какой-то текстовый элемент и его место в векторе, можно использовать функцию `grep()`:

```{r vec21, echo=TRUE}
a <- c("собака", "молоко", "квартира", "чай", "морозы", "квартира", "душа")
grep("квартира", a)

```

Результат показывает, что слово "квартира" встречается два раза, это третий и шестой элементы. Что будет, если поищем то, чего нет?

```{r vec22, echo=TRUE}
a <- c("собака", "молоко", "квартира", "чай", "морозы", "квартира", "душа")
grep("редиска", a)

```

Если векторы разного типа, то иногда с ними можно что-то сделать, иногда нет, зависит от типа данных:

```{r vec23, echo=TRUE, eval=FALSE}
a <- c(1, 2, 3)
b <- c("one", "two", "three")
c <- c(TRUE, TRUE, FALSE)
a+b
```

Ничего не получилось, потому что нельзя к словам прибавлять числа. А вот если сложить вектора a и c, все получится:

```{r vec23_1, echo=TRUE}
a <- c(1, 2, 3)
b <- c("one", "two", "three")
c <- c(TRUE, TRUE, FALSE)
a+c
```

#### Некторые полезные функции для работы с векторами

-   Создать вектор случайных чисел в определенном диапазоне:

```{r vec24, echo=TRUE}
x <- runif(10, min = -5, max = 5)
x
```

-   Создать вектор с повторяющимися значениями с помощью функции `rep()` – повторить (что, сколько раз):

```{r vec25, echo=TRUE}
b<- rep(c(1,2,3),4)
b
```

-   Создать вектор из повторяющихся значений определенной длины с помощью функции `rep()` – повторить (что, до каких пор, какой длины):

```{r vec26, echo=TRUE}
c<- rep(c(4,5,6), length.out=10)
c
```

-   Создать вектор через последовательность определенных значений с помощью функции `seq()` – задать последовательность (от, до, с каким шагом)

```{r vec27, echo=TRUE}
seq <- seq(from=2,to=15,by=0.5)
seq
```

-   Проверить, является ли какой-то объект вектором с помощью функции `is.vector()` :

```{r vec28, echo=TRUE}
seq <- seq(from=2,to=15,by=0.5)
is.vector(seq)
```

-   Проверить, удовлетворяет ли хотя бы один элемент вектора какому-либо условию с помощью функции `any()`:

```{r vec29, echo=TRUE}
vec <- as.integer(c(34,23,53,42,16,42,64,32,76))
any(vec,vec>50)
```

-   Проверить, удовлетворяют ли все элементы вектора какому-либо условию с помощью функции `all()`:

```{r vec30, echo=TRUE}
vec <- as.integer(c(34,23,53,42,16,42,64,32,76))
all(vec,vec>10)
```

-   Применить какую-либо функцию преобразования ко всем элементам вектора с помощью функции `sapply()`:

```{r vec31, echo=TRUE}
vec <- as.integer(c(34,23,53,42,16,42,64,32,76))
vec3<-sapply(vec, sqrt)
vec3
```

В принципе, можно это сделать и проще:

```{r vec32, echo=TRUE}
vec <- as.integer(c(34,23,53,42,16,42,64,32,76))
sqrt(vec)
```

Но иногда, когда у нас не вектор, а более сложный объект, функция `sapply()` и ее родные сестры `apply()` и `lapply()`часто очень выручают. Подробнее эти функции будут рассмотрены на следующих занятиях.

### Матрицы

-   **Матрица** – двумерная совокупность числовых, логических или текстовых величин. Чтобы создать матрицу, нужно воспользоваться функцией matrix(). Можно думать о матрице как о решетке каких-то числовых величин.

Простой пример:

```{r mat1, echo=TRUE}
data <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)
A <- matrix(data, ncol=3, nrow=3)
A

```

Мы создали матрицу с тремя строками и тремя колонками на основе данных, изначально хранящихся в виде числового вектора.

::: callout-important
R заполняет матрицу сверху вниз, колонку за колонкой, двигаясь справа налево.
:::

Если мы хотим это изменить, нужно поменять параметр `byrow`:

```{r mat, echo=TRUE}
data <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)
A <- matrix(data, ncol=3, nrow=3, byrow = T)
A

```

#### Полезные функции и операции над матрицами

-   Как обратиться к одному из элементов матрицы? В случае с вектором мы задавали один элемент в квадратных скобках, а что теперь? Матрица - двумерный объект, поэтому мы должны теперь в квадратных скобках задать две координаты - номер строки (первое число) и номер колонки (второе число) - через запятую:

```{r mat2, echo=TRUE}
data <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)
A <- matrix(data, ncol=3, nrow=3, byrow = T)
A
A[1,1] # Первый элемент первой строки
A[2,3] # Третий элемент второй строки
A[1,]  # Первая строка полностью
A[,3]  # Третий столбец полностью
```

Чтобы получить диагональные элементы, есть специальная функция - `diag()`

```{r mat3, echo=TRUE}
data <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)
A <- matrix(data, ncol=3, nrow=3, byrow = T)
diag(A)
```

Чтобы узнать размерность матрицы (количество строк и столбцов) - можно использовать функцию `dim()`:

```{r mat4, echo=TRUE}
data <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)
A <- matrix(data, ncol=3, nrow=3, byrow = T)
dim(A)
```

В результате применения функции мы получаем числовой вектор, первое значение в котором обозначает количество строк, второе - столбцов.

С матрицами, как и с векторами, можно совершать разные математические операции - сложение, умножение, вычитание и т.д.:

-   Например, прибавить единицу к каждому элементу матрицы:

```{r mat6, echo=TRUE}
data <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)
A <- matrix(data, ncol=3, nrow=3, byrow = T)
A
A + 1   
```

-   Умножить каждый элемент на 2:

```{r mat7, echo=TRUE}
data <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)
A <- matrix(data, ncol=3, nrow=3, byrow = T)
A
A * 2
```

-   Возвести в квадрат:

```{r mat8, echo=TRUE}
data <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)
A <- matrix(data, ncol=3, nrow=3, byrow = T)
A
A^2
```

-   Довольно часто возникает необходимость транспонирования, когда строки становятся столбцами и наоборот:

```{r mat9, echo=TRUE}
data <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)
A <- matrix(data, ncol=3, nrow=3, byrow = T)
A
t(A)
```

-   Найдти след матрицы

:::callout-note
*След матрицы** - это сумма диагональных элементов.
:::
```{r mat10, echo=TRUE}
data <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)
A <- matrix(data, ncol=3, nrow=3, byrow = T)
sum(diag(A))
```

-   Сложить две матрицы

```{r mat11, echo=TRUE}
data <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)
A <- matrix(data, ncol=3, nrow=3, byrow = T)
B <- matrix(1, 3, 3)
A + B
```

Заметьте, как мы это сделали: мы создали матрицу В одной строкой (матрица 3\*3, состоящая из одних единиц).

-   Перемножить элементы двух матриц:

```{r mat12, echo=TRUE}
data <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)
A <- matrix(data, ncol=3, nrow=3, byrow = T)
B <- matrix(2, 3, 3)
A * B
```

-   Осуществить матричное умножение:

```{r mat13, echo=TRUE}
data <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)
A <- matrix(data, ncol=3, nrow=3, byrow = T)
B <- matrix(2, 3, 3)
A %*%  B
```

В чем разница между двумя умножениями? В первом случае элементы поэлементно умножаются друг на друга, во втором - происходит умножение матриц по законам линейной алгебры.


### Массивы

-   **Массив (array)** – объект в R, в котором хранится данные, содержащие более двух измерений. Например, если мы создадим массив с параметрами (2, 3, 4), у нас получится 4 прямоугольные матрицы размером 2 на 3. В массивах хранятся данные только одного типа.

Для того, чтобы создать массив, есть специальная функция `array()`. Она принимает на входе вектора и использует значения параметра `dim`, чтобы создать массив.

Пример:

```{r arr1, echo=TRUE}
vector1 <- c(5,9,3)
vector2 <- c(10,11,12,13,14,15)
arr1 <- array(c(vector1,vector2),dim = c(3,3,2))
arr1
```

Мы можем присвоить имена строкам, колонкам и матрицам массива с помощью параметра `dimnames`:

```{r arr2, echo=TRUE}
vector1 <- c(5,9,3)
vector2 <- c(10,11,12,13,14,15)
column.names <- c("COL1","COL2","COL3")
row.names <- c("ROW1","ROW2","ROW3")
matrix.names <- c("Matrix1","Matrix2")
result <- array(c(vector1,vector2),dim = c(3,3,2),dimnames = list(row.names,column.names,
   matrix.names))
result
```

#### Операции с элементами массива

Так как массив - это по сути совокупность нескольких матриц, то и операции мы с массивами мы можем производить практически такие же.

-   Обращение к элементам

Обращение к элементам массива практически такое же, как и в случае с матрицами, чуть сложнее, поскольку добавляются новые измерения, но общая логика остается та же - мы в квадратных скобках указываем координаты элемента, которые нам нужны:

```{r arr3, echo=TRUE}
vector1 <- c(5,9,3)
vector2 <- c(10,11,12,13,14,15)
column.names <- c("COL1","COL2","COL3")
row.names <- c("ROW1","ROW2","ROW3")
matrix.names <- c("Matrix1","Matrix2")
result <- array(c(vector1,vector2),dim = c(3,3,2),dimnames = list(row.names,column.names,
   matrix.names))
result[3,,2] # Третья строка второй матрицы
result[1,3,1] # Третий элемент первой строки первой матрицы
result[,,2] #Вся вторая матрица
```

-   Создание матрицы на основе массива:

```{r arr4, echo=TRUE}
vector1 <- c(5,9,3)
vector2 <- c(10,11,12,13,14,15)
column.names <- c("COL1","COL2","COL3")
row.names <- c("ROW1","ROW2","ROW3")
matrix.names <- c("Matrix1","Matrix2")
array1 <- array(c(vector1,vector2),dim = c(3,3,2),dimnames = list(row.names,column.names,
   matrix.names))
matrix1 <- array1[,,1]
matrix2 <- array1[,,2]
matrix1
matrix2
```

-   Арифметические действия с элементами:

```{r arr5, echo=TRUE}
vector1 <- c(5,9,3)
vector2 <- c(10,11,12,13,14,15)
column.names <- c("COL1","COL2","COL3")
row.names <- c("ROW1","ROW2","ROW3")
matrix.names <- c("Matrix1","Matrix2")
array1 <- array(c(vector1,vector2),dim = c(3,3,2),dimnames = list(row.names,column.names,
   matrix.names))
array1[1,2,1]+array1[3,2,2]
```

### Списки (lists)

Список(list) - сложный объект, в котором могут храниться данные разных типов и структуры, включая вектора, матрицы и т.д.

Пример:

```{r list1, echo=TRUE}
A <- list("Red", "Green", c(21,32,11), matrix(c(1:9), nrow=3, ncol=3), TRUE, 51.23, 119.1)
A
```

Списки могут даже содержать внутри другие списки!

```{r list2, echo=TRUE}
A <- list("Red", "Green", c(21,32,11), matrix(c(1:9), nrow=3, ncol=3), TRUE, 51.23, 119.1)
A[[8]]<-list("One", 256, TRUE)
A
```

Компоненты списка также могут иметь имена:

```{r list3, echo=TRUE}
A <- list("Red", "Green", c(21,32,11), matrix(c(1:9), nrow=3, ncol=3), TRUE, 51.23, 119.1)
A[["color"]] <- "yellow"
A

```

Таким образом, обратиться к компоненту списка можно по имени или по порядковому номеру элемента:

```{r list4, echo=TRUE}
A <- list("Red", "Green", c(21,32,11), matrix(c(1:9), nrow=3, ncol=3), TRUE, 51.23, 119.1)
A[["color"]] <- "yellow"
A[["color"]]
A$color #Альтернативный вариант обращения по имени
A[[8]]
```

### Таблицы данных (data frame)

Для аналитиков данных это самый важный объект, с которым приходится работать чаще всего. Большинство из тех данных, с которыми нам приходится иметь дело, хранятся именно в формате датафрейма.

Таблица данных (data frame) - может включать данные разного типа, но только по столбцам. Иными словами, в таблице может быть несколько типов данных, но в каждом столбце может быть только один тип.

Пример:

```{r df1, echo=TRUE}
df <- data.frame(
  age        = c(25, 34, 42, 29),
  gender     = c("мужчина", "женщина", "мужчина", "женщина"),
  education  = c("высшее", "среднее", "высшее", "среднее специальное"),
  prof_status = c("работающий", "занятый на производстве", "пенсионер", "работающий")
)
df
```

Обращаться к элементам таблицы данных можно точно так же, как и к элементам матрицы:

```{r df2, echo=TRUE}
df[1,4]
```

Чтобы добавить новую переменную, нужно использовать знак `$`:

```{r df3, echo=TRUE}
df$region <- c("Алтайский край", "Кемеровская область", "Новосибирская область", "Красноярский край")
df
```

С помощью этого же знака, можно вывести все значения той или иной переменной:

```{r df4, echo=TRUE}
df$education
```

Чтобы узнать размерность таблицы, можно воспользоваться уже известной нам функции `dim()`:

```{r df5, echo=TRUE}
dim(df)
```

Если у нас есть список векторов, мы можем их легко трансформировать в датафрейм:

```{r df6, echo=TRUE}
people <- list(name=c("Анна Власова", "Петр Гордеев", "Андрей Павлов"), 
               grade=c(99.4, 87.6, 22.1), 
               sex=c("женский", "мужской", "мужской"))
as.data.frame(people)
```

В R содержатся много загруженных наборов данных, таких например, как swiss`, в котором содержатся данные рождаемости, образовании, доли католического населения, младенческой смертности в кантонах Швейцарии:

```{r df7, echo=TRUE}
head(swiss)
```
```{r df7a, echo=TRUE, eval=FALSE}
swiss
```

Самые простые операции с таблицами данных заключаются в выводе данных, наименований строк и столбцов.

Как вывести первые несколько наблюдений?

```{r df8, echo=TRUE}
head(swiss)
```

Как вывести последние несколько наблюдений?

```{r df9, echo=TRUE}
tail(swiss)
```

Какие переменные содержатся в наборе mtcars?

```{r df10, echo=TRUE}
names(mtcars)
```

Ну, и напоследок, представим сводку о данных, содержащихся в этом наборе:

```{r df11, echo=TRUE}
summary(swiss)
```

## Самостоятельная работа

:::callout-alert
Напоминаем, что для выполнения интерактивных самостоятельных работ, необходимо установить пакет `r4ssr`.
:::

```{r echo=T, eval=FALSE}
devtools::install_github("domelia/r4ssr", dependencies=TRUE)
```

Для выполнения интерактивной самостоятельной работы по данному разделу скопируйте и запустите следующий код:

```{r echo=T, eval=FALSE}
learnr::run_tutorial("Assignment1", package="r4ssr")
```


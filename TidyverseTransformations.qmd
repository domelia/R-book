---
title: Tidyverse и трансформация данных
---

В рамках данного занятия мы будем работать с библиотекой [tidyverse](https://www.tidyverse.org/), объединяющей возможности нескольких других библиотек и воплощающей общую философию, дизайн и грамматику обработки и анализа данных, разработанную RStudio: ![](https://hbctraining.github.io/Intro-to-R/img/tidyverse_website.png)

Основные библиотеки семейства tidyverse:

-   **ggplot2** - библиотека для создания разнообразных визуализаций на основе пользовательских данных и заданных настроек.
-   **dplyr** - библиотека для основных трансформаций данных (отбор, фильтрация, группировка, создание новых переменных, описательный анализ).
-   **tidyr** - набор функций для подготовки данных к анализу (транспонирование, переструктурированые данных).
-   **readr** работа с данными прямоугольного формата, представленными в формате csv, tsv или fwf.
-   **tibble** - специальная библиотека для работы с датафреймами.
-   **stringr** - набор функций для работы со строковыми переменными.
-   **forcats** - библиотека для работы с факторными (категориальными - номинальными и порядковыми) перемннными.

::: callout-tip
## Tidyverse - все нужные библиотеки в одном месте!

На предыдущем занятии мы осуществляли импорт и экспорт данных, используя некоторые библиотеки, входящие во вселенную `Tidyverse`. Загружая библиотеку Tidyverse, мы автоматически загружаем все остальные, и потребность в загрузке отдельных библиотек отпадает.
:::

## Прямоугольные и непрямоугольные таблицы, а также tidy и messy данные

Данные могут быть представлены в различных формах, но на самом базовом уровне их можно представить в виде двух типов структур: данные представленные в виде прямоугольных таблиц и непрямоугольных данных.

Прямоугольные данные имеют форму прямоугольника (действительно!), то есть каждое значение соответствует какой-то строке и столбцу. Большинство датафреймов содержат как раз прямоугольные данные.

Соответственно непрямоугольные данные не могут так легко распределяться по строкам и столбцам, они, как правило, представляют собой совокупность различных структур данных, в которых между отдельными элементами имеется какое-то сходство. Обычно непрямоугольные данные хранятся в списках.

**Tidy** по-английски означает "чистый, аккуратный, опрятный". По отношению к данным выражение - tidy data - "чистые, правильным образом представленные данные" противопоставляется "messy data" - "грязным данным", представленным в виде, не совсем пригодном или удобном для анализа.

`Tidy data` - это когда данные имеют так называемый "длинный формат" - каждый столбец представляет собой отдельную переменную, а строка - наблюдение или случай.

![](https://www.researchgate.net/publication/338569186/figure/fig1/AS:847073150775297@1578969385585/The-wide-versus-tidy-data-format-for-time-dependent-data-In-the-wide-spreadsheet-like.png){width="400"}

Как из «грязных» данных сделать чистые? Как привести набор данных к виду, пригодному для дальнейшего анализа, отобрать нужные переменные, преобразовать их в формат, который нужен для решения аналитической задачи?

В рамках данного раздела будут рассмотрены функции, которые используются для трансформации данных - их чистки, фильтрации, вычисления новых переменных и описательных статистик, а также перевода набора данных из «широкого» в «длинный» и обратно.

В основном мы будем работать с двумя библиотеками семейства `tidyverse` - `dplyr` и `tidyr`.

![](https://dplyr.tidyverse.org/logo.png), ![](https://tidyr.tidyverse.org/logo.png)

Эти библиотеки является одними из лучших для разнообразных трансформаций данных, потребность в которых возникает постоянно в процессе анализа.

Рассмотрим основные функции библиотек на примере набора данных `flights` из библиотеки - `nycflights13`, в котором содержится информация о 336 776 полетах, совершенных из аэропорта Нью-Йорка в 2013 году. Данные предоставлены Бюро по статистике США, справку по ним можно найти по запросу `?flights`.

## Фильтрация строк - filter()

Установим библиотеки:

```{r eval=FALSE, message=FALSE}
install.packages(c("nycflights13", "tidyverse"))
```
Теперь загрузим их в наше рабочее пространство:

```{r message=FALSE}
library(tidyverse)
library(nycflights13)
```

В наборе данных `flights` содержится следующая информация о переменных:

-   year (год), month (месяц), day (день) - дата вылета
-   dep_time - время вылета
-   arr_time - время прилета
-   sched_dep_time, sched_arr_time - время вылета и прилета по расписанию.
-   dep_delay, arr_delay - задержка вылета и прилета в минутах. Отрицательные значения означают досрочные вылеты / прилеты.
-   carrier - перевозчик
-   flight - номер рейса
-   tailnum - номер самолета
-   origin, dest - место отправления, место назначения
-   air_time - время полета в минутах
-   distance - расстояние в милях
-   hour, minute - часов, минут - время отлета, разбитое по часам и минутам
-   time_hour - дата и время полета по расписанию в формате даты.

Давайте сначала просто посмотрим на эти данные:

```{r}
head(flights)
```

Функция `filter()` позволяет отобрать наблюдения, основываясь на значениях. Первый аргумент - имя датафрейма (массива, базы данных), второй и последующие аргументы - выражения, позволяющие отфильтровать данные. Например, мы хотим отобрать все полеты, которые произошли 1 января:

```{r}
filter(flights, month == 1, day == 1)
```

Когда мы запускаем эту строку с кодом, `dplyr` выполняет фильтрующую операцию и выводит новый датафрейм. Однако, стоит учитывать, что исходные данные не меняются, и если нам необходимо сохранить эти изменения как отдельный объект, нам нужно использовать оператор присваивания, \<-, и задать новое имя:

```{r}
jan1 <- filter(flights, month == 1, day == 1)
```

R либо выводит на экран результаты либо сохраняет их в новую переменную (объект). Если мы хотим одновременно создать новую базу данных, сохранить в нее результаты фильтрации и вывести результат на экран, нужно код заключить в скобки:

```{r}
(dec25 <- filter(flights, month == 12, day == 25))
```

## Логические операторы

Очень часто функция `filter()` сопровождается логическими операторами ("и", "или" и др.). В этом случае, результат каждого выражения должен быть истинным, для того, чтобы строки были отобраны в новый набор.

::: callout-tip
##Запомним основные операторы:

**&** это “и”

**\|** это “или”

**!** “не равно”
:::

Графически различия между операторами можно представить следующим образом:

![](https://d33wubrfki0l68.cloudfront.net/01f4b6d39d2be8269740a3ad7946faa79f7243cf/8369a/diagrams/transform-logical.png)

Например, давайте отфильтруем данные так, чтобы у нас отображались два месяца - ноябрь и декабрь.

```{r}
filter(flights, month == 11 | month == 12)
```

Для некоторого упрощения кода полезно будет запомнить ["законы де Моргана"](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BA%D0%BE%D0%BD%D1%8B_%D0%B4%D0%B5_%D0%9C%D0%BE%D1%80%D0%B3%D0%B0%D0%BD%D0%B0):

!(x & y) это то же самое, что и !x \| !y,

!(x \| y) равносильно !x & !y.

Например, если нам нужно отобрать полеты, которые задерживались (по прилетам и отлетам) не более чем на два часа, мы могли бы пойти двумя путями:

```{r}
filter(flights, !(arr_delay > 120 | dep_delay > 120))
# Или (результат идентичный)
filter(flights, arr_delay <= 120, dep_delay <= 120)
```

{{< iconify arcticons writer size=42px >}} **Самостоятельное задание**:

1.  Создайте набор данных `arr_depay_over120`, в который отберите рейсы, прилет которых (arr_delay) задерживался на 2 или более часа.
2.  Выгрузите данные о рейсах в аэропорты Хьюстона -  George Bush Intercontinental (IAH) или аэропорт William P Hobby (HOU) (по переменной `dest`) и сохраните их под именем `IAH_OR_HOU`.
3.  Отберите из таблицы все полеты, которые совершались в летние месяцы, и сохраните их под именем `summer_flights`.

## Упорядочение строк с функцией arrange()

Функция `arrange()` работает практически идентично с `filter()`, однако, вместо отбора строк она меняет их порядок. На входе функция берет датафрейм и наименования столбцов, по которым нужно сделать сортировку.Если таких столбцов несколько, каждая дополнительная колонка может быть использована для сортировки значений по уже отсортированным значениям предыдущего столбца.

Например, отсортируем полеты по дате (сначала по месяцу, потом по дню):

```{r}
arrange(flights, month, day)
```

Если нам нужно отсортировать что-то по убыванию, то функция `desc()` поможет нам перегруппировать значения в столбце. Например, отсортируем по убыванию значения задержки отлета:

```{r}
arrange(flights, desc(dep_delay))
```

\*\* ! Пропущенные значения (NA) - всегда располагаются в конце списка, независимо от направления сортировки\*\*. Давайте воспроизведем это свойство на примере, содержащем небольшое количество строк:

```{r}
df <- tibble(x = c(5, 2, NA))
arrange(df, x)
arrange(df, desc(x))
```

{{< iconify arcticons writer size=42px >}} **Самостоятельное задание**:

1.  Отсортируйте полеты, чтобы найти те, что имеют наибольшие значения времени задержки прилета (`arr_delay`). Найдите также полеты, которые вылетели раньше времени по расписанию (вспоминаем функцию `tail()`).
2.  Найдите самые короткие (быстрые) полеты по переменной `air_time`.


## Отбор переменных с функцией select()

Достаточно часто нам для анализа не нужен весь наш набор данных, а только ограниченный набор переменных, с которыми мы работаем в какой-то момент времени. Удобно и полезно отобрать эти переменные и работать только с ними, особенно - если данных очень много, и количество переменных исчисляется сотнями или тысячами. Функция `select()` позволяет быстро отобрать переменные по их именам:

```{r}
select(flights, year, month, day)
```

```{r}

select(flights, year:day) # если переменные идут подряд, не обязательно перечислять все, можно воспользоваться оператором :
```

```{r}
select(flights, -(year:day))# знак минуса используется для того, чтобы, наоборот, исключить какие-то переменные
```

Есть еще несколько полезных функций, которые идут в паре с select() и делают жизнь проще:

`starts_with("abc")`: имена переменных начинаются на “abc”.

`ends_with("xyz")`: имена переменных заканчиваются на “xyz”.

`contains("ijk")`: имя переменной содержит “ijk”.

Иногда, в процессе обработки нам требуется переименовать переменную другим способом. Для этой цели подходит функция `rename`:

```{r}
rename(flights, tail_num = tailnum)
```

{{< iconify arcticons writer size=42px >}} **Самостоятельное задание**:

1.  Использовать все возможные способы для того, чтобы отобрать переменные dep_time, dep_delay, arr_time и arr_delay.
2.  Что случится, если Вы включите одну и ту же переменную несколько раз в запрос функции select()?


## Создаем новую переменную с функцией mutate()

Да, сейчас явно что-то будет про мутации)))

Помимо того, что в процессе анализа нам приходится что-то постоянно отбирать (например, только жителей сел или городов, какой-то регион исследования, лиц определенного возраста и пола), частенько приходится вычислять новые переменные на основе старых - высчитывать возраст, средний доход, количество детей и т. д.

В этом нам может помочь функция `mutate()`.

Важно: новые переменные могут быть созданы только на основе тех, которые уже есть в вашем наборе.

Пример: создадим новый набор `flights_sml`, куда отберем переменные даты полета, расстояние и переменные, оканчивающиеся на "delay". Затем, содадим две новых переменных: - скорость (speed) - количество минут, которые самолет смог догнать при задержке рейса (как разность между задержкой вылета и прилета) (gain).

```{r}
flights_sml <- select(flights,
  year:day,
  ends_with("delay"),
  distance,
  air_time
)
mutate(flights_sml,
  gain = dep_delay - arr_delay,
  speed = distance / air_time * 60
)
```

Отметим, что мы можем "не отходя от кассы" использовать новые переменные в последующих расчетах для создания других переменных. Например, давайте создадим переменную gain (см. пример выше), но и посчитаем время полета в часах и среднее количество минут, которое нагонял самолет каждый час:

```{r}
mutate(flights_sml,
  gain = dep_delay - arr_delay,
  hours = air_time / 60,
  gain_per_hour = gain / hours
)
```

## Самостоятельное задание:

1.  Сравните air_time и arr_time - dep_time. Что мы можем увидеть? Какие выводы сделать?
2.  Сравните dep_time, sched_dep_time и dep_delay. Как эти переменные связаны друг с другом?

## Анализ по группам с функциями `summarise()` и `group_by()`

Последняя функция, которую мы изучим в рамках данного урока, `summarise()`. Как следует из названия, ее предназначение - рассчитывать какие-то новые значения на основе разнообразных функций - арифметических, статистических и др. Например, посчитаем среднее количество минут задержки вылета:

```{r}
summarise(flights, delay = mean(dep_delay, na.rm = TRUE))#na.rm = TRUE - данный аргумент удаляет из анализа все пропущенные значения (na - not avaliable, rm - remove), в противном случае вычисление среднего не возможно.
```

Функция `summarise()` часто идет в паре с другой функцией - `group_by()`, позволяющей провести анализ в отдельных подгруппах. Соответственно, когда мы применяем функции dplyr к сгруппированным данным, они автоматически рассчитываются для каждой подгруппы по отдельности. Например, мы можем применить код из примера выше, но предварительно сгруппировать данные по месяцам. Получится следующее:

```{r}
#| colab: {base_uri: 'https://localhost:8080/', height: 475}
flights %>%
group_by(month) %>%
summarise(delay = mean(dep_delay, na.rm = TRUE))
```

|                               |
|-------------------------------|
| Стоп! Что за новый знак %\>%? |

Это оператор, который позволяет сократить код и написать его по типу "матрешки". По-английски это называется "pipe-operator", здесь явная аналогия с телескопическими трубами, которые собираются вместе путем нехитрой сборки. Так и наши различные функции dplyr следуют друг за другом уже без лиших аргументов и дублирования информации о наборе данных, лишних скобок и знаков \$, с помощью которых мы вводим имя переменной из набора. Код становится более читаемым и быстрым.

Графически это можно представить вот так:

![](https://i0.wp.com/www.rforecology.com/pipes_image0.png?w=584&ssl=1)

Приведем еще один пример: в наборе по полетам проведем группировку по месту назначения и посчитаем общее количество полетов, среднее расстояние и среднюю задержку рейсов в минутах, а также отфильтруем дни, в которых было более 20 полетов. И все это - в нескольких строчках кода:

```{r}
#| colab: {base_uri: 'https://localhost:8080/', height: 1000}
delays <- flights %>%
  group_by(dest) %>%
  summarise(
    count = n(),
    dist = mean(distance, na.rm = TRUE),
    delay = mean(arr_delay, na.rm = TRUE)
  ) %>%
  filter(count > 20, dest != "HNL")
delays
```

Другие полезные функции: - median() - медиана - sd() - стандартное отклонение - min() - минимум - max() - максимум - first() - первое значение - nth() - значение определенного порядка (2, 3 и т.д.) - last() - последнее - n() - количество, размер группы - n_distinct() - количество уникальных значений

Например:

```{r}
#| colab: {base_uri: 'https://localhost:8080/', height: 1000}
flights %>%
na.omit() %>% #na.omit() - опускает пропущенные значения
group_by(year, month, day) %>%
  summarise(
    first_dep = first(dep_time),
    last_dep = last(dep_time)
  )
```

Еще пример: сгруппируем полеты по месту назначения и посчитаем уникальных перевозчиков, отсортировав нашу таблицу по месту назначения.

```{r}
flights %>%
na.omit() %>%
group_by(dest) %>%
  summarise(carriers = n_distinct(carrier)) %>%
  arrange(desc(carriers))
```

## Сочетание нескольких трансформаций (mutate, filter, summarise)

Группировка обычно сопутствует функции summarise(),но ее также можно сочетать с mutate() и filter():

Например, мы хотим найти наиболее популярные направления:

```{r}
popular_dests <- flights %>%
  group_by(dest) %>%
  filter(n() > 365)
popular_dests
```

## Самостоятельная работа

Для каждого направления посчитайте общее количество минут задержки рейсов.

```{r}
# Напишите свой код здесь.
```
